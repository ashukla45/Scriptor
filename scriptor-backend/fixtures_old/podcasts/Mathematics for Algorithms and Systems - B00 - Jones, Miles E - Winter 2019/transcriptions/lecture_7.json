{
    "Blurbs": {
        "+ 1 Okay. And then that's it questions about that. Yeah. so that's because if the algorithm output 0 then that means I went through the loop the loop all the way. Which means I never went into that. If statement that if statement never was true. So that it can't be true for the next one. I know it may seem like it's kind of like a backwards way ": [
            2125.1,
            2175.9,
            52
        ],
        "1 are all smaller. Then 80 + 2 up to a n which is which is what we want, right? That's what we want the loop invariant to be any questions about that. Let's just do that and then just work here. Okay, now let's do one. Okay, A 1 through 80 are in sorted order. This is from the induction hypothesis. 80 + 1 is bigger. Then a 1 ": [
            1158.2,
            1229.1,
            29
        ],
        "1. Okay, so let's move on. now if you are an organized maybe your DVD collection looks like this in which case if I want to find a DVD and it's all out of order and I don't know how they were ordered. Then I might have to go through each one until I find the one I want right if I want it if I wanted to watch Philadelphia, ": [
            1547.3,
            1579.1,
            38
        ],
        "3 so don't forget 3, this is easily looked over. This is the step where you show that the algorithm is. Actually correct based on what you found with the loop invariant. Case let's go back to selection sort men's store, which is fine the smallest one and put it to the front. And here is the pseudocode. But what I like better is kind of the mid-level pseudocode because ": [
            221.5,
            252.6,
            5
        ],
        "And so what's the best way to minimize the maximum size of the list? Start from the middle, right? Because that means that you know, if you go anywhere from left to right of the middle than one of your list is going to grow bigger. So middle is going to be the best. Okay, so probe in the middle, so if we're searching a subarray, I threw AJ probat ": [
            2720.6,
            2749.3,
            68
        ],
        "BB and then but it could be the case that is not even in the list right? Maybe this dictionary, you know doesn't have any I wasn't I was going to say doesn't have any animals, but then I already said that there was Puma. Maybe lion wasn't a word yet or something. And so it didn't occur in the dictionary. Okay, so I'm just going to skip the last ": [
            2634.8,
            2660.0,
            65
        ],
        "I is less than or equal to P is less than or equal to Jay that implies that I is equal to J is equal to p and if you see back in the algorithm. if that's the case then we would neither should be less than or equal to. when we get down to I guess let me just put it in another line here then. if x is ": [
            3566.1,
            3632.9,
            88
        ],
        "I kind of numbered them wrong to sorry. So this is actually two and this is one. Okay. So this is the end three is the end. So that's it. Good done. Okay, let's move on. AutoCAD another type of problem. Why do you want to sort? Well remember when I said it's easier to find things in a sorted list. So we're going to talk about now how to ": [
            1423.6,
            1456.2,
            35
        ],
        "Listen to a podcast. Okay, good evening, everyone. Where is the Okay, so let's get started. so what we're doing today is basically learning how to prove it already of algorithms are correct using something called a loop invariant examples. I don't know if we're going to get to all of them today. We're going to start a selection sort. I think we already talked about it a little bit. ": [
            1.9,
            90.0,
            0
        ],
        "Okay, good A 1 through 80 are the smallest. Some algorithms you're going to only need one Loop invariant this one you need to and you'll sort of see why when we go through the proof of induction. questions about that All right, so that's what I have first two elements are sorted and they and they are the smallest. Okay, so. That's the first step coming up with the ": [
            325.4,
            356.2,
            8
        ],
        "Okay, which means that it's not in all of those? It's not equal to a 1 through 880 age. Okay. Remember we're under this assumption that the algorithm output 0 which means that it can't ever stop in the loop, right? Which means that it will never let me go back to the real fast. It will never execute this return state. then it wouldn't get to the end and ": [
            1974.4,
            2011.1,
            49
        ],
        "So basically what we want to do. Is given an algorithm which is a sequence of steps or it's a set of instructions step by step how to do something or how to give in a given some information how to Output another type of information. Right? And usually your algorithm wants to do something with the information whether it be Maybe determine if the input has a property or ": [
            90.0,
            121.6,
            1
        ],
        "The smallest integer W. That is sure to be greater than login is the floor of log base 2 of n + 1. So I at least have to do that many probes. So this is the worst case scenario by comparison linear search takes as many as an ore on average and over 200 even in the average case. Binary search is much better than linear search. But what ": [
            3789.2,
            3826.5,
            92
        ],
        "You want to find an index Jay where X is equal to a j or if no such index exists. We're just going to return 0. It's up, for example if this was my list. And X is equal to 1 what J would the search problem find? Okay, good beef Zachary. Okay, so it's going to Output the index right so4 is the index of where is equal to ": [
            1484.5,
            1547.3,
            37
        ],
        "a loop invariant often times. The loop invariant is related to the problem algorithm is supposed to do often times. It's kind of like sort of a sub problem on a smaller input. Then the next thing is to prove that it is correct by using induction. That proves that the loop invariant is correct. That doesn't necessarily prove that the album algorithm is correct. You need this last part ": [
            184.3,
            221.5,
            4
        ],
        "a nonzero number, that means that I must have Executed this line in the only way to execute that line is if x is actually equal to one of the values. Okay good. Okay. Now here is sort of the loop invariant one where we have to do an induction if the binary search return 0 then there is no position P for which AP is equal to X. I ": [
            3022.1,
            3052.4,
            77
        ],
        "about Andover too, and we'll just we're just going to kind of skip over the reasoning for that until we get to probability. Okay, that would be the expected run time. for the expected number of probes Okay, so that's good. Let's keep that in the back of our mind. Searching a sorted array now if the array is sorted. How would you search through a pile of alphabetize papers ": [
            2405.7,
            2434.3,
            59
        ],
        "about that Okay, so that's what we have. Let's let's still in the base case in the hypothesis and induction step. Okay the base case. Let's do after zero iterations, which means before the before the loop. Jersey right away shins. This is before the loop. It's saying that X is not in the set of a one up to a zero with his just the empty set. And that's ": [
            1854.4,
            1896.8,
            47
        ],
        "actually prove the contrapositive of the statement. What's the contrapositive? if there is a p Such that. AP is equal to X then what? Write binary search does not returned zero. Doubts are comments on that. Okay, good. Let's prove this. Okay. So the loop invariant I'm going to prove is suppose that there is a position P then I claim that P is always going to be an in-between ": [
            3081.9,
            3147.0,
            79
        ],
        "algorithm is, correct? So let's read through them we have Since the First Tee elements are the T smallest men's short is correct, since we execute the loop, at least once the first element at the end of the algorithm is the smallest and so Min sort is correct, since we execute the loop exactly end times the loop invariant with t equals and guarantees that all and elements of ": [
            392.8,
            419.9,
            10
        ],
        "an integer. That's what I'm trying to look for. When I go to the loop start. I from one if x is equal to a i at any point then just stop and return. I otherwise I'll go through the whole Loop up until n and then return 0. pet questions about that Okay song. What's the loop invariant for this algorithm? Okay good after T. Adorations, right? If you've ": [
            1643.0,
            1686.3,
            41
        ],
        "are Loop invariant said it said after T. Iteration something is true. So if I if I said t is equal to 0 that means that it's happening before the loop even happens. Is that Loop invariant true and we're going to see what that looks like. If you want you could start this induction at T is equal to 1 and that would be after the first kind of ": [
            622.8,
            649.2,
            16
        ],
        "array somewhere what position for X will cause linear search to take the longest amount of time. Okay, good. Excellent. Okay, the last element right just like looking through my DVDs right the last element. I have to look at every single one. So if it's the first element I can I can break out of that Loop because I have that return statement. So it might might be only ": [
            2275.8,
            2324.1,
            56
        ],
        "be? and the actual size of the input T the number of times we go through the Outer Loop or I the index of the smallest element or d none of the above. Okay, what sort of have? Kind of a MB or sort of the top to hear. Let's talk about that for a second. Then we're going to do this proof. We're going to fix the number of ": [
            510.6,
            551.7,
            13
        ],
        "because basically want to say that the loop invariant it's true after every iteration. So that means it's true after the last iteration. If it's too rough to the last iteration, that should show the Falcon this right? We'll revisit that after we do the proof. Okay, let's do this induction. So what's going to be the induction variable? What are we going to induct on? Is it going to ": [
            474.6,
            510.6,
            12
        ],
        "binary search, but every time you run a duration you divide the length of the list in half, right? So the sub array gets divided by two or four than the 816 all the way down. If I've done W many probes. What's the size of my sub array? 10 / 2 to the W Okay good. So what I want to do is do as many Pros I need ": [
            3674.0,
            3718.3,
            90
        ],
        "can conclude that. It's true for all values of T greater than or equal to 0. Let's plug in the base case. We need to show that the statement holes 40 is equal to zero before the loop even happens, right? I guess this is just setting it up then induction hypothesis suppose that it holds after tee times through the loop for some tea. This should be greater than ": [
            678.3,
            707.2,
            18
        ],
        "didn't have it then it wouldn't it wouldn't be so easy to show cuz all I need to say now is that 80 plus one is bigger than all of them. So when you put it at the end of sordid Any other questions? Oh, I just did it in the wrong direction. Right is that Doesn't matter how you number them. Take me to the questions. I think here ": [
            1370.6,
            1423.6,
            34
        ],
        "do it. Any other questions? Okay, so let's do that part 3 remember the conclusion part. the conclusion so this is like the part 3 in three step process is that we showed the loop invariant is true after Tia durations for all these tea in particular after an iteration Zex is not in that set. This means that X is not in the in the array. That's it. Algorithm ": [
            2198.3,
            2239.2,
            54
        ],
        "do we have to what do we have to assume in order to use linear search? Sorting write so well binary search is faster than linear search. It depends upon your raping sorted what if you have an unsorted array and that you need to search should you sort it first so that you can use this faster searching method Okay, good turns out that searching. I mean skews me ": [
            3826.5,
            3858.7,
            93
        ],
        "do we learn in each of these three cases? Wait, is this a clicker question? I guess let's do a quick question for each thing. Okay. Let's start with this one. Zz1, right or most of y'all got it. Okay, if x is actually equal then it occurs at position in. Okay, let's do the next one. If x is smaller than a m then what can we say? Okay ": [
            2528.4,
            2599.5,
            63
        ],
        "elements in the last we're going to say Suppose. There are n elements. Now. Let's do our proof in the thing that we want to induct on his T. It's basically after I go through a bunch of iterations. Will it still be true after the next iteration? So be is the right answer. this will come into play when we do recruits recursive algorithms, then we induct on the ": [
            551.7,
            583.0,
            14
        ],
        "equal to Jay, which is what we want. Remember all of this is under the assumption that X exist in the list. What's up? X is bigger than a m. I see you said I equal to m. Well, you know that it's strictly bigger than am so you may as well start from the next one. And then the case 3 is just the same or similar. If x ": [
            3380.4,
            3442.4,
            85
        ],
        "equal to a i then return I otherwise return 0. It might be the case that you that you that it was the last one that you said that you looked at. So either it's going to Output it at some point or it's going to help put it at the end. Okay. Okay, so Let's think about how fast is this run? How long does it take to do ": [
            3632.9,
            3674.0,
            89
        ],
        "equal to that position number and if it's bigger than you look to the one side and the other side and the way to do that is if it's if X is bigger than that value right? You reset I to be the the number right next to the middle. And if Jay if x is small in the value than you reset Jay to be right next to the ": [
            2891.9,
            2916.2,
            73
        ],
        "find things OK sorting house with searching get to searching algorithms. One of them is one that works all the time for any data sorted or not. And then there's another one. That's a lot lot faster, but He relies on there being some order to the data. Okay, so here is sort of the problem the search problem. You're given an array of values and a Target value X. ": [
            1456.2,
            1483.5,
            36
        ],
        "from this Loop invariant you don't even use really the tea in the loop invariant because these things are just updating during the next iteration. case one If x is equal to a m right, I guess I should I should put that has remember equal to I + J / 2. If x is equal to a.m. Then by the inductive hypothesis and is already in between or because ": [
            3256.1,
            3290.6,
            82
        ],
        "good. if x is in the list ever cruise for for position, and that's kind of like if you open up the if you're looking for the word lion and you open up the dictionary and you look in the word is What's after El? Puma Then you know you been lying is less than Puma. So that means you know that lion occurs before puma in the dictionary. Pistol ": [
            2599.5,
            2634.8,
            64
        ],
        "group them with 80 + 1. Okay. so I did this in like a weird way. how to get rid of that used to it that way. Okay. Sorry about that. Sorry, this is kind of giving me problems. I guess that's better. Okay, so so let's do the two cases, right? Let's do case to First. turkey stew so Right case two is the smallest one. Okay. A 1 ": [
            1013.7,
            1108.9,
            27
        ],
        "has been proven. I know nobody really had any doubt that linear search doesn't work. But now you know for for fact. No, just for case to remember case one was just like a simple statement. k-stew Okay, so let's talk about how efficient is linear search. Okay. So I suppose you have an unsorted array and you're searching for a Target value acts that you know is in the ": [
            2239.2,
            2275.8,
            55
        ],
        "hypothesis assume that after t iterations i is less than or equal to P is less than or equal to J. And now we'll do our inductive step. Okay, so that's what I just did. Okay inductive step now. Let's just split this up into cases. I guess this is during. during the next iteration b r t + t + 1 hitter Asian and you can you can see ": [
            3200.9,
            3256.1,
            81
        ],
        "if I actually output 0 then I need to show you that that X is not found in the set it all. Okay, so let's suppose the algorithm output 0 then it went through all and iterations of the loop, right? So now let's use our Loop invariant. After Chi iterations of the loop. What do we say it was? X is not equal to A1 through 80 right questions ": [
            1811.8,
            1854.4,
            46
        ],
        "in the internet. When I was a student, we had to look in a dictionary when we're writing papers. No, actually when I was a student, we still had the internet. When I was like in kindergarten Maybe. so anyhow Some some dictionaries had like a little tab that you that had all the letters and you can like open it up for that letter but in general if your ": [
            2466.3,
            2498.8,
            61
        ],
        "index I + J over to floor you guys remember what floor means right? Just the the integer less than that number. less than equal to Okay, so here is kind of a high-level approach probe In The Middle based on what you find determine which have to search in next continue until the target is found or you can be sure. But the target is not in the array ": [
            2749.3,
            2777.7,
            69
        ],
        "inj no matter how many times I've been through the loop invariant. So let's let's do this. This proof. So what's the base case? before the first iteration Before I even going to the loop, what did I set inj equal to? Right eye is equal to 1 + J is equal to end. So any position has got to be in between 1 and 10. So that's true. inductive ": [
            3147.0,
            3200.9,
            80
        ],
        "is less than 8 then JB comes and -1 1/8 is less than or equal to X is less than or equal to a j or a m -1 and that implies that is less than P less than or equal to J. And then that's it. What happened there? Okay, it's up. Now. Let's show let's do part 3, right? Which is to show that the loop invariant? actually ": [
            3442.4,
            3511.6,
            86
        ],
        "is not equal to 80 + 1. So then along with the with the inductive hypothesis where X is not equal to a 1 through 80 now we can conclude that is not equal to a 1 to 80 + 1. So how long? With inductive hypothesis that X is not in a 1 through 80. Let's go like this. We conclude. X is not in a 1 through 80 ": [
            2085.0,
            2125.1,
            51
        ],
        "it supposed to do. So we're going to do this with a loop invariant for Loop based algorithms. What's the effect of each Loop iteration on the list how we made any progress? Okay, so Here's the three step plan for doing a loop invariant proof. First you need to State what the problem is. What is it? The algorithm is supposed to do. Then with that try to find ": [
            153.0,
            184.3,
            3
        ],
        "it wouldn't help put 0 Okay, so inductive step so during the t + first iteration We check. if x is equal to a 80 plus one, right and since we know it went through the next iteration, we know that it can't be the case that X is equal to 8 + 80 + 1 since since We are assuming. that what's a that algorithm? output 0 That X ": [
            2011.1,
            2085.0,
            50
        ],
        "just have like a set of a nothing. It's just is that sorted or but can't be unsorted right? Cuz there's nothing there to to to move around. It's so it's trivially sorted. Okay. It's alright trivially. true okay, and then the first 0 elements are smallest basically what I'm saying is everything in the empty set is smaller than all the other elements and that's also trivially true because ": [
            793.3,
            835.2,
            21
        ],
        "just trivially true right? No element is in the empty set. So that's done. questions about that operation There is no element in the empty set. It's not in the empty. So that's why I put a cross between over that that's like not in. That makes sense. Okay, good now inductive hypothesis. assume that for some tea greater than or equal to 0 that the loop invariant is true. ": [
            1896.8,
            1973.3,
            48
        ],
        "know that a 1 through 80 are already the smallest right in the t+ first iteration you're swapping the next smallest element with 80 + 1. So now you know that a 1 through 80 + 1 or now the smallest. I'll see what that looks like during the cheapest first iteration. The algorithm finds a m which is the minimum value of like the all the rest of the ": [
            955.1,
            986.4,
            25
        ],
        "little bit of it today, but we're going to look at it in more General and how do you guys how are you supposed to approach an algorithm runtime analysis if I give you an algorithm, how are you supposed to figure out how long do you expect it to run? So that's going to be for next time. Okay, so I guess we went a little fast today, but ": [
            3919.7,
            3943.4,
            96
        ],
        "loop invariant. Now, let's go to Let's skip to the third step just so that we can kind of see what it means and it's basically saying if I know that the loop invariant is true. How does that imply that the algorithm is? Correct? ISO? What would be? the correct Statement of the conclusion of this part 3 what is it about the loop invariant that implies that the ": [
            356.2,
            392.8,
            9
        ],
        "made it that far then none of the First Tee elements are equal to X right because if you got to the teeth index, then that means you've passed over a bunch of elements that are not equal to your target. Okay, so that's good. That's the loop invariant this algorithm. It has sort of two outcomes right? It's got the outcome where you actually find the element and their ": [
            1686.3,
            1714.4,
            42
        ],
        "maybe it's going to rearrange the elements of the input so that the output has a certain property or maybe it's going to tell you the best way to get around the world or take a certain path. Right? So it's every algorithm has a purpose that sort of the what that's the problem specification. So we're trying to do is convince everyone. That are algorithm will actually do what ": [
            121.6,
            153.0,
            2
        ],
        "means there's an - and positions remain to be checked. So for example, if I had a hundred elements, I probe that position 5 right I could get lucky and reduce my 100 size list down to four elements and now it's going to be easier to find it but most likely I'm going to have to look in the 95 trunk or the night, I guess 94 trunk, right? ": [
            2694.3,
            2720.6,
            67
        ],
        "name is in the middle of the the dictionary then you kind of opening up in the middle and then maybe you flip back a few pages. If you went too far or flip forward a few pages. If you didn't go far enough, I'm searching through a sorted list. so in general Suppose your list is sorted in increasing order if we probe the list at position M. What ": [
            2498.8,
            2528.4,
            62
        ],
        "need to show this I need to justify this. Prove it to you. Okay, this direction is easy because if it returned a non-zero value than it must have returned and as a result, so that's good. So let's jump down to this one. Okay, if binary search return 0 and there is no position p 4 where X is equal to X. So what I'm going to do is ": [
            3052.4,
            3081.9,
            78
        ],
        "net in between 0 and end the loop invariant is true? Okay, so remember what part 3 is. Now we need to show that this implies. The algorithm is true case. Let's see that again. So it's true for any tea in between 0 and N in particular. It's true after and iterations. So just plug in into your Loop invariant. It means that the first n elements are in ": [
            1292.9,
            1321.5,
            32
        ],
        "number. so kind of the idea is here you have I Jay And am right. So if if you know that X is to the right of M then I can reposition I To be right there now I is there and now in the next iteration I look at that. What are you guys say? What do I need what needs to happen for me to break out of ": [
            2916.2,
            2952.5,
            74
        ],
        "of the selection of mm is already in between I and J. of the choice of M and is in between I and J. case too many questions about case one kh2 If x is greater than a sub m. Then I is equal to and plus one, right? That's what the algorithm does. I guess reset to be m + 1 and so what is this mean this means ": [
            3290.6,
            3347.0,
            83
        ],
        "of want you to get the idea. Okay. So remember we have to show these to Loop and variance. So let's show the first one first. Ain't that what you want first one I do. Oh, I think I'm going to do part 2 first. Sorry. That's just the way that I organized it. So let's just kind of think about what's going on because of the induction hypothesis. We ": [
            904.4,
            955.1,
            24
        ],
        "one cuz I think we all know what it is right for this one if x is in the list it occurs after position in. Okay, good any questions about that? Okay. so now suppose X is equal to a if it's less than its its position is before an that means that there are n -1 positions to remain to be checked. Okay, and if it's bigger than that ": [
            2660.0,
            2694.3,
            66
        ],
        "or equal to 0. Sorry about that. And then the induction step is to show that it actually hold after t + 1 x through the loop or sometimes we just say after. one more iteration Okay. So here's the algorithm. We might flip back and forth just to kind of figure out what's going on in the loop. But just to kind of summarize every time he goes to ": [
            707.2,
            741.3,
            19
        ],
        "or maybe we can just leave early. That's awesome longer than normal. No. Maybe was the material. very heavy sandiego.edu ": [
            3943.4,
            3967.3,
            97
        ],
        "outcome where you don't find it. So we have to take those two cases into consideration. And one of the proofs is really easy. And the other one is with where we're going to use the proof the loop invariant. Okay, so case one the algorithm output some non-zero value. And I want to show that if it outputs this value and then I found my target it's at that ": [
            1714.4,
            1739.9,
            43
        ],
        "position. Otherwise if my output if my algorithm output 0 then I want to show that X is not in my list at all. So this one is really easy to do and just to kind of conceptualize why is because if your algorithm output something that's not zero. That means it must of it must have executed that line and the only way to execute that line is if ": [
            1739.9,
            1774.0,
            44
        ],
        "proves the algorithm Okay, so Loop invariant is pee is always going to be in between inj right. When does the Wild Loop stop? Does anybody remember? When I is less than or equal to Jay Wright. so the wild Loop stops or what? Do you say ends or breaks? When I is equal to J into a pi is equal to J. Then why is equal to Jay and ": [
            3511.6,
            3566.1,
            87
        ],
        "questions. We're kind of just prove both Loop and variance at the same time because we sorted needed one to prove the other right we needed that they were the smallest in order to show that they're sorted. So that's why we prove both of them. Okay, let's move on. So this is just what we wrote and then he was like a little conclusion. Is that there for four ": [
            1263.5,
            1292.9,
            31
        ],
        "size Okay, so this is for recursive algorithms algorithm in store is an iterative algorithm, which means you kind of go through a loop until it's done. Where is the recursive algorithm you plug the algorithm into itself until you get down to a bass case. okay, so essentially what we did want to do here is do the base case and then do the induction step. So remember what ": [
            583.0,
            622.8,
            15
        ],
        "sorted order, right which is what we want, right? And then the first and elements are the smallest. This is just trivial now. Doesn't really matter doesn't hurt us doesn't help us. It's just whatever because there was just all the elements. So we need it because of this. Right here. We used it to prove the sordid Loop invariant. It was important for us to have it. If you ": [
            1321.5,
            1370.6,
            33
        ],
        "sorting. Cost more or is it slower than just linear search. But if you're going to know if you know that you're going to be searching it over and over again, then it might be nice to do that sorting first and then have it in sorted order so that you can access it easier. Right? That's why people organize their file cabinets. That's why people organize their bookshelf or ": [
            3858.7,
            3886.2,
            94
        ],
        "that for some tea. The loop invariant is true after T iterations. So you really have to write we just didn't want to rewrite the whole Loop invariant. You just write it like that. Okay. So let's go to the induction step show that is true after t plus 1 iterations. Okay, first was kind of figure it out in words and then we'll write it down. I just kind ": [
            873.9,
            904.4,
            23
        ],
        "that now a has got to be less than x has got to be less than A J Wright and if you like instead of I I can put a m plus one, right because I said I'd be m + 1 2x is bigger than a plus one up to AJ and this implies that I have got to be less than or equal to P less than or ": [
            3347.0,
            3380.4,
            84
        ],
        "that. I have to look at 1 DVD. So come on now. Okay. So how fast is linear search will say that our array has n elements and we're searching for ex the time it takes to find X depends on the number of probes. How many times do I ask it? How many times do I perform that if statement, right how many times do I check? Okay, so ": [
            2324.1,
            2354.9,
            57
        ],
        "the algorithm works you set I equal to one and J equal to end basically the endpoints of the array. Okay, we're going to do this while loop until something happens, but let's see what happens inside. Okay, we set em to be the floor of I + J over tooth. That's just basically the middle value right? And then we probe there which means you ask if x is ": [
            2866.9,
            2891.9,
            72
        ],
        "the list will be in correct order at the end of the algorithm as required or none of the above. What do you guys think? Is a small as I can get it? I should resize it here. Figured so he is the right answer. Any questions about that? You'll see this happen a lot is when we do this step step 3, you're basically plugging in an 40 right ": [
            419.9,
            474.6,
            11
        ],
        "the loop find the minimum and then you interchange it with a I so let's just keep that in mind. Okay the base case. We're going to do T is equal to 0 so how to do this is basically just rewrite the loop invariant with t replace with 0. after zero iterations or before the first Loop the first zero elements RN sorted order is that even true? You ": [
            741.3,
            793.3,
            20
        ],
        "the the size of the list decrease down and if you get it down to one and it's not the element that you know that you're done. Okay, so so now we have a search algorithm where we are. We are assuming that the list comes in and assorted order that's going to be we're going to use that in our And how we build the algorithm. So here's how ": [
            2839.2,
            2866.9,
            71
        ],
        "the whole list, then it's not there. Okay. Here's kind of a pseudocode of how to do this. Okay, so I'm giving. Integers A1 through a and and let's say that they're all distinct. Okay. So let's just say that they're all different and they're not in any particular order. Oh, yeah, and then I have okay, so these are distinct integers and I also have acts which is just ": [
            1608.9,
            1643.0,
            40
        ],
        "the wild Loop? When do I know when I'm done? Okay. Good see. I has less than J. Or I guess not when I know when I'm done when I know when to keep on going, right? I has less than J. So once I is equal to Jay, that's when you know, your list size is of only one element and then that's when you know, if it's not ": [
            2952.5,
            2987.3,
            75
        ],
        "their DVD players is so that maybe it's like takes all day to sort it out or to organize. But once you've done that every time you go back to it, you can find things very quickly. Sort of like the same idea here. We need to search at many times. It becomes worthwhile. Okay, so The next thing we're going to do is run Time Performance. We did a ": [
            3886.2,
            3919.7,
            95
        ],
        "then I could be very lucky and find it fast if I wanted to watch you can see that Borax like in the middle, right? It would take some time to sort of the idea. We're going to search the array one index that I'm asking. Is this my target value at each position. If you answer yes, then return the position that you found it if you've gone through ": [
            1579.1,
            1608.9,
            39
        ],
        "there then it can't be anywhere. Okay, so here's the algorithm. Any questions so far? Okay good. So let's prove the correctness of this one. This one again. We have to do to two cases either I found it or I didn't and they're both kind of the same as linear search if I found it then I found it and I'm done right if you if you give me ": [
            2987.3,
            3022.1,
            76
        ],
        "there's nothing in the empty set. Text often times the base case will have this type of light trivial statement about the empty set. I want you to ride it out anyway. so Now, let's go into the induction hypothesis. Okay, so that's we already put that I guess you could put vacuously true or trivially true the kind of mean the same things. Okay, here's the induction hypothesis suppose ": [
            835.2,
            873.9,
            22
        ],
        "through 80 are all smaller. then 80 + 1 through a n right that's from the induction hypothesis. 80 + 1 is smallest. It well, let's just say is smaller than 80 + 2 up to a n. That's from swapping. I'll just put a little note by why each statement is true induction hypothesis. This is from the algorithm swapping. right there for a 1 through 80 80 + ": [
            1108.9,
            1158.2,
            28
        ],
        "through 80. This is actually just going to be true because a 1 through 80 are all the smallest elements, right? So just like this is also the induction hypothesis part to write. Mississippi induction hypothesis part 1 vs. Part 2 and then you say that they're for a 1 through 80 + 1 is in sorted order. This is what you want. So that's it. That's the proof any ": [
            1229.1,
            1263.5,
            30
        ],
        "to do it later. We all know how to find a minimum tax. Okay. So what were the two Loop invariants for selection sort do you guys remember it goes something like this after T. Iterations? What? Okay good. So the First Tee. Alamance what did I do it like this? I have a mic subscripts or yeah, I guess so there's subscripts. And what else do you get this? ": [
            275.6,
            323.8,
            7
        ],
        "to do until that value gets down to one or I guess, you know at the at the very most one. EXO how many Pros do I need to do for this to be for this to go? Can I do this wrong? Yeah, so then. n okay. I think I put these in the wrong direction. So basically, okay. This is what I wanted to get to is that ": [
            3718.3,
            3787.0,
            91
        ],
        "to find the one with your name on it? Or how do you look for stuff in a dictionary? Do you go through every single page one by one? You do. That's why you're always late to class. I got to look at that word. I know hopefully your dictionary has like those little tabs don't even uses a book dictionary anymore. Do they? You just put it in the ": [
            2434.3,
            2466.3,
            60
        ],
        "to prove this as correct and it's sort of more work than you need but it's more just an example to show you guys that the power of this Loop invariant that it can prove a lot of algorithms. You could probably find a much more direct simple argument for why lady or search works, but for the for the purpose of this lesson let you use Loop invariant to ": [
            2175.9,
            2198.3,
            53
        ],
        "up to you. I prefer to start at 0 because the the justifications are just very simple. You don't have to do much as you're going to see. Can you do the induction step? If it's ever true then going through the loop one more time it Still Remains true if that's kind of the idea. Okay questions. Alright, let's take a look here. Once we do that, then we ": [
            649.2,
            678.3,
            17
        ],
        "values that the remaining right hat the remaining right hand. Can you swap a m with 80 + 1? so after the first t t + first iteration 80 + 1 is the minimum value of that set right from 80 + 102 a n and you already know that a 1 through 80 are all the minimum values are all the smallest values. So now you can kind of ": [
            986.4,
            1013.7,
            26
        ],
        "we have a few different scenarios. How many probes do I have to do in the worst case scenario? Right, and that's if what? is the last or what? Or not in the list, right? Okay, what's the best case scenario? one, right if x is first and what do you kind of expected to do on average if you average out a bunch of random things? Andover to write ": [
            2357.9,
            2405.7,
            58
        ],
        "what? If you find it, right, so it's pretty straightforward to prove that direction. So let's do it that easy direction if the algorithm output cycle zero, then it must have been that X is equal to a i and so then you're done. Any questions about that? Okay, the other direction is a little bit more subtle. It's saying that I didn't miss it as I went along right ": [
            1774.0,
            1811.8,
            45
        ],
        "when can you be sure that the targets not in the array? Okay, but we're going to kind of be like looking through right? But we're going to be like looking through in the middle in the maximum in or on the sides. Oh, you mean like if if the list size is down to one element and that element doesn't match Yeah, exactly. So we're going to see that ": [
            2777.7,
            2839.2,
            70
        ],
        "when you're doing proofs on algorithms the higher-level you go the easier it is because you don't have to worry about all these indices and chasing these things around instead. If you just have the high-level concept of oh, we're just finding the minimum. I don't know how I'm going to do it yet. But if I can do it then I'll remove work. You got to figure out how ": [
            252.6,
            275.6,
            6
        ]
    },
    "File Name": "Mathematics for Algorithms and Systems - B00 - Jones, Miles E - Winter 2019-lecture_7.flac",
    "Full Transcript": "Listen to a podcast.  Okay, good evening, everyone.  Where is the  Okay, so  let's get started.  so what we're doing today is  basically learning how to prove it already of algorithms are correct using something called a loop invariant examples. I don't know if we're going to get to all of them today. We're going to start a selection sort. I think we already talked about it a little bit. So basically what we want to do.  Is given an algorithm which is a sequence of steps or it's a set of instructions step by step how to do something or how to give in a given some information how to Output another type of information. Right? And usually your algorithm wants to do something with the information whether it be  Maybe determine if the input has a property or maybe it's going to rearrange the elements of the input so that the output has a certain property or maybe it's going to tell you the best way to get around the world or take a certain path. Right? So it's every algorithm has a purpose that sort of the what that's the problem specification. So we're trying to do is convince everyone.  That are algorithm will actually do what it supposed to do.  So we're going to do this with a loop invariant for Loop based algorithms. What's the effect of each Loop iteration on the list how we made any progress?  Okay, so  Here's the three step plan for doing a loop invariant proof.  First you need to State what the problem is. What is it? The algorithm is supposed to do.  Then with that try to find a loop invariant often times. The loop invariant is related to the problem algorithm is supposed to do often times. It's kind of like sort of a sub problem on a smaller input.  Then the next thing is to prove that it is correct by using induction.  That proves that the loop invariant is correct. That doesn't necessarily prove that the album algorithm is correct. You need this last part 3 so don't forget 3, this is easily looked over. This is the step where you show that the algorithm is. Actually correct based on what you found with the loop invariant.  Case let's go back to selection sort men's store, which is fine the smallest one and put it to the front.  And here is the pseudocode.  But what I like better is kind of the mid-level pseudocode because when you're doing proofs on algorithms the higher-level you go the easier it is because you don't have to worry about all these indices and chasing these things around instead. If you just have the high-level concept of oh, we're just finding the minimum. I don't know how I'm going to do it yet. But if I can do it then I'll remove work.  You got to figure out how to do it later. We all know how to find a minimum tax.  Okay. So what were the two Loop invariants for selection sort do you guys remember it goes something like this after T. Iterations? What?  Okay good. So the First Tee.  Alamance what did I do it like this?  I have a mic subscripts or yeah, I guess so there's subscripts.  And what else do you get this?  Okay, good A 1 through 80 are the smallest.  Some algorithms you're going to only need one Loop invariant this one you need to and you'll sort of see why when we go through the proof of induction.  questions about that  All right, so that's what I have first two elements are sorted and they and they are the smallest.  Okay, so. That's the first step coming up with the loop invariant. Now, let's go to Let's skip to the third step just so that we can kind of see what it means and it's basically saying if I know that the loop invariant is true. How does that imply that the algorithm is? Correct? ISO?  What would be?  the correct  Statement of the conclusion of this part 3 what is it about the loop invariant that implies that the algorithm is, correct? So let's read through them we have  Since the First Tee elements are the T smallest men's short is correct, since we execute the loop, at least once the first element at the end of the algorithm is the smallest and so Min sort is correct, since we execute the loop exactly end times the loop invariant with t equals and guarantees that all and elements of the list will be in correct order at the end of the algorithm as required or none of the above.  What do you guys think?  Is a small as I can get it?  I should resize it here.  Figured so he is the right answer.  Any questions about that?  You'll see this happen a lot is when we do this step step 3, you're basically plugging in an 40 right because basically want to say that the loop invariant it's true after every iteration. So that means it's true after the last iteration. If it's too rough to the last iteration, that should show the Falcon this right?  We'll revisit that after we do the proof.  Okay, let's do this induction.  So what's going to be the induction variable? What are we going to induct on?  Is it going to be?  and the actual size of the input  T the number of times we go through the Outer Loop  or I the index of the smallest element or d none of the above.  Okay, what sort of have?  Kind of a MB or sort of the top to hear. Let's talk about that for a second.  Then we're going to do this proof. We're going to fix the number of elements in the last we're going to say Suppose. There are n elements. Now. Let's do our proof in the thing that we want to induct on his T. It's basically after I go through a bunch of iterations. Will it still be true after the next iteration? So be is the right answer.  this  will come into play when we do recruits recursive algorithms, then we induct on the size Okay, so  this is for  recursive  algorithms  algorithm in store is an iterative algorithm, which means you kind of go through a loop until it's done. Where is the recursive algorithm you plug the algorithm into itself until you get down to a bass case.  okay, so essentially what we did want to do here is  do the base case and then do the induction step. So remember what are  Loop invariant said it said after T. Iteration something is true. So if I if I said t is equal to 0 that means that it's happening before the loop even happens. Is that Loop invariant true and we're going to see what that looks like. If you want you could start this induction at T is equal to 1 and that would be after the first kind of up to you.  I prefer to start at 0 because the the justifications are just very simple. You don't have to do much as you're going to see.  Can you do the induction step? If it's ever true then going through the loop one more time it Still Remains true if that's kind of the idea. Okay questions.  Alright, let's take a look here.  Once we do that, then we can conclude that. It's true for all values of T greater than or equal to 0.  Let's plug in the base case. We need to show that the statement holes 40 is equal to zero before the loop even happens, right? I guess this is just setting it up then induction hypothesis suppose that it holds after tee times through the loop for some tea.  This should be greater than or equal to 0. Sorry about that.  And then the induction step is to show that it actually hold after t + 1 x through the loop or sometimes we just say after.  one more iteration  Okay. So here's the algorithm. We might flip back and forth just to kind of figure out what's going on in the loop. But just to kind of summarize every time he goes to the loop find the minimum and then you interchange it with a I so let's just keep that in mind.  Okay the base case.  We're going to do T is equal to 0 so how to do this is basically just rewrite the loop invariant with t replace with 0.  after zero  iterations or before  the first Loop  the first zero elements  RN sorted  order is that even true?  You just have like a set of a nothing. It's just is that sorted or but can't be unsorted right? Cuz there's nothing there to to to move around. It's so it's trivially sorted. Okay.  It's alright trivially.  true  okay, and then the first  0 elements  are smallest  basically what I'm saying is everything in the empty set is smaller than all the other elements and that's also trivially true because there's nothing in the empty set.  Text often times the base case will have this type of light trivial statement about the empty set.  I want you to ride it out anyway.  so  Now, let's go into the induction hypothesis.  Okay, so that's we already put that I guess you could put vacuously true or trivially true the kind of mean the same things.  Okay, here's the induction hypothesis suppose that for some tea. The loop invariant is true after T iterations. So you really have to write we just didn't want to rewrite the whole Loop invariant. You just write it like that.  Okay. So let's go to the induction step show that is true after t plus 1 iterations.  Okay, first was kind of figure it out in words and then we'll write it down. I just kind of want you to get the idea. Okay. So remember we have to show these to Loop and variance.  So let's show the first one first.  Ain't that what you want first one I do.  Oh, I think I'm going to do part 2 first. Sorry. That's just the way that I organized it.  So let's just kind of think about what's going on because of the induction hypothesis. We know that a 1 through 80 are already the smallest right in the t+ first iteration you're swapping the next smallest element with 80 + 1.  So now you know that a 1 through 80 + 1 or now the smallest.  I'll see what that looks like during the cheapest first iteration. The algorithm finds a m which is the minimum value of like the all the rest of the values that the remaining right hat the remaining right hand.  Can you swap a m with 80 + 1?  so after the first t t + first iteration 80 + 1 is the minimum value of that set right from 80 + 102 a n  and you already know that a 1 through 80 are all the minimum values are all the smallest values. So now you can kind of group them with 80 + 1.  Okay.  so  I did this in like a weird way.  how to get rid of that  used to it that way. Okay. Sorry about that.  Sorry, this is kind of giving me problems.  I guess that's better. Okay, so  so let's do the two cases, right?  Let's do case to First.  turkey stew  so  Right case two is the smallest one. Okay.  A 1 through 80 are all smaller.  then  80 + 1 through a n right that's from the induction hypothesis.  80 + 1 is smallest.  It well, let's just say is smaller than 80 + 2 up to a n. That's from swapping.  I'll just put a little note by why each statement is true induction hypothesis. This is from the algorithm swapping.  right there for a 1 through 80 80 + 1  are all smaller.  Then 80 + 2 up to a n which is which is what we want, right? That's what we want the loop invariant to be any questions about that.  Let's just do that and then just work here.  Okay, now let's do one.  Okay, A 1 through 80 are in sorted order.  This is from the induction hypothesis.  80 + 1 is bigger.  Then a 1 through 80.  This is actually just going to be true because a 1 through 80 are all the smallest elements, right?  So just like this is also the induction hypothesis part to write.  Mississippi induction hypothesis part 1 vs. Part 2 and then you say that they're for a 1 through 80 + 1 is in sorted order.  This is what you want. So that's it. That's the proof any questions.  We're kind of just prove both Loop and variance at the same time because we sorted needed one to prove the other right we needed that they were the smallest in order to show that they're sorted. So that's why we prove both of them.  Okay, let's move on.  So this is just what we wrote and then he was like a little conclusion. Is that there for four net in between 0 and end the loop invariant is true?  Okay, so remember what part 3 is.  Now we need to show that this implies. The algorithm is true case. Let's see that again.  So it's true for any tea in between 0 and N in particular. It's true after and iterations. So just plug in into your Loop invariant. It means that the first n elements are in sorted order, right which is  what we want, right?  And then the first and elements are the smallest. This is just trivial now.  Doesn't really matter doesn't hurt us doesn't help us. It's just whatever because there was just all the elements.  So we need it because of this.  Right here.  We used it to prove the sordid Loop invariant. It was important for us to have it. If you didn't have it then it wouldn't it wouldn't be so easy to show cuz all I need to say now is that 80 plus one is bigger than all of them. So when you put it at the end of sordid  Any other questions?  Oh, I just did it in the wrong direction. Right is that  Doesn't matter how you number them.  Take me to the questions.  I think here I kind of numbered them wrong to sorry.  So this is actually two and this is one.  Okay. So this is the end three is the end. So that's it. Good done.  Okay, let's move on.  AutoCAD another type of problem. Why do you want to sort? Well remember when I said it's easier to find things in a sorted list. So we're going to talk about now how to find things OK sorting house with searching get to searching algorithms. One of them is one that works all the time for any data sorted or not.  And then there's another one. That's a lot lot faster, but  He relies on there being some order to the data.  Okay, so here is sort of the problem the search problem. You're given an array of values and a Target value X.  You want to find an index Jay where X is equal to a j or if no such index exists. We're just going to return 0.  It's up, for example if this was my list.  And X is equal to 1 what J would the search problem find?  Okay, good beef Zachary. Okay, so it's going to Output the index right so4 is the index of where is equal to 1.  Okay, so let's move on.  now if you are  an organized maybe your DVD collection looks like this in which case if I want to find a DVD and it's all out of order and I don't know how they were ordered. Then I might have to go through each one until I find the one I want right if I want it if I wanted to watch Philadelphia, then I could be very lucky and find it fast if I wanted to watch you can see that  Borax like in the middle, right? It would take some time to sort of the idea.  We're going to search the array one index that I'm asking. Is this my target value at each position. If you answer yes, then return the position that you found it if you've gone through the whole list, then it's not there.  Okay. Here's kind of a pseudocode of how to do this.  Okay, so I'm giving.  Integers A1 through a and and let's say that they're all distinct. Okay. So let's just say that they're all different and they're not in any particular order.  Oh, yeah, and then I have okay, so these are distinct integers and I also have acts which is just an integer. That's what I'm trying to look for. When I go to the loop start. I from one if x is equal to a i at any point then just stop and return. I otherwise I'll go through the whole Loop up until n and then return 0.  pet questions about that  Okay song.  What's the loop invariant for this algorithm?  Okay good after T. Adorations, right? If you've made it that far then none of the First Tee elements are equal to X right because if you got to the teeth index, then that means you've passed over a bunch of elements that are not equal to your target.  Okay, so that's good. That's the loop invariant this algorithm. It has sort of two outcomes right? It's got the outcome where you actually find the element and their outcome where you don't find it. So we have to take those two cases into consideration. And one of the proofs is really easy. And the other one is with where we're going to use the proof the loop invariant.  Okay, so case one the algorithm output some non-zero value.  And I want to show that if it outputs this value and then I found my target it's at that position. Otherwise if my output if my algorithm output 0 then I want to show that X is not in my list at all.  So this one is really easy to do and just to kind of conceptualize why is because if your algorithm output something that's not zero.  That means it must of it must have executed that line and the only way to execute that line is if what?  If you find it, right, so it's pretty straightforward to prove that direction. So let's do it that easy direction if the algorithm output cycle zero, then it must have been that X is equal to a i and so then you're done.  Any questions about that?  Okay, the other direction is a little bit more subtle. It's saying that I didn't miss it as I went along right if I actually output 0 then I need to show you that that X is not found in the set it all.  Okay, so let's suppose the algorithm output 0 then it went through all and iterations of the loop, right? So now let's use our Loop invariant.  After Chi iterations of the loop.  What do we say it was?  X is not equal to  A1  through 80  right  questions about that  Okay, so that's what we have. Let's let's still in the base case in the hypothesis and induction step. Okay the base case.  Let's do after zero iterations, which means before the before the loop.  Jersey right away shins. This is before the loop.  It's saying that X is not in the set of a one up to a zero with his just the empty set.  And that's just trivially true right? No element is in the empty set. So that's done.  questions about that  operation  There is no element in the empty set.  It's not in the empty. So that's why I put a cross between over that that's like not in.  That makes sense.  Okay, good now inductive hypothesis.  assume  that for some tea  greater than or equal to 0 that  the loop invariant is true.  Okay, which means that it's not in all of those?  It's not equal to a 1 through 880 age. Okay. Remember we're under this assumption that the algorithm output 0 which means that it can't ever stop in the loop, right? Which means that it will never let me go back to the real fast.  It will never execute this return state.  then  it wouldn't get to the end and it wouldn't help put 0 Okay, so  inductive step  so during  the t + first  iteration  We check.  if x is equal to a 80 plus one, right and since we know it went through the next iteration, we know that it can't be the case that X is equal to 8 + 80 + 1  since since  We are assuming.  that  what's a that algorithm?  output 0  That X is not equal to 80 + 1.  So then along with the with the inductive hypothesis where X is not equal to a 1 through 80 now we can conclude that is not equal to a 1 to 80 + 1.  So how long?  With inductive hypothesis that X is not in a 1 through 80.  Let's go like this.  We conclude.  X is not in a 1 through 80 + 1  Okay.  And then that's it questions about that.  Yeah.  so that's because  if the algorithm output 0  then that means I went through the loop the loop all the way.  Which means I never went into that.  If statement that if statement never was true.  So that it can't be true for the next one.  I know it may seem like it's kind of like a backwards way to prove this as correct and it's sort of more work than you need but it's more just an example to show you guys that the power of this Loop invariant that it can prove a lot of algorithms. You could probably find a much more direct simple argument for why lady or search works, but for the for the purpose of this lesson let you use Loop invariant to do it.  Any other questions?  Okay, so let's do that part 3 remember the conclusion part.  the conclusion so this is like the part 3  in three step process  is that we showed the loop invariant is true after Tia durations for all these tea in particular after an iteration Zex is not in that set. This means that X is not in the in the array.  That's it.  Algorithm has been proven.  I know nobody really had any doubt that linear search doesn't work. But now you know for for fact.  No, just for case to remember case one was just like a simple statement.  k-stew  Okay, so let's talk about how efficient is linear search. Okay. So I suppose you have an unsorted array and you're searching for a Target value acts that you know is in the array somewhere what position for X will cause linear search to take the longest amount of time.  Okay, good. Excellent.  Okay, the last element right just like looking through my DVDs right the last element. I have to look at every single one.  So if it's the first element I can I can break out of that Loop because I have that return statement. So it might might be only that. I have to look at 1 DVD.  So come on now.  Okay. So how fast is linear search will say that our array has n elements and we're searching for ex the time it takes to find X depends on the number of probes. How many times do I ask it? How many times do I perform that if statement, right how many times do I check?  Okay, so  we have a few different scenarios.  How many probes do I have to do in the worst case scenario?  Right, and that's if what?  is the last  or what?  Or not in the list, right?  Okay, what's the best case scenario?  one, right  if x is first  and what do you kind of expected to do on average if you average out a bunch of random things?  Andover to write about Andover too, and we'll just we're just going to kind of skip over the reasoning for that until we get to probability. Okay, that would be the expected run time.  for the expected number of probes  Okay, so that's good. Let's keep that in the back of our mind.  Searching a sorted array now if the array is sorted.  How would you search through a pile of alphabetize papers to find the one with your name on it?  Or how do you look for stuff in a dictionary? Do you go through every single page one by one?  You do.  That's why you're always late to class.  I got to look at that word.  I know hopefully your dictionary has like those little tabs don't even uses a book dictionary anymore. Do they?  You just put it in the in the internet.  When I was a student, we had to look in a dictionary when we're writing papers.  No, actually when I was a student, we still had the internet.  When I was like in kindergarten Maybe.  so anyhow  Some some dictionaries had like a little tab that you that had all the letters and you can like open it up for that letter but in general if your name is in the middle of the the dictionary then you kind of opening up in the middle and then maybe you flip back a few pages. If you went too far or flip forward a few pages. If you didn't go far enough, I'm searching through a sorted list.  so in general  Suppose your list is sorted in increasing order if we probe the list at position M. What do we learn in each of these three cases?  Wait, is this a clicker question?  I guess let's do a quick question for each thing. Okay. Let's start with this one.  Zz1, right or most of y'all got it. Okay, if x is actually equal then it occurs at position in. Okay, let's do the next one.  If x is smaller than a m then what can we say?  Okay good.  if x is in the list ever cruise for for position, and that's kind of like if you open up the if you're looking for the word lion and you open up the dictionary and you look in the word is  What's after El?  Puma  Then you know you been lying is less than Puma. So that means you know that lion occurs before puma in the dictionary.  Pistol BB and then but it could be the case that is not even in the list right? Maybe this dictionary, you know doesn't have any  I wasn't I was going to say doesn't have any animals, but then I already said that there was Puma.  Maybe lion wasn't a word yet or something. And so it didn't occur in the dictionary.  Okay, so I'm just going to skip the last one cuz I think we all know what it is right for this one if x is in the list it occurs after position in.  Okay, good any questions about that?  Okay.  so  now  suppose X is equal to a if it's less than its its position is before an that means that there are n -1 positions to remain to be checked. Okay, and if it's bigger than that means there's an - and positions remain to be checked. So for example, if I had a hundred elements, I probe that position 5 right I could get lucky and reduce my 100 size list down to four elements and now it's going to be easier to find it but most likely I'm going to have to look in the 95 trunk or the night, I guess 94 trunk, right? And so what's the best way to minimize the maximum size of the list?  Start from the middle, right? Because that means that you know, if you go anywhere from left to right of the middle than one of your list is going to grow bigger. So middle is going to be the best.  Okay, so probe in the middle, so if we're searching a subarray, I threw AJ probat index I + J over to floor you guys remember what floor means right?  Just the the integer less than that number.  less than equal to  Okay, so here is kind of a high-level approach probe In The Middle based on what you find determine which have to search in next continue until the target is found or you can be sure.  But the target is not in the array when can you be sure that the targets not in the array?  Okay, but we're going to kind of be like looking through right?  But we're going to be like looking through in the middle in the maximum in or on the sides.  Oh, you mean like if if the list size is down to one element and that element doesn't match  Yeah, exactly.  So we're going to see that the the size of the list decrease down and if you get it down to one and it's not the element that you know that you're done.  Okay, so  so now we have a search algorithm where we are. We are assuming that the list comes in and assorted order that's going to be we're going to use that in our  And how we build the algorithm.  So here's how the algorithm works you set I equal to one and J equal to end basically the endpoints of the array. Okay, we're going to do this while loop until something happens, but let's see what happens inside.  Okay, we set em to be the floor of I + J over tooth. That's just basically the middle value right? And then we probe there which means you ask if x is equal to that position number and if it's bigger than you look to the one side and the other side and the way to do that is if it's if X is bigger than that value right? You reset I to be the the number right next to the middle. And if Jay if x is small in the value than you reset Jay to be right next to the number.  so kind of the idea is  here you have I  Jay  And am right. So if if you know that X is to the right of M then I can reposition I  To be right there now I is there and now in the next iteration I look at that.  What are you guys say? What do I need what needs to happen for me to break out of the wild Loop? When do I know when I'm done?  Okay. Good see.  I has less than J.  Or I guess not when I know when I'm done when I know when to keep on going, right?  I has less than J.  So once I is equal to Jay, that's when you know, your list size is of only one element and then that's when you know, if it's not there then it can't be anywhere.  Okay, so here's the algorithm.  Any questions so far?  Okay good.  So let's prove the correctness of this one.  This one again. We have to do to two cases either I found it or I didn't and they're both kind of the same as linear search if I found it then I found it and I'm done right if you if you give me a nonzero number, that means that I must have  Executed this line in the only way to execute that line is if x is actually equal to one of the values.  Okay good.  Okay. Now here is sort of the loop invariant one where we have to do an induction if the binary search return 0 then there is no position P for which AP is equal to X. I need to show this I need to justify this.  Prove it to you.  Okay, this direction is easy because if it returned a non-zero value than it must have returned and as a result, so that's good. So let's jump down to this one. Okay, if binary search return 0 and there is no position p 4 where X is equal to X. So what I'm going to do is actually prove the contrapositive of the statement. What's the contrapositive?  if there is a p  Such that.  AP is equal to X then what?  Write binary search does not returned zero.  Doubts are comments on that.  Okay, good. Let's prove this.  Okay. So the loop invariant I'm going to prove is suppose that there is a position P then I claim that P is always going to be an in-between inj no matter how many times I've been through the loop invariant.  So let's let's do this.  This proof. So what's the base case?  before the first iteration  Before I even going to the loop, what did I set inj equal to?  Right eye is equal to 1 + J is equal to end. So any position has got to be in between 1 and 10.  So that's true.  inductive hypothesis assume  that after t iterations  i is less than or equal to P is less than or equal to J.  And now we'll do our inductive step.  Okay, so that's what I just did.  Okay inductive step now. Let's just split this up into cases.  I guess this is during.  during the next  iteration  b r t + t + 1 hitter Asian and you can you can see from this Loop invariant you don't even use really the tea in the loop invariant because these things are just updating during the next iteration.  case one  If x is equal to a m right, I guess I should I should put that has remember equal to I + J / 2.  If x is equal to a.m. Then by the inductive hypothesis and is already in between or because of the selection of mm is already in between I and J.  of the choice  of M  and is in between I and J.  case too many questions about case one  kh2  If x is greater than a sub m.  Then I is equal to and plus one, right? That's what the algorithm does. I guess reset to be m + 1  and so what is this mean this means that now a has got to be less than x has got to be less than A J Wright and if you like instead of  I I can put a m plus one, right because I said I'd be m + 1 2x is bigger than a plus one up to AJ and this implies that I have got to be less than or equal to P less than or equal to Jay, which is what we want.  Remember all of this is under the assumption that X exist in the list.  What's up?  X is bigger than a m.  I see you said I equal to m.  Well, you know that it's strictly bigger than am so you may as well start from the next one.  And then the case 3 is just the same or similar.  If x is less than 8 then JB comes and -1 1/8 is less than or equal to X is less than or equal to a j or a m -1 and that implies that is less than P less than or equal to J.  And then that's it.  What happened there?  Okay, it's up. Now. Let's show let's do part 3, right?  Which is to show that the loop invariant?  actually proves the algorithm Okay, so  Loop invariant is pee is always going to be in between inj right. When does the Wild Loop stop?  Does anybody remember?  When I is less than or equal to Jay Wright.  so the wild Loop  stops or what? Do you say ends or breaks?  When I is equal to J into a pi is equal to J.  Then why is equal to Jay and I is less than or equal to P is less than or equal to Jay that implies that I is equal to J is equal to p and if you see back in the algorithm.  if that's the case then  we would  neither should be less than or equal to.  when we get down to  I guess let me just put it in another line here then.  if x is equal to a i  then return I otherwise return 0.  It might be the case that you that you that it was the last one that you said that you looked at.  So either it's going to Output it at some point or it's going to help put it at the end.  Okay.  Okay, so  Let's think about how fast is this run? How long does it take to do binary search, but every time you run a duration you divide the length of the list in half, right?  So the sub array gets divided by two or four than the 816 all the way down. If I've done W many probes. What's the size of my sub array?  10 /  2 to the W  Okay good.  So what I want to do is do as many Pros I need to do until that value gets down to one or I guess, you know at the at the very most one.  EXO  how many Pros do I need to do for this to be for this to go?  Can I do this wrong?  Yeah, so then.  n  okay.  I think I put these in the wrong direction. So basically, okay. This is what I wanted to get to is that  The smallest integer W. That is sure to be greater than login is the floor of log base 2 of n + 1.  So I at least have to do that many probes.  So this is the worst case scenario by comparison linear search takes as many as an ore on average and over 200 even in the average case.  Binary search is much better than linear search.  But what do we have to what do we have to assume in order to use linear search?  Sorting write so well binary search is faster than linear search. It depends upon your raping sorted what if you have an unsorted array and that you need to search should you sort it first so that you can use this faster searching method  Okay, good turns out that searching. I mean skews me sorting.  Cost more or is it slower than just linear search. But if you're going to know if you know that you're going to be searching it over and over again, then it might be nice to do that sorting first and then have it in sorted order so that you can access it easier. Right? That's why people organize their file cabinets. That's why people organize their bookshelf or their DVD players is so that maybe it's like takes all day to sort it out or to organize. But once you've done that every time you go back to it, you can find things very quickly.  Sort of like the same idea here.  We need to search at many times. It becomes worthwhile.  Okay, so  The next thing we're going to do is run Time Performance. We did a little bit of it today, but we're going to look at it in more General and how do you guys how are you supposed to approach an algorithm runtime analysis if I give you an algorithm, how are you supposed to figure out how long do you expect it to run? So that's going to be for next time.  Okay, so I guess we went a little fast today, but or maybe we can just leave early.  That's awesome longer than normal. No.  Maybe was the material.  very heavy  sandiego.edu "
}