{
    "Blurbs": {
        "+ -1 V to the T minus one Okay. Now, let's do the proof bass case. What's up bass case usually is before you even go into the loop. I ain't usually get like the the simplest form of the base case and the way that you you talked about it is you say. after 0 iterations and in or AKA before entering the loop but the trick here is ": [
            1278.5,
            1323.4,
            28
        ],
        "+ a + - 1 V - in - 1 that's what we want. That's what that's how you get the thing. Okay, any questions about that? That's it. It's clear that that's what you want for this problem. I mean is there and this I think this is what we had in the in the problem specification I maybe we didn't. Yeah, I guess. Yeah, maybe you just say ": [
            2167.1,
            2214.5,
            45
        ],
        "+... + a + -1 V to the N - 1 for any V & N E a of degree and -1 for any n greater than or equal to one. So if you write it up like this a kind of like helps you with understanding what's going to be my induction variables going to be in the size of the input, right? Okay, so the proof bass case ": [
            2504.3,
            2553.8,
            51
        ],
        "- the number of iterations so Now we do the step, okay. so during the tea + 1 iteration Y is equal to v y + 1/8 + -2 + 1 right by the inductive hypothesis, whatever why was before was whatever we had in the inductive hypothesis. So, bye-bye. inductive hypothesis, why originally is Y is equal to a n minus t plus... + 8 + -1 V to ": [
            1811.5,
            1883.6,
            38
        ],
        "1 then. return true right otherwise return what? Rock 101 from B1 up to where can I go to Be a Menace 2? Let's go to be in -1. I like that better. Then we won't have either way. Okay, any questions about that? Yeah, that's just a personal preference. If you wanted to check from the front, then that's fine, too. either way Kimberly check from the middle though, ": [
            3674.9,
            3751.3,
            73
        ],
        "A. And we to the end - 1 * V. Plus a zero and if you just kind of simplify this you got a 1 V + a 2 V squared plus... Plus anv to the end. Plus a zero, which is what we want. Let's just rearrange the terms a 0 + a 1 b + A to B squared +... + A + B to the end. any ": [
            2976.1,
            3008.5,
            60
        ],
        "And in this case, you're going to have to go all the way down to the base case and we already solve this recurrence and you get the event is Big Theta event. Okay questions about that. Oh, yeah, you're right. It is T2, isn't it? Thank you. But you still get the same big fat event. Okay any questions? Oh. You should be. Run time is constant. Didn't say ": [
            3898.7,
            3968.1,
            77
        ],
        "FN is N squared G of n is 1,000 and squared + 2 to the 100. Okay. So this one what you might want to do is kind of simplified GN into like a a simpler. Form Frank remember we can ignore constants and ignore coefficients. So if we ignore constants and ignore coefficients that shows you that G of n is Big Theta of N squared Crossing out the ": [
            611.5,
            668.1,
            14
        ],
        "How are they different? once they want Oh, yeah. Okay, so I kind of think about like the The recurrence relation as the pair right? You get the base case and you get the recurrence. Yeah, I guess it's sort of like a loose thing. But I guess what if I say recurrence, then I'm thinking of the base case and the relation I guess one is the relation in ": [
            3438.8,
            3481.5,
            68
        ],
        "Listen to a podcast. I just put 1314 because it's going to be today and tomorrow. Yeah, it's payday Eve. Is there anything special going on today? tomorrow I love pie. You talk about the number or the food? Okay, okay. I think I like the the food better than the number. Is that crazy? I am know how alright, so Everybody ready for the final on Saturday? Yeah. No. ": [
            1.9,
            98.3,
            0
        ],
        "Metaphor that we had from before so if you can you can say maybe like what I had before was I had three soldiers here. Two Soldiers here and Two Soldiers here, right and once you put them in there, you know, which order they have to go in the positions. You just send you send these guys to the three you just send them to the first available open ": [
            4526.4,
            4556.4,
            91
        ],
        "N - 1 Right because that's what it should do for a polynomial of degree + -1. Any questions about that? That's what we claim that it should do. So that's where using our inductive hypothesis. Okay, then the next line is. Y is equal to v y x v Plus a zero, so that's equal to well why in this case is a 1 plus A 2v Plus... Class ": [
            2934.3,
            2976.1,
            59
        ],
        "O good Okay. This is what we can cook conclude. Can we conclude anything about big Omega? Is f of an oar sorry G of n is Big Omega of GE oven or not, or is it inconclusive? It's not we know that for a fact it's not big Omega. Okay. So what does that mean about big Sada? Not Big Data. There any questions about that? Okay, next one. ": [
            551.1,
            608.4,
            13
        ],
        "Okay. Well, I claim it will work for all and greater than equal to one. So let's say that and is equal to one right then. a is degree zero? Right and so a is equal to just some value a right. And in the algorithm you just returned that value. correctly returns a0 I got any questions about that. Okay. inductive hypothesis okay, so we're going to use a ": [
            2556.4,
            2615.0,
            52
        ],
        "Okay. recursive algorithm okay, so this one is It's the same thing. right so The same problem is a different algorithm. It's very similar, right but the proofs even though they're both induction. There are different. Okay, and this is a big thing that I want you to realize is that an iterative algorithms. The induction is on the number of iterations recursive algorithms. The induction is on the size ": [
            2392.6,
            2450.1,
            49
        ],
        "Right? What happens is that? You're going from a and minus zero all the way up to a 10-1 rent. And this is supposed to be like an increasing list. So that turns into the empty list. And I don't know we we could have seen something like this before right whenever you have a an increasing list that starts with a bigger value than end with then. It turns ": [
            1395.6,
            1438.7,
            30
        ],
        "So the net weight of the 7 walking time from The Chew 7 come from because it's + 10 - 1 + 7 choose 7 or 10 - 1 + 7 choose 10 - 1 final like the one in group home works. Let's see. possibly well, it's just a using UC San Diego podcast ": [
            4710.8,
            4765.0,
            94
        ],
        "The powers of V you can kind of do them hitter, Italy. Okay. So the first thing we're going to do is prove this Loop invariant. I'm sorry. It's so small, but will write it bigger. So prove the loop invariant that why okay, so I'll just rewrite it. claim after t iterations Y is equal to a + -30 + 1/8 + -30 + 1 V +... + a ": [
            1229.8,
            1278.5,
            27
        ],
        "a + -1 V to the T minus one. + a + - t + 1 okay. Can you guys see how it's going to work out? You're going to add V2 all of those, right and you're going to add the the last term and you can see that whatever the result of this is going to match what we want to show. Any questions about that? I'll just ": [
            1926.1,
            1970.8,
            40
        ],
        "a bit string. has no 101 substring occurrence in which case the recursions going to go all the way down to the base case, right and you're going to do n and recursions you have basically T of n is equal to T of N - 1 + some Constance D. And we all know that t of one is equal to some constant C or something like that. Right? ": [
            3851.5,
            3898.7,
            76
        ],
        "all ends. So that means that F of and is Big O of G event. right What else do we know is it? Is there a way that we can show that it big Omega? so they say it again. So speaker, right so we get a big. Oh, yeah. So how do we show that it's big Omega or not? How do we show that it's not big? Okay, ": [
            874.3,
            949.1,
            19
        ],
        "an is an increasing function. So this limit is going to go to what 0 Now if the limit of f over G goes to zero, what can I conclude? FFN is what of G. Think about it like this. The funk the the low in the denominator function is growing much faster than the numerator function right? It's kind of over taking it and how can I help? Big ": [
            503.9,
            551.1,
            12
        ],
        "and Manistee So it's like you're after the first iteration. The only term you're going to have is a + -1 + 5 + -2 + a + -1 and your kind of like building it off that way kind of like a weird backwards thing. Okay, let some. Let's prove the orbit State the inductive hypothesis. Okay. Yes. Yes. Yeah, so this inductive hypothesis you basically just copy down ": [
            1570.5,
            1620.1,
            33
        ],
        "and then divide out by all the ordering us. Okay. I don't know if that's if you guys like that way that way would look something like you have 9 * 8 * 7 * 6 * 5 * 4 * 1 2 3 4 5 6 7 And then divide out by all the different ways. You can order them. cuz you're taking You know the first the first ": [
            4165.8,
            4195.4,
            82
        ],
        "and this. is defined to be I don't know. What was that POV? You can just say you just say it if you've proven it or if it were if it says like given that the loop invariant is correct. You just say after and iterations or something like that. Okay, any other questions about this algorithm? Next thing is what runtime analysis. Car seat describe the running time of ": [
            2214.5,
            2274.2,
            46
        ],
        "and weird, but you can see how powerful Loop invariant is. It's not as it's not really clear this little kind of dinky equation dinky algorithm is able to evaluate on a polynomial and the reason is because we found the correct Loop invariant too deep to use right now. So we've done part A is correct now Part B. Don't forget this part. All right, if we ask for ": [
            2028.8,
            2064.7,
            42
        ],
        "be equal to what? a of N - n + K of N - n + 1 V plus.... Plus a of n -1 V to the N - 1 so basically, I'm just plugging in and wherever i c a t which was here. here here okay, then we do a little bit of cleanup and we get Y is equal to a 0 + a 1 V +... ": [
            2120.9,
            2167.1,
            44
        ],
        "bound it above by a continuous function, then that's nice and not all kind of give you a kind of like what we did for the first example that we had this weird floor function that's hard to take the limit. But if you bounded above and below by something, that's a little bit nicer. I think that's a good strategy. Get any of the questions. Okay. Was look at ": [
            1129.3,
            1161.6,
            24
        ],
        "can be the same right 7. digit number digits can repeat Okay, so think about it like this. We're still doing decreasing right? So I'm going to have some right going to have some nice here. And then I'm going to have some 8. And I'm going to have some sevens. and then I'm going to have someone's and then I'm going to have some zeros. Okay, and so basically ": [
            4314.3,
            4356.3,
            86
        ],
        "can then you can put them in whatever order is is necessary. Let's do a similar problem first and then work our way to this problem. Okay. So the first problem I want to do is how many 7 digit numbers AR decreasing Such that. all digits are distinct okay, so one way to think about this is You can. Figure out all the seven digit numbers that are possible ": [
            4118.9,
            4165.8,
            81
        ],
        "digit could be whatever you want and then the second digit just has to not be the first right and so on you build it that way and then every different way you've ordered the same one will correspond to a different permutation. So you basically counted all of those. sex and factorial times each Oh, there's zero right. Thank you. like that Oh. Does it say that? It's a ": [
            4195.4,
            4241.4,
            83
        ],
        "equal to T of N - 1 + some constant. Okay, so Well, we can solve this using unraveling if you like. Okay, so we know that t of n minus 1 is equal to T of N - 2 + D rent so plug that in. Tia van is equal to T of + -2 plus d plus d equals T of N - 2 + 2 D. You ": [
            3295.7,
            3353.8,
            65
        ],
        "factorial. Yeah. or The way I like to think about it is 10 to 7 to seven of those 10 numbers. Once you have them in a set you can order them whatever way you want to order them in decreasing order and that would be the order. What kind of make sense? Okay. Now if the if the if the digits are Different I mean the same the digits ": [
            4280.5,
            4314.3,
            85
        ],
        "false Okay. If n is equal to 3. That's it. Depends. Let's do it and is equal to 0. How about that? If n is equal to zero return false. Cuz we have three base cases. Now if n is equal to 3 or bigger now we going to the recursion right? Otherwise What do we want to check? Okay. Yeah, but we have that already. Yeah, those are part ": [
            3587.2,
            3634.0,
            71
        ],
        "floor log base 2 of n is there a way that we can get a lower Bound for the floor function? 2 to the log base 2 of n -1, right cuz we're trying to get a lower down. And so this is equal to 1/2 * 2 to the log base 2 of end. Which is 1/2 in? And that implies that 2 to the log base 2 of ": [
            353.9,
            395.8,
            8
        ],
        "goal is, right? You want to show that Y is equal to I guess I should say. after t plus 1 iterations Why is now equal to a + - t + 1? + 8 + -2 + 1 + 1 B+... A + -1 v t + 1 - 1 thank you can kind of see that you got the idea. Okay, so let's figure out what happens in ": [
            1731.0,
            1777.6,
            36
        ],
        "guys could probably see the pattern going here, right? If you do this k x this will be T event is equal to T of N - k + k d. And so how many times do we need to do it before we get down to the base case? And -1, right? This is like k x this is like two times right? And this is like one one ": [
            3353.8,
            3386.8,
            66
        ],
        "if I can prove this that proves algorithm is correct. like Okay, so I have the counting problems here. you said e okay, we'll start with E and then we'll and then I'll make one up for you. That's kind of in that sense. How many seven digit phone numbers? Strings / 0 through 9. Are there where the digits are not decreasing every digit is less than or equal ": [
            4030.2,
            4083.2,
            79
        ],
        "in between well, We know that 2 to the log base 2 of n has got to be less than or equal to 2 to the log base 2 of n right because the floor function is always less than or equal to whatever is inside. and this is equal to end this implies 2 to the log base 2 of end is Big O of Okay to to the ": [
            313.4,
            353.9,
            7
        ],
        "into stars and bars, but it's like if it's a set. What is a multi set like a set containing multiple copies, then you you want to use stars and bars? Yeah. was that Direct me to 71627. 10 plus 7 minus one cuz there's 10% Castle. Thank you y'all. Thanks guys. You guys are going to do so good you guys are going to do great. Thanks for coming. ": [
            4636.8,
            4692.0,
            93
        ],
        "is only changing by one each time. Okay. So the inductive hypothesis is going to be yes. because we usually would say something like for all when we bring the cake Melanie deep week. Any and all yeah for any in for all they're the same. Okay, so we say suppose Rec evaluate AV Worx let's just say for any polynomial a Such that. is of degree + -1 for ": [
            2657.5,
            2725.0,
            54
        ],
        "is when do I change from 9 to 8 and when do I change from 8 to 7 and you can think about this as putting up barriers like this? right And then the the 7-digit will be like the stars. So this is kind of like the stars and bars. So if I have like let's say I have Three stars here. No stars there two stars. And two ": [
            4381.7,
            4412.7,
            88
        ],
        "it's hard to kind of take the limit here. It doesn't really have a nice closed form. It's kind of kind of balance is all over the place. But so what we can do is either solve this using induction or use some nice bounds write the floor is a easy function to bound because it's always in between two integers and which two integers. Is it going to be ": [
            287.2,
            313.4,
            6
        ],
        "it. It just mainly saying why is the algorithm correct? based on the loop invariant queso Part B prove algorithm is correct based on Loop invariant kids anybody remember how to do this? Set teibel's to end because this Loop is going to terminate after n iterations. so by the loop invariant because we know the Lupin very is true after every iteration, right so after and iterations why should ": [
            2064.7,
            2120.9,
            43
        ],
        "let's see how that would look and you're saying is and x + -1 Down 2 * 3 * 2 * 1 right. So you're saying that that is less than I see you're saying that this is less than n to the N - 1 right Can you take the limit goes to Infinity of f of and over G of n has got to be? Less than right ": [
            949.1,
            1013.3,
            20
        ],
        "limit of f a n over Giovanni's 0 and that means half of n is not big Omega of G of n also F of n is not big Theta Chi event. 00 well, both f and g are positive value functions with all of these things were only going to be using positive value functions or at least functions that are positive valued for begin You can use that ": [
            1038.0,
            1092.9,
            22
        ],
        "list? It should just be 0 right. Y is equal to 0 good Okay, let's move on to the inductive hypothesis. No, you don't have to explain much just say Y is equal to 0 and maybe you say like the end of the sum of all elements in the empty set is 0 it's probably good to keep that in there. Okay question. a - 1 - 1 8th ": [
            1502.5,
            1570.5,
            32
        ],
        "minus What's 30 + 1? V to the V plus.... Plus a to the N minus 1 V2 the T minus one. That's it. Okay now inductor step. We want to show that it's true 40 + 1 right? show It is true. 4 t + 1 okay, and so our way to do this is you want to show sometimes it's nice to kind of put in what your ": [
            1685.4,
            1731.0,
            35
        ],
        "n is Big Omega event. Alright, so we got its Big O and his big Omega. That means it's big Theta and if if G is Big Data of app, that means f is Big Theta of G. questions Okay, let's look at the next one. That's was an is log base. What is it? I guess let's do the default log base 2 of n to the 4th. G ": [
            395.8,
            433.9,
            9
        ],
        "now. Okay. problem for run time now on the exam I'm not going to expect you to design your own algorithm, but it is a it's a nice exercise because then you can kind of practice doing the run time practice doing the correctness and all the stuff to determine whether a bit string of length n contains the substring 101. Okay now. You guys want to go interative or ": [
            3130.1,
            3182.7,
            62
        ],
        "of an x one, which is Big Data and so part C. I would say something like line 3 takes constant time the loop goes end times so the loop takes big Sada of end time. and the rest of the algorithm is constant time so the whole algorithm. takes fixate oven time. Okay, stop. pretty simple runtime analysis Okay. moving on to The iterative algorithm that we just did. ": [
            2309.9,
            2390.0,
            48
        ],
        "of is there any way that I can simplify the numerator? Are you going to use the log rule right and make this for log base 2 of n right and this is love base 2 of end race 4th. So now this log cancels with that and you get limit as n goes to Infinity of 4 / log base 2 of n cubed + log base 2 of ": [
            471.0,
            503.9,
            11
        ],
        "of n is log base 2 of n raised to the 4th Okay. So can we take the limits? Can we take the limit of this one? Might be a little bit easier to to do right so limit as n goes to Infinity of log base 2 of end to the 4th / log base 2 of n to the 4th. This is limit as n goes to Infinity ": [
            433.9,
            471.0,
            10
        ],
        "of the algorithm. I guess I guess you can you can group them all into what you said. Let's just do it that way if and is less than or equal to 2 return false. Okay. Now what now? What do we want to check? Okay, which elements you want to pick? Okay good. So if B + -2 is 1 + B + -1 is 0 + BN is ": [
            3634.0,
            3674.9,
            72
        ],
        "of the input. Okay, so let's go through this example. I like recursive algorithms better. Especially proving them because you don't have to come up with this Loop invariant. You just kind of prove it directly. So, let's see how that works. Okay proof. I like to also claim what's going on. Okay, so clean. wreck evaluate of a oav write a v returns a 0 + a 1 V ": [
            2450.1,
            2504.3,
            50
        ],
        "one of the base case and the whole thing is a recurrence relation. Okay. Okay. Back to this one. Let's build this algorithm. We want recursive algorithm, right? Okay, so consider. What are you guys want to call it? What is it? recursion 101 What about raq101? Rx101 of and now you have a bit string of length. And so let's say I have B1 B2 are the bits up ": [
            3481.5,
            3540.8,
            69
        ],
        "or a who else uses log base 10. physics math is usually log base e who does? Right. That's what I was thinking physics. Anyhow. I guess let's let's take a look here. Okay. So let's do a n is an GE oven is 2 to the log base 2 of n floor. So what are we doing this for function? Well, it's not really like a continuous function. So ": [
            241.5,
            287.2,
            5
        ],
        "out to be an empty list and we're kind of just going to keep that as a general rule general rule. If you have an increasing. I guess it was say a list. a list with increasing indices where the first index is bigger then the last then the list is empty Okay, any questions about that? Okay, so what's the sum of a bunch of things in the empty ": [
            1438.7,
            1502.5,
            31
        ],
        "phone number. Let's just say you can. Exactly and that is 10 to 7 right for this another way to think about it. I'm a bit confused. Why starting with 10 because you couldn't start with 7 of the numbers? Cuz when you decrease farting know this what I'm doing here is I'm I'm counting all the different 7-digit numbers that are possible and then you divide out by 7 ": [
            4241.4,
            4280.5,
            84
        ],
        "position. if that helps with the that help your question. Yeah, yeah. Yeah. Okay, I think. the time for one more What do you all say? Is this you want to see out something else like that? What if there were an increasing order? Same thing, right? the variance stuff Oh. Just no variance. so I don't I can't think I'm trying to think about a way to group this ": [
            4556.4,
            4636.8,
            92
        ],
        "questions I don't know in my opinion a little bit easier to prove you don't have to worry about the teas and it's all over the place. Right this one. It's just assumed it works and then show that it works. Okay. Okay, so Oh, I didn't make you something. Okay. All right. Let me do something real fast. All right. Here we go. problem for copy and paste Okay ": [
            3008.5,
            3130.1,
            61
        ],
        "recursive? Recursive is better write it makes everything easier. No. Oh that reminds me. We didn't do the runtime of that recursive algorithm. Oh crap. Was that part C? Ghetto part B. Give a recurrence. Okay, let's do that. Okay. Okay, so there's one recursive call and it's a size and -1 right? So we have t of n -1 and let's say that this is T of n all ": [
            3182.7,
            3251.5,
            63
        ],
        "regular induction hypothesis because as you can see the wait, this is there's a typo here isn't there. This is fine. Nevermind. Everything's good. Don't worry. Okay, so b b starts from a 1 and goes up 2 N -1. So it's the size of it is one smaller than a so that means that we're going to use a regular induction because you know the size of the input ": [
            2615.0,
            2657.5,
            53
        ],
        "regular induction. Okay, let's continue. want to show wreck evaluate AV works on an arbitrary polynomial a of degree n okay, so let's start with a polynomial of degree n A is equal to a 0 + a 1 v x +... + a v to the end. So what happens in the polynomial in the algorithm is that it set B2B equal, but I guess we can. we actually ": [
            2804.8,
            2871.9,
            57
        ],
        "right? Oh, yeah, you're right. I was thinking. No, you're right. It's got to be in -1. I don't know what I was thinking. Okay, that's good. We're done now which bit strings of length and would be the best-case inputs in your algorithm. Okay good. So Part B. best case b + -2 is 1 b + -1 is 0 b n is 1101 at the end. I think ": [
            3751.3,
            3801.9,
            74
        ],
        "said ignore constants Maybe Okay questions about that. Okay. How about the next one? Apples and is 2 to the 2 end? G of n is 2 to the n What's the best way of doing this one? limit simplify how do you simplify it? Okay, good. So Right, we can rewrite F of an as 4 to the end right and then you can kind of see. That for ": [
            668.1,
            727.5,
            15
        ],
        "say for any polynomial of degree less than or equal to n minus one. You could have said that to it won't it won't change it but only for divide-and-conquer once not only for but for divide and conquer algorithms you want to use strong induction? For this type of algorithm since the size of the sub problem is only decreasing by one each time. You only need to use ": [
            2772.7,
            2804.8,
            56
        ],
        "some And greater than equal to 1. then we're going to want to show that it works for a a polynomial of degree n Any questions about that? This is regular induction. Known sayings for some for some and greater than or equal to one. this thing works on any polynomial of degree N - 1 and then we're going to use that to prove for an strong induction would ": [
            2725.0,
            2772.7,
            55
        ],
        "stars, that would be my 7-digit number would be 9 977-999-7711. So how many barriers do we have? 9 right because there's one in between there's not any ones on the ends, right how many stars? 7 right. So basically I take 16 objects and I pick seven seven seven seven of them to be stars and nine of them to be bars. Let me just do one more. interpretation ": [
            4412.7,
            4479.9,
            89
        ],
        "that it's not. So if those two we can we can conclude that F of n is also not big Theta up to you then. I got questions about that. Okay. last one half of n Is n factorial. Giovanni is an to the end. Okay, so What do you guys think here? Okay. We know that F of an is less than or equal to G of n for ": [
            788.8,
            874.3,
            18
        ],
        "that might help with this Let's say I have a bunch of castles, right? 9 the 8th Castle the seven Castle right all the way down to the 1 castle and the zero Castle. The soldiers are the positions. Right 1 2 3 4 5 6 7. In other words, what we're doing is trying to send 7 soldiers into 9 castles, right? This is kind of like the same. ": [
            4479.9,
            4521.8,
            90
        ],
        "that you're basically setting T to be equal to zero. So wherever you see a t in your Loop invariant. Replace it with a 0. Is that going to cause problems? I kind of just going to get empty right? I guess we can say all negative coefficients are zero. So after zero iterations know what I did in this illusions. Yeah, this is kind of a little bit awkward. ": [
            1323.4,
            1395.6,
            29
        ],
        "that's what are the different algorithm and it just depends on what your algorithm is, right question. Okay, I'm glad you asked that best case when I say that I mean best case and an arbitrary length in. Does it say that? Yeah, cuz it says which bit strings of length would be best case inputs. Okay, how about sea worst-case? Okay, or more specifically or more kind of generally ": [
            3801.9,
            3851.5,
            75
        ],
        "that. Okay. So that's like most of the stuff that I wanted to talk about. We could talk about some more things. You guys want to see some other kinds of problems. In the practice midterm or I need the practice final or any other sources. this one This claim here. That's for the proof. That's for the induction proof. This is what I claim I aim to prove because ": [
            3968.1,
            4030.2,
            78
        ],
        "the F function big O big Omega and big Theta of the chief function. Okay, so we had a nice clarification for the first one. Is this log log base 2 log base 10 or log base. What's the other E-Class? Let's say that the default is log base 2 just because we're computer scientist in here. If you were a chemist, you would go log base 10 or engineer ": [
            207.0,
            241.5,
            4
        ],
        "the T minus one, okay. So now we do kind of the inductive step what happens in that inductive part. So why is reset? to be y equals okay multiply Everybody by V and I'm going to replace this why here with whatever it is in the inductive step, right? We're assuming that it was this value for set correctly. So it would be a + - t +... + ": [
            1883.6,
            1926.1,
            39
        ],
        "the end is going to be bigger than to the end. But if we want to be a little bit more formal we can use a limit here. Limit as n goes to Infinity of 2 to the 2N over 2 to the end is equal to limit as n goes to Infinity. Right. I'm just going to reorder it. This is 2 to the N squared right over 2 ": [
            727.5,
            759.4,
            16
        ],
        "the limit as n goes to Infinity. Into the N - 1 / n to the end and that's equal to limit as n goes to Infinity of 1 / n which is zero. So I guess we'll have to say less than or equal to since it's a limit and we do, you know things kind of act differently when you take limits. And so we found that the ": [
            1013.3,
            1038.0,
            21
        ],
        "the loop invariant and then give an appropriate range 40. And say suppose before you write anyting suppose. 4 he greater than or equal to 0. after Key. I should say for you. Just say for some. T greater than equal to zero after t iterations Y is equal to what was it a of n- t V2 the Oh, no, I think zero. Plus a to the ASAP and ": [
            1620.1,
            1685.4,
            34
        ],
        "the next iteration. I'm just bounce back real fast. So what you do is you take Y and u x v and then you add a and minus I okay and it in this is a nice. This is a nice Loop in the in the sense that the number of iterations you go through is actually equal to I right and so are you just adding on? a + ": [
            1777.6,
            1811.5,
            37
        ],
        "the next problem iterative algorithms. Okay, so this is kind of a cool algorithm. If you guys didn't read it will go through kind of the idea. So you're given a polynomial. AB degree and minus one just some general thing, right and you just specify the polynomial as its list of coefficients from a zero up to a and minor You want to evaluate that polynomial out of certain ": [
            1161.6,
            1197.3,
            25
        ],
        "the other things in there take constant time. And I mean, I guess you can argue that building that a rabie will take linear time, but we're going to assume it takes constant time just like taking one thing off. Okay, so the recursion. 4 run time is this is part B. Yeah. If the sizes one then you just get some constant. Otherwise you get T of n is ": [
            3251.5,
            3295.7,
            64
        ],
        "think about this as a think about this as like a vector. And now be is the vector that just starts from a 1. the size here is + - 1 that means wreck evaluate. What is it? What is it said it to y y is equal to record value 8B TV. By inductive hypothesis. This is equal to A1 Plus a 2v plus... Plus a n V2 the ": [
            2871.9,
            2934.3,
            58
        ],
        "this algorithm in Theta assuming that rhythmic arithmetic operations. Take constant time justify your answer. Okay. Well, I'm just going to I know it's very small, but let me just annotate the algorithm. Okay, this thing since arithmetic operations take constant time. This line takes constant time right big say Taiwan. Do you do a constant? I'm operation the loop goes and X right? So you get big stayed out ": [
            2274.2,
            2309.9,
            47
        ],
        "time. queso and -1 times we get T of n is equal to T of N - + - 1 write + & - 1D so he can t of 1 + N - 1 d is equal to some constant C plus and minus 1 t and from that you can conclude that t of n is Big Theta of n 10 questions about that I say it again. ": [
            3386.8,
            3435.3,
            67
        ],
        "to bien. How's that sound? I know you guys like to start at zero. I'm sorry. I'm sorry. okay, consider this If an is one, right the base case what happens return? It says determine what does determined mean? Yes or no, so I will return yes, right or true. 08 does it weight is says? Contains overturned false. Sorry Okay, what about if n is equal to 2? return ": [
            3540.8,
            3587.2,
            70
        ],
        "to just maybe go through at a steady Pace. You can stop me at any time or if there's something that you wanted to see other than the practice problems and you can ask me that two are there any questions before we begin? Okay, so just to kind of review what we did in this class. We did some algorithm stuff correctness and run time. And with run time, ": [
            132.4,
            168.4,
            2
        ],
        "to the N sew a tutu the end cancels with each and you get limit as n goes to Infinity of two to the end, which we all know is infinity. So if the limit is infinity What does that mean half of an is Big Omega of G of n? Right. What can we say about Big O is active and big ol G event or not. We know ": [
            759.4,
            788.8,
            17
        ],
        "to the next digit. I guess this is kind of your like your question. Oh, okay. Well, we'll do this one and then maybe that all spark some conversation. Okay? so If you ever see something like where the digits are going to be in some specify order like increasing or decreasing then. That just means that you want to set right because once you have a set then you ": [
            4083.2,
            4118.9,
            80
        ],
        "value V running? And so one way you could do it is you could just kind of plug-in V and multiply it by the linear term then Square V and X the quadratic term and then cubed * that right and that's perfectly fine way to do it kind of takes a while though this algorithm. Is a little bit quicker because it kind of takes the fact that these. ": [
            1197.3,
            1228.0,
            26
        ],
        "way to. just sometimes that way it gets a little tricky I think I think I would do something like this. Because I wouldn't want to. Does taking the limit of a factorial is kind of hard because it's like this. Step function, you know it kind of increases in like this weird way. Enter the end is continuous so you can just take the limit. So if you can ": [
            1092.9,
            1129.3,
            23
        ],
        "well We're going to do some review here today mainly going over some of the practice problems and then Andrews going to go over whatever. I don't go over. So we're going to do mainly like the first half of the practice problem. problems and then Andrew will do like the second half. I'm open to any other questions if you guys want to talk about anything else. I'm going ": [
            102.6,
            132.4,
            1
        ],
        "will you please order notation and did time analysis of algorithms? We looked at Dad's trees and graphs accounting principles probability and we did a little bit of encoding and decoding and those kind of things. So these are the These are the places in the book that you can find the topics. Okay, so let's get started. So with the order notation the first few. The question is is ": [
            168.4,
            207.0,
            3
        ],
        "write it out just for so Y is equal to X Everybody by V. So it was a + - t v + a + - t + 1 B squared plus... Plus a + -1 V to the T this whole thing + a + - 50 + 1 and this is what we wanted. to shop done Okay questions about that. I know it was kind of tedious ": [
            1970.8,
            2028.8,
            41
        ],
        "you put them like this. Now how many am I going to have of each one? Well, maybe I have zero have 0 9 0 8 0 7 and then a bunch of sixes and then a few fives, right? But you know, they're going to be like this in the order. So what you can think about is how to arrange them based on. Or another way to say ": [
            4356.3,
            4381.7,
            87
        ]
    },
    "File Name": "Mathematics for Algorithms and Systems - B00 - Jones, Miles E - Winter 2019-lecture_18.flac",
    "Full Transcript": "Listen to a podcast.  I just put 1314 because it's going to be today and tomorrow.  Yeah, it's payday Eve.  Is there anything special going on today?  tomorrow  I love pie.  You talk about the number or the food?  Okay, okay.  I think I like the the food better than the number.  Is that crazy?  I am  know how  alright, so  Everybody ready for the final on Saturday? Yeah.  No.  well  We're going to do some review here today mainly going over some of the practice problems and then Andrews going to go over whatever. I don't go over. So we're going to do mainly like the first half of the practice problem.  problems  and then Andrew will do like the second half. I'm open to any other questions if you guys want to talk about anything else. I'm going to just maybe go through at a steady Pace. You can stop me at any time or if there's something that you wanted to see other than the practice problems and you can ask me that two are there any questions before we begin?  Okay, so  just to kind of review what we did in this class. We did some algorithm stuff correctness and run time. And with run time, will you please order notation and did time analysis of algorithms? We looked at Dad's trees and graphs accounting principles probability and we did a little bit of encoding and decoding and those kind of things. So these are the  These are the places in the book that you can find the topics.  Okay, so  let's get started. So with the order notation the first few.  The question is is the F function big O big Omega and big Theta of the chief function. Okay, so we had a nice clarification for the first one. Is this log log base 2 log base 10 or log base.  What's the other E-Class?  Let's say that the default is log base 2 just because we're computer scientist in here. If you were a chemist, you would go log base 10 or engineer or a who else uses log base 10.  physics  math is usually log base e  who does?  Right. That's what I was thinking physics. Anyhow.  I guess let's let's take a look here.  Okay. So let's do a n is an GE oven is 2 to the log base 2 of n floor. So what are we doing this for function? Well, it's not really like a continuous function. So it's hard to kind of take the limit here. It doesn't really have a nice closed form. It's kind of kind of balance is all over the place. But so what we can do is either solve this using induction or use some nice bounds write the floor is a easy function to bound because it's always in between two integers and which two integers. Is it going to be in between well,  We know that 2 to the log base 2 of n has got to be less than or equal to 2 to the log base 2 of n right because the floor function is always less than or equal to whatever is inside.  and this is equal to end this implies 2 to the log base 2 of end is Big O of  Okay to to the floor log base 2 of n is there a way that we can get a lower Bound for the floor function?  2 to the log base 2 of n -1, right cuz we're trying to get a lower down.  And so this is equal to 1/2 * 2 to the log base 2 of end.  Which is 1/2 in?  And that implies that 2 to the log base 2 of n is Big Omega event.  Alright, so we got its Big O and his big Omega. That means it's big Theta and if if G is Big Data of app, that means f is Big Theta of G.  questions  Okay, let's look at the next one. That's was an is log base. What is it?  I guess let's do the default log base 2 of n to the 4th.  G of n is log base 2 of n raised to the 4th  Okay.  So can we take the limits? Can we take the limit of this one?  Might be a little bit easier to to do right so limit as n goes to Infinity of log base 2 of end to the 4th / log base 2 of n to the 4th.  This is limit as n goes to Infinity of is there any way that I can simplify the numerator?  Are you going to use the log rule right and make this for log base 2 of n right and this is love base 2 of end race 4th.  So now this log cancels with that and you get limit as n goes to Infinity of 4 / log base 2 of n cubed + log base 2 of an is an increasing function. So this limit is going to go to what 0  Now if the limit of f over G goes to zero, what can I conclude?  FFN is what of G.  Think about it like this.  The funk the the low in the denominator function is growing much faster than the numerator function right? It's kind of over taking it and  how can I help?  Big O good  Okay. This is what we can cook conclude. Can we conclude anything about big Omega?  Is f of an oar sorry G of n is Big Omega of GE oven or not, or is it inconclusive?  It's not we know that for a fact it's not big Omega.  Okay. So what does that mean about big Sada?  Not Big Data.  There any questions about that?  Okay, next one.  FN is N squared G of n is 1,000 and squared + 2 to the 100.  Okay. So this one what you might want to do is kind of simplified GN into like a a simpler.  Form Frank remember we can ignore constants and ignore coefficients.  So if we ignore constants and ignore coefficients that shows you that  G of n is Big Theta of N squared  Crossing out the said ignore constants Maybe  Okay questions about that.  Okay.  How about the next one?  Apples and is 2 to the 2 end?  G of n is 2 to the n  What's the best way of doing this one?  limit  simplify  how do you simplify it?  Okay, good. So  Right, we can rewrite F of an as 4 to the end right and then you can kind of see.  That for the end is going to be bigger than to the end. But if we want to be a little bit more formal we can use a limit here.  Limit as n goes to Infinity of 2 to the 2N over 2 to the end is equal to limit as n goes to Infinity.  Right. I'm just going to reorder it. This is 2 to the N squared right over 2 to the N sew a tutu the end cancels with each and you get limit as n goes to Infinity of two to the end, which we all know is infinity. So if the limit is infinity  What does that mean half of an is Big Omega of G of n?  Right. What can we say about Big O is active and big ol G event or not.  We know that it's not.  So if those two we can we can conclude that F of n is also not big Theta up to you then.  I got questions about that.  Okay.  last one  half of n  Is n factorial.  Giovanni is an to the end.  Okay, so  What do you guys think here?  Okay.  We know that F of an is less than or equal to G of n for all ends. So that means that F of and is Big O of G event.  right  What else do we know is it? Is there a way that we can show that it big Omega?  so  they say it again.  So speaker, right so we get a big. Oh, yeah. So how do we show that it's big Omega or not? How do we show that it's not big?  Okay, let's see how that would look and you're saying is and x + -1 Down 2 * 3 * 2 * 1 right. So you're saying that that is  less than I see you're saying that this is less than n to the N - 1  right  Can you take the limit goes to Infinity of f of and over G of n has got to be?  Less than right the limit as n goes to Infinity.  Into the N - 1 / n to the end and that's equal to limit as n goes to Infinity of 1 / n which is zero. So I guess we'll have to say less than or equal to since it's a limit and we do, you know things kind of act differently when you take limits. And so we found that the limit of f a n over Giovanni's 0 and that means  half of n is not big Omega of G of n  also F of n is not big Theta Chi event.  00  well, both f and g are positive value functions with all of these things were only going to be using positive value functions or at least  functions that are positive valued for begin  You can use that way to.  just sometimes that way it gets a little  tricky  I think I think I would do something like this.  Because I wouldn't want to.  Does taking the limit of a factorial is kind of hard because it's like this.  Step function, you know it kind of increases in like this weird way.  Enter the end is continuous so you can just take the limit. So if you can bound it above by a continuous function, then that's nice and not all kind of give you a  kind of like what we did for the first example that we had this weird floor function that's hard to take the limit. But if you bounded above and below by something, that's a little bit nicer. I think that's a good strategy.  Get any of the questions.  Okay.  Was look at the next problem iterative algorithms.  Okay, so this is kind of a cool algorithm. If you guys didn't read it will go through kind of the idea. So you're given a polynomial.  AB degree and minus one just some general thing, right and you just specify the polynomial as its list of coefficients from a zero up to a and minor  You want to evaluate that polynomial out of certain value V running?  And so one way you could do it is you could just kind of plug-in V and multiply it by the linear term then Square V and X the quadratic term and then cubed * that right and that's perfectly fine way to do it kind of takes a while though this algorithm.  Is a little bit quicker because it kind of takes the fact that these.  The powers of V you can kind of do them hitter, Italy.  Okay. So the first thing we're going to do is prove this Loop invariant. I'm sorry. It's so small, but will write it bigger. So prove the loop invariant that why okay, so I'll just rewrite it.  claim  after t iterations  Y is equal to a + -30 + 1/8 + -30 + 1 V +... + a + -1 V to the T minus one  Okay.  Now, let's do the proof bass case.  What's up bass case usually is before you even go into the loop.  I ain't usually get like the the simplest form of the base case and the way that you you talked about it is you say.  after 0 iterations  and in or AKA  before entering  the loop  but the trick here is that you're basically setting T to be equal to zero.  So wherever you see a t in your Loop invariant.  Replace it with a 0.  Is that going to cause problems?  I kind of just going to get empty right?  I guess we can say all negative coefficients are zero.  So after zero iterations know what I did in this illusions.  Yeah, this is kind of a little bit awkward. Right? What happens is that?  You're going from a and minus zero all the way up to a 10-1 rent. And this is supposed to be like an increasing list. So that turns into the empty list.  And I don't know we we could have seen something like this before right whenever you have a an increasing list that starts with a bigger value than end with then. It turns out to be an empty list and we're kind of just going to keep that as a general rule general rule.  If you have an increasing.  I guess it was say a list.  a list with  increasing  indices  where  the first index  is bigger  then the last  then the list  is empty  Okay, any questions about that?  Okay, so what's the sum of a bunch of things in the empty list? It should just be 0 right.  Y is equal to 0 good  Okay, let's move on to the inductive hypothesis.  No, you don't have to explain much just say Y is equal to 0 and maybe you say  like the end of the sum of all elements in the empty set is 0  it's probably good to keep that in there.  Okay question.  a - 1 - 1  8th and Manistee  So it's like you're after the first iteration. The only term you're going to have is a + -1 + 5 + -2 + a + -1 and your kind of like building it off that way kind of like a weird backwards thing.  Okay, let some.  Let's prove the orbit State the inductive hypothesis.  Okay.  Yes.  Yes. Yeah, so this inductive hypothesis you basically just  copy down the loop invariant and then give an appropriate range 40.  And say suppose before you write anyting suppose.  4  he greater than or equal to 0.  after  Key.  I should say for you. Just say for some.  T greater than equal to zero  after t iterations  Y is equal to what was it a of n- t  V2 the  Oh, no, I think zero.  Plus  a to the ASAP and minus  What's 30 + 1?  V to the V plus.... Plus a to the N minus 1 V2 the T minus one.  That's it. Okay now inductor step.  We want to show that it's true 40 + 1 right?  show  It is true.  4 t + 1 okay, and so our way to do this is you want to show sometimes it's nice to kind of put in what your goal is, right?  You want to show that Y is equal to I guess I should say.  after t plus 1 iterations  Why is now equal to a + - t + 1?  + 8 + -2 + 1 + 1  B+... A + -1 v t + 1 - 1  thank you can kind of see that you got the idea.  Okay, so  let's figure out what happens in the next iteration.  I'm just bounce back real fast.  So what you do is you take Y and u x v and then you add a and minus I okay and it in this is a nice.  This is a nice Loop in the in the sense that the number of iterations you go through is actually equal to I right and so are you just adding on?  a + -  the number of iterations so  Now we do the step, okay.  so during  the tea + 1  iteration  Y is equal to v y  + 1/8 + -2 + 1  right  by the inductive hypothesis, whatever why was before was whatever we had in the inductive hypothesis. So, bye-bye.  inductive hypothesis, why originally  is  Y is equal to a n minus t plus... + 8 + -1 V to the T minus one, okay.  So now we do kind of the inductive step what happens in that inductive part. So why is reset?  to be  y equals okay multiply Everybody by V and I'm going to  replace this why here with whatever it is in the inductive step, right? We're assuming that it was this value for set correctly.  So it would be a + - t +... + a + -1 V to the T minus one.  + a + - t + 1  okay. Can you guys see how it's going to work out?  You're going to add V2 all of those, right and you're going to add the the last term and you can see that whatever the result of this is going to match what we want to show.  Any questions about that?  I'll just write it out just for  so Y is equal to X Everybody by V. So it was a + - t  v + a + - t +  1  B squared plus... Plus  a + -1 V to the T  this whole thing + a + - 50 + 1  and this  is  what we wanted.  to shop  done  Okay questions about that.  I know it was kind of tedious and weird, but you can see how powerful Loop invariant is.  It's not as it's not really clear this little kind of dinky equation dinky algorithm is able to evaluate on a polynomial and the reason is because we found the correct Loop invariant too deep to use right now. So we've done part A is correct now Part B. Don't forget this part.  All right, if we ask for it.  It just mainly saying why is the algorithm correct?  based on the loop invariant  queso Part B  prove algorithm  is correct  based on Loop invariant  kids anybody remember how to do this?  Set teibel's to end because this Loop is going to terminate after n iterations.  so by the loop invariant because we know the Lupin very is true after every iteration, right so after  and iterations  why should be equal to what?  a of N - n + K of N - n + 1 V  plus.... Plus a of n  -1 V to the N - 1  so basically, I'm just plugging in and wherever i c a t  which was here.  here  here  okay, then we do a little bit of cleanup and we get  Y is equal to a 0 + a 1 V +... + a + - 1 V - in - 1 that's what we want.  That's what that's how you get the thing.  Okay, any questions about that?  That's it.  It's clear that that's what you want for this problem. I mean is there and this I think this is what we had in the  in the problem specification  I maybe we didn't.  Yeah, I guess.  Yeah, maybe you just say and this.  is defined  to be I don't know. What was that POV?  You can just say you just say it if you've proven it or if it were if it says like given that the loop invariant is correct. You just say after and iterations or something like that.  Okay, any other questions about this algorithm?  Next thing is what runtime analysis.  Car seat describe the running time of this algorithm in Theta assuming that rhythmic arithmetic operations. Take constant time justify your answer. Okay. Well, I'm just going to I know it's very small, but let me just annotate the algorithm.  Okay, this thing since arithmetic operations take constant time. This line takes constant time right big say Taiwan.  Do you do a constant? I'm operation the loop goes and X right?  So you get big stayed out of an x one, which is Big Data and  so part C. I would say something like  line 3 takes  constant time  the loop  goes end times  so the loop  takes big Sada of end time.  and the rest  of the algorithm  is constant time  so the whole algorithm.  takes  fixate oven time.  Okay, stop.  pretty simple runtime analysis  Okay.  moving on to  The iterative algorithm that we just did.  Okay.  recursive algorithm  okay, so this one is  It's the same thing.  right  so  The same problem is a different algorithm. It's very similar, right but the proofs even though they're both induction.  There are different.  Okay, and this is a big thing that I want you to realize is that  an iterative algorithms. The induction is on the number of iterations recursive algorithms. The induction is on the size of the input.  Okay, so let's go through this example.  I like recursive algorithms better.  Especially proving them because you don't have to come up with this Loop invariant. You just kind of prove it directly. So, let's see how that works.  Okay proof.  I like to also claim what's going on. Okay, so clean.  wreck evaluate  of a  oav write a v returns  a 0 + a 1 V +... + a + -1 V to the N - 1 for any  V & N E  a of  degree  and -1 for any n greater than or equal to one.  So if you write it up like this a kind of like helps you with understanding what's going to be my induction variables going to be in the size of the input, right?  Okay, so  the proof  bass case  Okay. Well, I claim it will work for all and greater than equal to one. So let's say that and is equal to one right then.  a  is degree zero?  Right and so a is equal to just some value a right.  And in the algorithm you just returned that value.  correctly  returns  a0  I got any questions about that.  Okay.  inductive hypothesis  okay, so we're going to use a regular induction hypothesis because as you can see the  wait, this is  there's a typo here isn't there.  This is fine. Nevermind. Everything's good. Don't worry.  Okay, so b b starts from a 1 and goes up 2 N -1. So it's the size of it is one smaller than a so that means that we're going to use a regular induction because you know the size of the input is only changing by one each time. Okay. So the inductive hypothesis is going to be yes.  because we usually would say something like for all when we  bring the cake Melanie deep week.  Any and all yeah for any in for all they're the same.  Okay, so we say  suppose  Rec  evaluate  AV  Worx let's just say  for any  polynomial a  Such that.  is of degree  + -1  for some  And greater than equal to 1.  then we're going to want to show that it works for a  a polynomial of degree n  Any questions about that?  This is regular induction.  Known sayings for some for some and greater than or equal to one.  this thing works on any polynomial of degree N - 1  and then we're going to use that to prove for an strong induction would say for any polynomial of degree less than or equal to n minus one.  You could have said that to it won't it won't change it but  only for divide-and-conquer once not only for but for divide and conquer algorithms you want to use strong induction?  For this type of algorithm since the size of the sub problem is only decreasing by one each time. You only need to use regular induction.  Okay, let's continue.  want to show  wreck evaluate  AV works  on  an arbitrary  polynomial  a of degree n  okay, so let's start with a polynomial of degree n  A is equal to a 0 + a 1 v x +... + a v to the end.  So what happens in the polynomial in the algorithm is that it set B2B equal, but I guess we can.  we actually think about this as a  think about this as like a vector.  And now be is the vector that just starts from a 1.  the size here  is + - 1  that means wreck evaluate.  What is it? What is it said it to y y is equal to record value 8B TV.  By inductive hypothesis. This is equal to  A1 Plus a 2v plus... Plus a n  V2 the N - 1  Right because that's what it should do for a polynomial of degree + -1.  Any questions about that?  That's what we claim that it should do. So that's where using our inductive hypothesis.  Okay, then the next line is.  Y is equal to v y x v  Plus a zero, so that's equal to well why in this case is a 1 plus A 2v Plus... Class A.  And we to the end - 1 * V.  Plus a zero and if you just kind of simplify this you got a 1 V + a 2 V squared plus... Plus anv to the end.  Plus a zero, which is what we want. Let's just rearrange the terms a 0 + a 1 b + A to B squared +... + A + B to the end.  any questions  I don't know in my opinion a little bit easier to prove you don't have to worry about the teas and it's all over the place. Right this one. It's just assumed it works and then show that it works.  Okay.  Okay, so  Oh, I didn't make you something.  Okay.  All right. Let me do something real fast.  All right. Here we go.  problem for  copy  and paste  Okay now.  Okay.  problem for run time now on the exam I'm not going to expect you to design your own algorithm, but it is a it's a nice exercise because then you can kind of  practice doing the run time practice doing the correctness and all the stuff to determine whether a bit string of length n contains the substring 101.  Okay now.  You guys want to go interative or recursive?  Recursive is better write it makes everything easier. No.  Oh that reminds me. We didn't do the runtime of that recursive algorithm.  Oh crap.  Was that part C?  Ghetto part B. Give a recurrence. Okay, let's do that.  Okay.  Okay, so there's one recursive call and it's a size and -1 right? So we have t of n -1 and let's say that this is T of n all the other things in there take constant time. And I mean, I guess you can argue that building that a rabie will take linear time, but we're going to assume it takes constant time just like taking one thing off.  Okay, so the recursion.  4 run time  is  this is part B.  Yeah.  If the sizes one then you just get some constant. Otherwise you get T of n is equal to T of N - 1 + some constant.  Okay, so  Well, we can solve this using unraveling if you like.  Okay, so we know that t of n minus 1 is equal to T of N - 2 + D rent so plug that in.  Tia van is equal to T of + -2  plus d  plus d  equals T of N - 2 + 2 D.  You guys could probably see the  pattern going here, right?  If you do this k x this will be T event is equal to T of N - k + k d.  And so how many times do we need to do it before we get down to the base case?  And -1, right?  This is like k x this is like two times right? And this is like one one time.  queso and -1 times we get T of n is equal to T of N - + - 1 write + & - 1D so he can t of 1 + N - 1 d  is equal to some constant C plus and minus 1 t  and from that you can conclude that t of n is Big Theta of n  10 questions about that  I say it again.  How are they different?  once they want  Oh, yeah. Okay, so  I kind of think about like the  The recurrence relation as the pair right? You get the base case and you get the recurrence.  Yeah, I guess it's sort of like a loose thing.  But I guess what if I say recurrence, then I'm thinking of the base case and the relation I guess one is the relation in one of the base case and the whole thing is a recurrence relation.  Okay.  Okay.  Back to this one. Let's build this algorithm.  We want recursive algorithm, right?  Okay, so consider.  What are you guys want to call it?  What is it?  recursion 101  What about raq101?  Rx101 of and now you have a bit string of length. And so let's say I have B1 B2 are the bits up to bien.  How's that sound? I know you guys like to start at zero.  I'm sorry. I'm sorry.  okay, consider this  If an is one, right the base case what happens return?  It says determine what does determined mean?  Yes or no, so I will return yes, right or true.  08 does it weight is says?  Contains overturned false. Sorry  Okay, what about if n is equal to 2?  return false  Okay.  If n is equal to 3.  That's it. Depends. Let's do it and is equal to 0. How about that?  If n is equal to zero return false.  Cuz we have three base cases.  Now if n is equal to 3 or bigger now we going to the recursion right? Otherwise  What do we want to check?  Okay. Yeah, but we have that already.  Yeah, those are part of the algorithm. I guess I guess you can you can group them all into what you said. Let's just do it that way if and is less than or equal to 2 return false.  Okay. Now what now? What do we want to check?  Okay, which elements you want to pick?  Okay good. So if B + -2 is 1 + B + -1 is 0 + BN is 1 then.  return  true  right  otherwise  return  what?  Rock 101 from B1 up to where  can I go to Be a Menace 2?  Let's go to be in -1. I like that better.  Then we won't have either way.  Okay, any questions about that?  Yeah, that's just a personal preference.  If you wanted to check from the front, then that's fine, too.  either way  Kimberly check from the middle though, right?  Oh, yeah, you're right. I was thinking.  No, you're right. It's got to be in -1.  I don't know what I was thinking.  Okay, that's good. We're done now which bit strings of length and would be the best-case inputs in your algorithm. Okay good. So Part B.  best case  b + -2 is 1 b + -1 is 0 b n is 1101 at the end. I think that's what are the different algorithm and it just depends on what your algorithm is, right question.  Okay, I'm glad you asked that best case when I say that I mean best case and an arbitrary length in.  Does it say that? Yeah, cuz it says which bit strings of length would be best case inputs.  Okay, how about sea worst-case?  Okay, or more specifically or more kind of generally a bit string.  has no  101  substring  occurrence  in which case  the recursions going to go all the way down to the base case, right and you're going to do n  and recursions  you have basically T of n is equal to T of N - 1 + some Constance D. And we all know that t of one is equal to some constant C or something like that. Right? And in this case, you're going to have to go all the way down to the base case and we already  solve this recurrence and you get  the event is Big Theta event.  Okay questions about that.  Oh, yeah, you're right. It is T2, isn't it?  Thank you.  But you still get the same big fat event.  Okay any questions?  Oh.  You should be.  Run time is constant.  Didn't say that.  Okay.  So that's like most of the stuff that I wanted to talk about. We could talk about some more things. You guys want to see some other kinds of problems.  In the practice midterm or I need the practice final or any other sources.  this one  This claim here. That's for the proof. That's for the induction proof. This is what I claim I aim to prove because if I can prove this that proves algorithm is correct.  like  Okay, so I have the counting problems here.  you said e  okay, we'll start with E and then we'll and then I'll make one up for you. That's kind of in that sense.  How many seven digit phone numbers?  Strings / 0 through 9. Are there where the digits are not decreasing every digit is less than or equal to the next digit. I guess this is kind of your like your question.  Oh, okay. Well, we'll do this one and then maybe that all spark some conversation. Okay?  so  If you ever see something like where the digits are going to be in some specify order like increasing or decreasing then.  That just means that you want to set right because once you have a set then you can then you can put them in whatever order is is necessary. Let's do a similar problem first and then work our way to this problem. Okay. So the first problem I want to do is how many  7 digit  numbers  AR  decreasing  Such that.  all digits  are distinct  okay, so one way to think about this is  You can.  Figure out all the seven digit numbers that are possible and then divide out by all the ordering us. Okay. I don't know if that's if you guys like that way that way would look something like you have 9 * 8 * 7 * 6 * 5 * 4 * 1 2 3 4 5 6 7  And then divide out by all the different ways. You can order them.  cuz you're taking  You know the first the first digit could be whatever you want and then the second digit just has to not be the first right and so on you build it that way and then every different way you've ordered the same one will correspond to a different permutation. So you basically counted all of those.  sex and factorial times each  Oh, there's zero right. Thank you.  like that  Oh.  Does it say that?  It's a phone number. Let's just say you can.  Exactly and that is 10 to 7 right for this another way to think about it.  I'm a bit confused. Why starting with 10 because you couldn't start with 7 of the numbers? Cuz when you decrease farting know this what I'm doing here is I'm I'm counting all the different 7-digit numbers that are possible and then you divide out by 7 factorial.  Yeah.  or  The way I like to think about it is 10 to 7 to seven of those 10 numbers. Once you have them in a set you can order them whatever way you want to order them in decreasing order and that would be the order.  What kind of make sense?  Okay. Now if the if the  if the digits are  Different I mean the same the digits can be the same right 7.  digit  number  digits can repeat  Okay, so think about it like this. We're still doing decreasing right?  So I'm going to have some right going to have some nice here.  And then I'm going to have some 8.  And I'm going to have some sevens.  and then I'm going to have someone's  and then I'm going to have some zeros. Okay, and so basically you put them like this. Now how many am I going to have of each one? Well, maybe I have zero have 0 9 0 8 0 7 and then a bunch of sixes and then a few fives, right? But you know, they're going to be like this in the order.  So what you can think about is how to arrange them based on.  Or another way to say is when do I change from 9 to 8 and when do I change from 8 to 7 and you can think about this as putting up barriers like this?  right  And then the the 7-digit will be like the stars. So this is kind of like the stars and bars. So if I have like let's say I have  Three stars here. No stars there two stars.  And two stars, that would be my 7-digit number would be 9 977-999-7711.  So how many barriers do we have?  9 right because there's one in between there's not any ones on the ends, right how many stars?  7 right. So basically I take 16 objects and I pick seven seven seven seven of them to be stars and nine of them to be bars.  Let me just do one more.  interpretation that might help with this  Let's say I have a bunch of castles, right?  9  the 8th Castle  the seven Castle right all the way down to the 1 castle and the zero Castle.  The soldiers are the positions.  Right 1 2 3 4 5 6 7.  In other words, what we're doing is trying to send 7 soldiers into 9 castles, right? This is kind of like the same.  Metaphor that we had from before so if you can you can say maybe like what I had before was I had three soldiers here.  Two Soldiers here and Two Soldiers here, right and once you put them in there, you know, which order they have to go in the positions. You just send you send these guys to the three you just send them to the first available open position.  if that helps with the  that help your question.  Yeah, yeah. Yeah.  Okay, I think.  the time for one more  What do you all say?  Is this you want to see out something else like that?  What if there were an increasing order?  Same thing, right?  the variance stuff  Oh.  Just no variance.  so  I don't I can't think I'm trying to think about a way to group this into stars and bars, but it's like if it's a set.  What is a multi set like a set containing multiple copies, then you you want to use stars and bars?  Yeah.  was that  Direct me to 71627.  10 plus 7 minus one cuz there's 10% Castle. Thank you y'all.  Thanks guys.  You guys are going to do so good you guys are going to do great. Thanks for coming.  So the net weight of the 7 walking time from The Chew 7 come from  because it's  + 10 - 1  + 7 choose 7 or 10 - 1 + 7 choose 10 - 1  final like the one in group home works. Let's see.  possibly  well, it's just a  using  UC San Diego podcast "
}