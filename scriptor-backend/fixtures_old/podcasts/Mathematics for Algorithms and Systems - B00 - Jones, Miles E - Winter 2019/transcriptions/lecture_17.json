{
    "Blurbs": {
        "All right. Okay. None of the above, huh? More than the about more than one. Which ones? A&B A&D okay. Okay, let's let's name these and you tell me what you're ordering is. What's a good ordering here? All right, I think that's fine, right? What's one way to tell that? What was it a VDC and be right that it's a good ordering is if you redraw your graph ": [
            2592.1,
            2667.0,
            65
        ],
        "Ang Ang are the only sources? Okay vertices with no outgoing edges are called sinks. So F and I are sinks. Okay, good thing else is just do whatever so if Dad can have more than one source, I can have more than one sink, but it's got to the top of logical ordering has got to start in a source and it's got to end in the sink right ": [
            3272.3,
            3302.7,
            79
        ],
        "Annie goes down to one. Okay, so we just did this whole thing for a and then the resulting graph we have is now this with a removed and all of the other edges removed. Okay, so let's just kind of go through this quickly the next vertex to remove. Well, let's say that this was a q. So we're moving the First one is going to be the first ": [
            3821.3,
            3855.4,
            95
        ],
        "D and then H and then and then I And this is going to be a topological sort. How long does a sack? guess that's maybe we'll end a little early today. Okay. So this is kind of like the completion of all the material and on Wednesday. We're going to do some more stuff for the review. Can you see San Diego podcast? ": [
            3928.7,
            3986.4,
            98
        ],
        "D4 sure, how about sea? How about be? Yes. Yes. how about a No. OK every in every internal vertex has exactly two children. So every internal vertex is a vertex that's not a leaf. Every nanoleaf vertex has exactly two children. So this would also be a full binary tree. You call it like a full binary tree. I would call it a a I'll call it a complete ": [
            943.8,
            994.4,
            24
        ],
        "H + 1 - 1 queso a tree of height H. This is the maximum number of vertices that it can have any questions about that. This is when it's complete and the the bottom layer layer is built. Okay, so you can kind of solve for H here and get that. H is equal to log of n + 1 - 1 so if n is the number of ": [
            1096.1,
            1127.6,
            27
        ],
        "I wanted to include all the vertices? Is it possible? Is it possible for this graph? Is there a way to take all the classes? Yeah, right. I mean some of you have already have are already on your way of doing it right or have it planned out. Are these required classes for everybody? some of them Okay, so then the question is is this possible for any graph? ": [
            2490.8,
            2519.2,
            63
        ],
        "I'll special case of dags. I didn't mean from last class from later later on. Okay, so let's let's look at some examples which of the following directed graphs are trees with root indicated in green. Are rooted trees. Okay. Good only see right what's wrong with a Write this one has two incoming edges. What's wrong with d? That is a consequence but really it's because this one has ": [
            570.3,
            623.1,
            15
        ],
        "II moves and you score them all and you take the one with the max score or the one that kind of changes your score the most. This is like a parsing. Tree. So this is what your parser does when you give it some code. It will break up that the sequence of characters and put them into different categories and Basically to make sense of the syntax, right? ": [
            162.7,
            195.4,
            4
        ],
        "Let's say g - V is the graph that results when we were a movie and all of its outgoing edges from G. Okay, so he's kind of like take the vertex away and everything that I had to do with the graph. Okay now. Let's think about what happens when you take a source away from a dag. The result is still a dag. You guys believe that? Let's ": [
            3459.6,
            3491.4,
            85
        ],
        "Let's take a look. what we want to do now is ask try to ask this question about all grass. Is it possible to have a good ordering which which kind of graph is it possible for? And which is there a simple rule that can tell you if I can make a good ordering? Okay, let's look at these three which of the following graphs. Have a good ordering. ": [
            2521.3,
            2552.7,
            64
        ],
        "Listen to a podcast. So let's get started. Let's see today is like the last day of new material on Wednesday. I'm going to do some review and Andrew and I are going to kind of do like a two-part review for Wednesday and Thursday during class. And so I'll be doing like the first half of class and he'll do the second half sort of we might split it ": [
            1.9,
            40.6,
            0
        ],
        "Okay, so the first thing I do. is Consider a right that's this part choose some vertex in ass. Then look at all of the vertices adjacent to it. Okay, so we have B we have C and we have he so decrement each one of those be goes down to zero and never goes down to zero throw it into your set of sources. Sea goes down to zero. ": [
            3786.5,
            3820.2,
            94
        ],
        "They have these the same exact kind of trees in linguistics. My dad was a linguist. So he would always be drawing. All this stuff is the same thing, you know, but instead of like, you know the for Loop and all that kind of stuff it was the noun phrase and verb phrase and all this kind of thing. Okay, this is a what? taxonomic all tree of the ": [
            197.7,
            225.5,
            5
        ],
        "Yeah, you just basically. Go like that. No problem. Okay, how about here? His own brother has a child. Yeah. I think you just recursively go down right that was the best thing to do. that is That is on the 11th Street of the right side of the know your bathroom. Yeah, I think you just kind of. What's the best way to do it? And I'll leave this ": [
            2229.0,
            2328.6,
            58
        ],
        "a You choose a Vertex with at least one outgoing Edge or you choose a Vertex with no incoming edges. Okay, good D through the vortex with no incoming edges. Okay, so that has a special name. It's called a source. So. A Vertex with no incoming edges is called a source which of the vertices are sources. Okay, good. Yeah, that was an easy one. Okay, that's fine. Only ": [
            3227.9,
            3272.3,
            78
        ],
        "a first okay, so Which of the following orderings are okay with meaning? I have Master the prerequisite before I take the next class. Okay, let's see. Okay, we're saying see let's look at them. What's wrong with a you took 100 after 151. What's wrong with B? You put 21 after 1:05. It's going to be hard. How about c c is okay, right you first you take 21 ": [
            2400.7,
            2457.9,
            61
        ],
        "all the values are unique and then we can. Yeah, it doesn't change much if if you have repeated values. Okay. So now how does that how is this going to work? well How are we going to store this because storing an array is really easy right now. It's just a a built-in data structure. How do you store a binary search tree? Each vertex is going to basically ": [
            1774.5,
            1808.1,
            45
        ],
        "answer this think about what you're doing you're taking two copies of t + -1 and then what are you doing? Adding the route also. so via vallen is going to be 2 * V event - 1 write two copies of the tree with n minus the T of N - 1 tree and then plus one because of the root any questions about that. Atlas look at another ": [
            1335.4,
            1374.6,
            33
        ],
        "at binary search trees. What is it? And data structures a binary search tree is a data structure that facilitates efficient search and its Dynamic which means well it sufficiently Dynamic which means that you can add to it and take it away also efficiently. Let's compare it to some other types of data structures that can do the same thing. Okay, let's start with Let's just think about what ": [
            1500.5,
            1534.9,
            37
        ],
        "at it starting right and you know, they kind of have their they're both the same at removing so one's kind of better at the other in certain things. So the next thing we're going to look at it as a binary search tree and it's going to be in general better than all of them both of these in every way. So let's see kind of briefly what that ": [
            1712.4,
            1733.7,
            43
        ],
        "be its own object with four Fields, right? It's going to have a parent field left child field right child field in a value. So what is it mean if pee is no, what does that mean about a node if it's P value is no Okay good. It means that its parent is empty parent field is empty, which means it has no parent. How sad? But there's only ": [
            1808.1,
            1853.6,
            46
        ],
        "binary tree. maybe a complete balanced binary tree Maybe that's not even good enough. I'll complete at a complete binary tree with the bottom level filled. binary tree with all yeah with all leaves on the same level. Cuz complete just means that every level is filled except for maybe the last so I complete the tree with the last level field. Okay, so at most how many vertices are ": [
            994.4,
            1048.8,
            25
        ],
        "class B. I need to take class C in order to take class C. I need to take class D. Okay, that's fine. I'll take class D to take class D. I needed to take class A that's fine. I'll take class A. If you think long enough you're going to keep on going around in circles. Okay, so basically if there's a cycle then you can't find a good ": [
            2745.6,
            2771.0,
            68
        ],
        "describe them with this recursive description. Okay. So for example, if I told you that a particular family of trees T of n t of zero is just a single root and T of n is the tree sets that the root Vortex has two children and each child is the root of T of N - 1 Okay, so it's kind of like you start with a with a ": [
            1221.3,
            1249.7,
            30
        ],
        "do it. Let's just pretend this is a world with no co-requisite. Okay. So thick to classify the all the grass that have good orderings. They're basically all the directed graphs with no Cycles. These are called directed acyclic graphs. Here's one. You can't find a cycle in there and the consequences that every directed acyclic graph has a good ordering. It doesn't necessarily mean that there's a unique good ": [
            2922.3,
            2954.0,
            72
        ],
        "do this one first. Well, we're just going to do kind of like an informal sort of proof here. The idea is you start off with a graph a directed graph with no Cycles. If you take away of vertex, there's no way that you could have created a psycho by doing that right because you're not adding in any edges. You're not adding any vertices. All you're doing is ": [
            3522.6,
            3549.9,
            87
        ],
        "do we want to do? We're collecting data. Let's say we want to store it in a modifiable can collection you want to be able to search in your data for certain targets you want to be able to insert data into it and delete data from it. okay, the first maybe idea that you could come up with is just start with an array of integers that has sort ": [
            1534.9,
            1564.1,
            38
        ],
        "edges. with out degree equal to zero Okay, so here's so I love these tree definitions cuz they're all kind of cute they all have like root and leaf and stuff. So we talk about a tree but you can also think about him as in a family tree. So the route is sort of like the the beginning of the family. And the vertices directly connected to the root ": [
            655.1,
            695.1,
            17
        ],
        "egg has exactly one incoming Edge and you call that it's parent. and so think about these roots as like What do you call an animal? That doesn't? reproduce that reproduces by only with one individual asexual think about these and asexual organisms, which means that you don't have to parents right? You can only have one parent. Okay height of a Vertex is given by this recurrence. the height ": [
            725.5,
            770.1,
            19
        ],
        "example. Now I'm going to say let T of zero just be the single vertex Define t of n to be. A tree such that the roofer text has two children. The left child is a single vertex and the right child is the root of T of N - 1 so you can see we have here we have ta0. Tf1 TF2 and what is T of 3 look ": [
            1374.6,
            1407.8,
            34
        ],
        "family know the order of mammals called Carnivora and so you have like the the cat's the dogs and then like the Badgers and otters and stuff Okay, so you can see trees are everywhere not only in computer science, but all over the place. They come up in Mass a lot to a kind of like a math topic. So we're going to start with undirected trees. So unrooted ": [
            225.5,
            256.1,
            6
        ],
        "for it. And then whenever you find a null value you put it in there if you stick it in there. Okay, here's kind of an idea of how to remove. So you search for the value then you restructure the tree case one the target is a leaf. You just basically remove it and everybody's okay. Case to the Target only has one child. And what are you do? ": [
            2190.2,
            2219.2,
            57
        ],
        "for it. So you going here it's bigger than 2850. It's smaller than 50 go to 36. It's smaller than 36 go to 30. It's bigger than 33 doesn't have any children. So put it there. how to make sense this is also proportional to the height Okay, last one. How do you remove something? What if I ever wanted to remove 21? You have to search for it. Someone ": [
            2042.5,
            2084.5,
            53
        ],
        "get added to the queue and this is the resulting graph. and so noticed that every time we do this this set s is our set of sources. The next one is BB only has one neighbor. So take get rid of him decrement D. And as I'm doing this I'm out putting this list as I go. I can't keep on going with c and then he and then ": [
            3896.6,
            3928.7,
            97
        ],
        "go through you kind of output these sources one by one and keep them in some sort of stack or queue. stupid so this is sort of like them. the summary of the the algorithm that has to do with the array. Okay. So first choose some X for each why that's adjacent to it first to some source for each why that's adjacent to it decrement the in degree ": [
            3709.5,
            3752.8,
            92
        ],
        "go? To the left. Okay, then which way to the right and then to the left 2117 is less than 21 so you go to over to the left also so you can do that for any number and it will tell you whether or not it's in there. Okay notice that we didn't have to go through the in any of the other half. So the the time it ": [
            1942.9,
            1970.6,
            50
        ],
        "guy this as an exercise for you guys. Okay, so Binary search tree. I put big old login. It's really big O of the height. This is kind of like the best case. But you might be unlucky and as you build your search tree, it could kind of like build in like a long line and there are ways around that there are ways to make sure that doesn't ": [
            2328.6,
            2359.6,
            59
        ],
        "happen. I think you learn some of them in 30. Well, you guys have done this already. dinosaur Alright, let's move on. next type of graph gag So basically a dag you can think of as like a curriculum of a university where certain classes are prerequisites of other classes. So if I take course as a prerequisite for corned beef that means you can't take be unless you take ": [
            2359.6,
            2400.7,
            60
        ],
        "how long does it take to insert something? old one, right 01 and to remove Well, you kind of have to find it and then when you remove it, you would have to shift everybody over. This is also Big O of n prank What's a sure? to insert What's a we know? right Okay, how about if this array was sorted and so you want to keep it sorted ": [
            1592.1,
            1650.8,
            40
        ],
        "if it's bigger you go one-way with smaller go the other way and then you just recurse on those just like when we defined the Peachtree recursively remember we said the route has children and each child is the root of their own subtree. You just kind of deal with it that way. Okay, so that search. How about insert? We saw kind of how that works you basically search ": [
            2165.1,
            2190.2,
            56
        ],
        "in that order, all the edges are going in One Direction, right? So Eggos to be that's fine. Sea goes to be Digos to see that's fine. He goes to D and E goes to be Okay, so this is a good at ordering any questions about that. Okay. Hey works too, right? You could do it for that. Maybe you guys can figure that out as an exercise. Okay. ": [
            2667.0,
            2705.1,
            66
        ],
        "is a good amount of time. Right? It's a very efficient amount because you're not going through every single note. All right, let's we'll talk about that in a minute. Okay, so here is just like a few algorithms. We're not going to spend a lot of time on it. I just wanted to kind of prison it for completeness. So then to search something you compare to the root ": [
            2142.7,
            2165.1,
            55
        ],
        "is a tree is a rooted tree where every internal vertex has no more than two children. How many leaves does a binary tree of height 3 have? Now, it's just you guys are too quick. It was supposed to be like a trick question. All right. Let's just forget about that. all of the above right here is a tree of height 3012. 3 with two leaves, right? But ": [
            842.9,
            897.3,
            22
        ],
        "it's not a source then look at its incoming Edge, right? And keep on going until you find the source. Why am I always guaranteed to find a source? There's no cycles and it's finite right? So at some point you're going to have to get to the get to the end. Que NADA Source keep on going look at found the source. Okay, and then you're done. Okay, so ": [
            3334.0,
            3365.5,
            81
        ],
        "keep a noise in degrees, right? Yeah, the end agree to terms if it's a source so we can keep an integer array in degree. And so the first thing you do is you can run Graph Search on it and fill this up right for every vertex. Look at all the in incoming edges and count them up that's going to be the in degree. And then as you ": [
            3680.8,
            3709.5,
            91
        ],
        "kind of like a game tree right decision tree based on tic-tac-toe. And the idea is that you look at all the possibilities and you score each one of them, right and then you know, if you're trying to win then you go for the maximum score. That's kind of how Some chess engines operate like some very simple ones, you know, you you look at all the possible moves ": [
            130.7,
            162.7,
            3
        ],
        "left to right. Talk to algorithmic questions one is given a order list. Is it a topological ordering? How would you how would you verify it to given a graph produce a topological ordering if one exists or in other words figure out if it's a dag if it is a dag then find a ordering. Okay, so let's start with the first question. Given the order list of all ": [
            2983.0,
            3023.5,
            74
        ],
        "let's let's think about it in a more mathematical way of proving it. So assume toward the contradiction that the gag has no Source at all. That means that every vertex has at least one incoming Edge, right? So do the same thing and start with any random vertex and start looking at its incoming edges and keep on going you can you can go on forever right? Because if ": [
            3365.5,
            3392.6,
            82
        ],
        "let's look at an example. Here's an example and let's say that the date of that were trying to store are integers, right? So if you kind of take a look, our route is 28 take a look at its left subtree. All of the values are less than 28 and it's right subtree. All the values are bigger than 28 and each subtree of each other vertex has that ": [
            1890.4,
            1915.5,
            48
        ],
        "let's start at let's say like this if if a tree has n vertices, what's the maximum height I can have what if you just had like a And might as well if it's just a along string. Okay, so we know that the height is got to be in between those two numbers find the maximum minimum. any questions alright trees are very nice because often times you can ": [
            1179.1,
            1221.3,
            29
        ],
        "like you remove 17 ads remove 17. Start somewhere with 24th or somewhere remove 21.7 + 24. Yeah, that would work. I mean in this particular example. You could do that. What if 17 had its own tree hanging down from it? Yeah, maybe you could recursively do it because you want it to be quick to write you wanted to be I'm thinking that the height of the tree ": [
            2084.5,
            2142.7,
            54
        ],
        "like? Well, you have a route from the left child. You just hang a single vertex. And from the right child you hang TF2 which looks like this. So, how did how did the number of leaves grow? On the right child, you have all the leaves from that tree, right wanted to leave. It's always a leaf so it doesn't change right then. You're adding the route, which is ": [
            1407.8,
            1449.0,
            35
        ],
        "looking for. Right because if you take away at an edge in the tree than the then you get to disconnected. Two connected components. This is one way that you can convince yourself that there are and -1 edges right when you take away and Edge you get to Connected components. Will you take away another Edge you get another connected component if you keep on taking away edges like ": [
            382.7,
            412.2,
            10
        ],
        "looks like. So we're going to use this recursive definition of the binary tree in order to facilitate this binary search tree. So you have the root, right and every node in the left subtree of the route is going to be smaller value than the route and everything in the right subtree is going to have bigger value. Sure. I think it doesn't matter but let's just assume that ": [
            1733.7,
            1774.5,
            44
        ],
        "next thing what are the barriers to ordering? What kind of prevented you from ordering on B&D? Whenever there's a cycle, you can't have an ordering, right? You can kind of think about it in this sort of circular way, right? So, let's I want to take class A. Well, I need to I need to take be before I take class A Class B, but in order to take ": [
            2707.1,
            2745.6,
            67
        ],
        "not a topological ordering? Because there's a arrow from what? gc2b Sorry. What you say G to E. Yes. So what do you want to do? How do you prove that? It's a topological ordering Loop through all the edges and check. Do the endpoints come in order? Maybe what you could do is give each vertex a position in the list. 1 2 Right, and then if if that ": [
            3094.0,
            3153.1,
            76
        ],
        "not going to be a leaf and the left child which is a leaf. So basically you're taking all the leaves from T of n -1 and you're adding one more. Any questions about that? Alright, let's move on. So we looked at definition of trees properties of trees how to build trees by know. What this is. This is a Max Heap. Just do that. Okay. So let's look ": [
            1449.0,
            1500.5,
            36
        ],
        "of a Doesn't really have an end right you can kind of keep on making the end bigger. Okay. So let's say that there are an element's or on the order of n elements in order to search for an element. It's going to take Big O of n time, right? Cuz you're going to have to just look through it all it's not in any way sordid. Okay, how ": [
            1564.1,
            1592.1,
            39
        ],
        "of each one of those neighbors, right? And if any one of those neighbors falls down to zero then add it to your list of sources. All right, let's look at how this works on this graph here taking the liberty of populating this in degree array And since my two sources are A & G I put them in ass. So then this is where we start the algorithm. ": [
            3752.8,
            3785.5,
            93
        ],
        "of the is equal to the height of its parent plus one that's like because of this plus that edge and the start of the recurrence is that the height of the root is 0 Okay, what is the height of this red vertex? I know it's kind of messed up and upside down but you can maybe think of the root as like the root of the tree and ": [
            770.1,
            802.5,
            20
        ],
        "one out, right? That's how a key works. Make the first one key was going to be the first one in. Is going to be the first one out. like you first in first out Okay. Okay. So next one. We're going to take his gk3 take G and we decrement its neighbors, which is he and H. That goes down to zero gauge goes down to one so you ": [
            3855.4,
            3896.6,
            96
        ],
        "one vertex out there. That doesn't have a parent. It's the root node. Okay. Good next one. What happens when the left child is now in the right child is no, what does that mean? Okay, good guys are catching on means it is a note. Okay good. So it's really fast to kind of check to see what type of note it is just by looking at those. Okay, ": [
            1853.6,
            1890.4,
            47
        ],
        "or the children of the route and then you have the grandchildren and in general. Everything in the tree is a descendant of the root. Okay, so these are all descendants. Just like in a family tree and everything kind of higher in the tree than a certain vertex. It would be its ancestor, right if there's a direct line backup. Okay, so if a Vertex is not the root ": [
            695.1,
            725.5,
            18
        ],
        "ordering but it definitely has one. Okay. Now let's stop talking about good orderings. It's actually called a topological ordering. It's a order list of all of its vertices such that for each directed Edge VW in the graph V comes before W in the list that was kind of like what I was saying before we're if you draw in all the arrows, they're always going to go from ": [
            2954.0,
            2983.0,
            73
        ],
        "ordering right now is the opposite true. If there is a good ordering. Does that mean or not? Let's do it this way. If there's not a cycle does that mean that there is a good ordering? If there is not a cycle. Is there a good ordering? What was the question? Not necessarily you could maybe be taking CSE classes and then you can be taking dance classes and ": [
            2771.0,
            2821.4,
            69
        ],
        "position if if the edge goes from a higher position to a lower position then you know, it's not a topological ordering. D after e is that I know it's only the edges. It's only Edge directions that that disqualify it. Okay. now given a graph produce a topological ordering at which vertex. Do you guys want to start at? You can start at any vertex. You must start at ": [
            3153.1,
            3227.9,
            77
        ],
        "prove it. So we have to sit at the if and only if proof we have to do both directions. Okay. So the the forward Direction assume G is a dag show that g - V is also attack. And then the opposite direction we're going to do the contrapositive and show that assume G is not a dag show that Jiva - V is also not attack. Okay, let's ": [
            3491.4,
            3522.6,
            86
        ],
        "right now? How long does it take to search for an element in a sorted list? login, right So we've done a lot better there now. How long does it take to insert something? Well, we want to maintain the sorted nature of this array. So in order to insert something you have to find out where it's supposed to go, right? I think also login but then you have ": [
            1650.8,
            1686.5,
            41
        ],
        "right? So this algorithm will detect if the graph is a dag and if it is it will give you this topological sort. So let's think about how we're going to implement this. What kind of data do I need? What kind of information do I need about the vertices in order to show in order to detect? Which avertx which vertices are sources? Without degrees, right? so we can ": [
            3645.3,
            3680.8,
            90
        ],
        "root. It has two children and from those children you hang the Trees of T of n -1. So this will be T of 0. Tiawan is just a root vertex and its two children are the roots of ta0. But T of zero is just a test. TF2 right you start with the root vertex. It has two children. Each one of its children is T of one. So ": [
            1249.7,
            1282.8,
            31
        ],
        "rooted tree have? Good. Oh you you can use the we can use the example as a as a clue right this one two, three, four five. five vertices and for edges and -1 just like a unrooted Tree in fact rooted trees and unrooted trees. They have like similar structures. If you take a rooted tree and you delete all the arrowheads you get an unrooted tree. Another way ": [
            483.2,
            530.9,
            13
        ],
        "rooted trees have a lot more structure and have a lot more vocab. Okay. So a rooted tree is a connected directed acyclic graph in which one vertex has been designated the route which has no incoming edges and every other vertex has exactly one incoming Edge. Okay, so How many edges does a rooted tree have white where's my clicker thing? Here we go. How many edges does a ": [
            439.2,
            483.2,
            12
        ],
        "same structure and that's what makes a binary search tree. So efficient is because in order to search all you have to do is figure out which direction to go at each vertex along the Okay, if I wanted to search for 17, maybe I want to say is 17 already in my data structure. How would you do it you go into here. And then which way do you ": [
            1915.5,
            1942.9,
            49
        ],
        "so we got trees up in the top left corner. We have a binary tree. It's the numbers are arranged in a special way. Does anybody know what type of binary tree this is? It's not a binary search tree know. It's a what a Max Heap. Okay. This is like a tree to map out how a certain otamatone would process an input. this one over here is a ": [
            79.0,
            129.4,
            2
        ],
        "takes is proportional to the height of the tree. How about if I wanted to insert something something that's not in there. Where would you put it? Let's say I already know that 32 is not in my data, but I wanted to put in a add it into the tree. Where is a good place to put it? the child of okay. Which child of 50? Yeah, if so ": [
            1970.6,
            2017.2,
            51
        ],
        "taking away. Okay good. Now, let's do the other one. Let's suppose G is not a dag. What does that mean about G? Has a cycle. Okay now remove a source from G. Could that Source be part of that cycle know there's no way right because every vertex in that cycle must have an incoming Edge when you remove that Source, you haven't touched the cycle at all and ": [
            3549.9,
            3588.4,
            88
        ],
        "that might cause some problems cuz you don't know the subtree. Right, cuz if you put if you put 36 as the right child of 32, then you have 30 in there right in that kind of causes problems. So the best place to put it is at the bottom so that it doesn't interfere with anybody else and how do you find it? You just pretend like you're searching ": [
            2017.2,
            2042.5,
            52
        ],
        "that. You're going to keep on gaining one more connected component as you go, right you start off with one at the end. You have an are you have just dumped so how many steps does it take to get from 1 to n + -1 Okay, so we're not going to do so much with unrooted trees. So in computer science, you mostly deal with rooted trees and so ": [
            412.2,
            439.2,
            11
        ],
        "the dad has no Source than every vertex keeps on having an incoming it. Okay do this and make a list of the vertices that you get and make a list of n + 1 vertices v1vn + 1 okay by the pigeonhole principle. One of these vertices has to be a repeat cuz there's and vertices and there's n n + 1. Kind of pigeon holes or slots for ": [
            3392.6,
            3427.2,
            83
        ],
        "the maximum that you can have is eight leaves right? And that would be if every if the whole bottom layer was built. Okay, I'll full binary tree is a rooted tree where every internal vertex has exactly two children part. You should be more and one the about because I'm writing it in maybe you guys are. putting that one Okay good. So which ones are full binary tree's? ": [
            897.3,
            941.5,
            23
        ],
        "the result is still not a dag. Okay, any questions about that? You might create some. Yeah, yeah. exactly Okay. Now let's get to this algorithm. Here's the idea. Build this while loop while G has at least one vertex. If she has a source. Then choose it and output it and then remove it, right. If it doesn't have a source then it wasn't a dag to begin with ": [
            3588.4,
            3645.3,
            89
        ],
        "the vertex. So one of those vertices must be repeated, which means that you have a cycle cuz remember what a cycle is. It's a list of or it's a sequence of vertices that starts and ends with the same vertex. and then that contradicts the fact that it's basically Okay, good. So Moving towards an algorithm to sort a dag topological sort of dag. Let's think about some notation. ": [
            3427.2,
            3459.6,
            84
        ],
        "the vertices. Is it a topological ordering. How would you do this? First of what? where to start where Like I'm giving you a list. So let me say I give you this list is a b c d e f g h i and I ask you is this a topological ordering of this graph? Just doesn't have a root. What what what makes it fail? Why is this ": [
            3023.5,
            3094.0,
            75
        ],
        "then you take 105 and then you take 30 with me 1:30. Come on. Okay. So we can start calling these like good ordering Zorro K ordering. We're going to come up with like another word for them in a minute. But let's just think about them as valid ordering things or something like that. Okay, so What what would be a way to take all the classes? What if ": [
            2457.9,
            2490.8,
            62
        ],
        "there in a binary tree of height h Okay good. Trinidad right Or to the H sorry. And why is that? Well, here's the key Insight the number of vertices doubles at each level at least level right? So you have this nice geometric sequence everybody. Remember this 1 + 2 + 4 + 8 all the way up to plus to the H is equal to 2 to the ": [
            1048.8,
            1096.1,
            26
        ],
        "they might not have any prerequisites from one to the other. What is your best solution? Maybe that's not a good ordering but it would still be like a legal ordering right as long as you didn't run into this problem where a certain class was dependent on another one and another one that kind of LED back to the same class. That kind of makes sense. So, what do ": [
            2821.4,
            2872.7,
            70
        ],
        "this graph have? Fort Wright So we're going to use this same terminology when we talked about rooted trees. Okay, if a tree has n vertices how many edges must it have? And -1 always every tree with n vertices always has and -1 edges. A set of trees is called a does anybody know? Forest okay, how many distinct points are there between each pair of nodes in a ": [
            297.4,
            345.7,
            8
        ],
        "to shift everybody over. Let's say big or then. Because once you find it, then you have to kind of make the array bigger. Okay, how long does it take to remove something? Also Big O of n for sort of the same reason, right? So let's take a look at what we have we have that the sorted array is better at searching but the regular rate is better ": [
            1686.5,
            1712.4,
            42
        ],
        "to think about it is every vertex has exactly one incoming Edge except for the root. Therefore. There must be one vertex per non root vertex, which is in -1. Okay good so you can think about a rooted Tree in layers. Okay. So the root is at the top layer and usually we call this layer 0. And then the next layer would be one two and three. Okay, ": [
            530.9,
            570.3,
            14
        ],
        "tree is an undirected tree. The basic definition is that it's connected and it has no Cycles. That's it. connected undirected graph with no Cycles Okay. So these are all trees. These are all on rooted trees. Okay now. Let's fill in a few gaps for the for these facts facts and definitions about trees leaf. Leaves are vertices of degree. What? 1 alright, okay. So how many leaves does ": [
            256.1,
            297.4,
            7
        ],
        "tree? One right. That's that's one of the properties of a tree what would happen if there were two distinct paths? You would have created a cycle right because you got to go around One path or around the other one. You can just kind of go around like that. Each Edge in a tree is considered a vocab word that we learned last time. Bridge that's what I was ": [
            345.7,
            382.7,
            9
        ],
        "two incoming edges what's wrong with B to incoming edges and these ones don't have any edges in coming every vertex has to have exactly one in coming in. Okay, so Rooted trees have a route we talked about and then they have the same kind of meaning for leaf. As you have in a undirected tree, which is a leaf is basically any vertex that doesn't have any outgoing ": [
            623.1,
            655.1,
            16
        ],
        "up in a slightly different way. Both classes will be podcast in so you all can access all of his content and the other class can access all of my content and so Are there any questions? Okay, let's let's finish up what we want to talk about with grass. We're going to look at two special types of graphs today. Dags and trees plus start with trees. Okay. Alright, ": [
            40.6,
            79.0,
            1
        ],
        "vertices than the minimum height that I can have is Big Theta of log event. Okay, cool, so basically A tree of height H. The minimum height of can have is love and + 1 - 1 what's the maximum maximum number of vertices second half Maximum number of vertices I can have is login + 1 - 1 what's the minimum number of vertices that can have? or if ": [
            1127.6,
            1179.1,
            28
        ],
        "what does tf3 look like? You have that. Has two children and each one of these children is TF2. see Okay. So as you build the tree the number of edges grow the number of vertices grows a number of leaves grow and you can you can keep track of them using recursion for the number of vertices with v of 0 is equal to 1. K in order to ": [
            1282.8,
            1335.4,
            32
        ],
        "you guys all agree. Okay, so the next thing is to figure out well. If it starts in the source than a dag should have a source right and so we're going to prove that every dag has a source. Or has at least one source. Okay, and he was sort of the idea of the proof is you started any random vertex and ask if it's a store if ": [
            3302.7,
            3334.0,
            80
        ],
        "you guys think? Is the converse true? Yeah, it's really the only way that you're going to break this ordering is if you have a cycle, okay? Okay question. Has unique pre represent like what's a 15 L take CSE 5 and 12 takes? 880 Write that in. But you just do one thing. Yeah, just put one thing there. I think I don't know how that's why I would ": [
            2872.7,
            2922.3,
            71
        ],
        "you're just looking at it upside down. Okay good. So this is Dee Wright any questions about that? We have Titan 0 1 2 and 3. Okay good. Okay, so that's a height of a Vertex the height of the tree is the maximum height of all the vertices in the tree. So the height of this tree here is three. height equal to 3 Okay. Now a binary tree ": [
            802.5,
            842.9,
            21
        ]
    },
    "File Name": "Mathematics for Algorithms and Systems - B00 - Jones, Miles E - Winter 2019-lecture_17.flac",
    "Full Transcript": "Listen to a podcast.  So let's get started.  Let's see today is like the last day of new material on Wednesday. I'm going to do some review and Andrew and I are going to kind of do like a two-part review for Wednesday and Thursday during class. And so I'll be doing like the first half of class and he'll do the second half sort of we might split it up in a slightly different way. Both classes will be podcast in so you all can access all of his content and the other class can access all of my content and so  Are there any questions?  Okay, let's let's finish up what we want to talk about with grass. We're going to look at two special types of graphs today.  Dags and trees plus start with trees. Okay. Alright, so we got trees up in the top left corner. We have a binary tree.  It's the numbers are arranged in a special way. Does anybody know what type of binary tree this is?  It's not a binary search tree know. It's a what a Max Heap.  Okay.  This is like a tree to map out how a certain otamatone would process an input.  this one over here is a  kind of like a game tree right decision tree based on tic-tac-toe.  And the idea is that you look at all the possibilities and you score each one of them, right and then you know, if you're trying to win then you go for the maximum score. That's kind of how  Some chess engines operate like some very simple ones, you know, you you look at all the possible moves II moves and you score them all and you take the one with the max score or the one that kind of changes your score the most.  This is like a parsing.  Tree. So this is what your parser does when you give it some code. It will break up that the sequence of characters and put them into different categories and  Basically to make sense of the syntax, right?  They have these the same exact kind of trees in linguistics. My dad was a linguist. So he would always be drawing. All this stuff is the same thing, you know, but instead of like, you know the for Loop and all that kind of stuff it was the noun phrase and verb phrase and all this kind of thing.  Okay, this is a what?  taxonomic all tree of the family know the order of mammals called Carnivora and so you have like the the cat's the dogs and then like the  Badgers and otters and stuff  Okay, so you can see trees are everywhere not only in computer science, but all over the place.  They come up in Mass a lot to a kind of like a math topic. So we're going to start with undirected trees. So unrooted tree is an undirected tree. The basic definition is that it's connected and it has no Cycles. That's it.  connected undirected graph with no Cycles  Okay. So these are all trees. These are all on rooted trees.  Okay now.  Let's fill in a few gaps for the for these facts facts and definitions about trees leaf.  Leaves are vertices of degree. What?  1  alright, okay. So how many leaves does this graph have?  Fort Wright  So we're going to use this same terminology when we talked about rooted trees. Okay, if a tree has n vertices how many edges must it have?  And -1 always every tree with n vertices always has and -1 edges.  A set of trees is called a does anybody know?  Forest  okay, how many distinct points are there between each pair of nodes in a tree?  One right. That's that's one of the properties of a tree what would happen if there were two distinct paths?  You would have created a cycle right because you got to go around One path or around the other one. You can just kind of go around like that.  Each Edge in a tree is considered a vocab word that we learned last time.  Bridge that's what I was looking for.  Right because if you take away at an edge in the tree than the then you get to disconnected.  Two connected components. This is one way that you can convince yourself that there are and -1 edges right when you take away and Edge you get to Connected components. Will you take away another Edge you get another connected component if you keep on taking away edges like that. You're going to keep on gaining one more connected component as you go, right you start off with one at the end. You have an are you have just dumped so how many steps does it take to get from 1 to n + -1  Okay, so we're not going to do so much with unrooted trees. So  in computer science, you mostly deal with rooted trees and so rooted trees have a lot more structure and have a lot more vocab.  Okay. So a rooted tree is a connected directed acyclic graph in which one vertex has been designated the route which has no incoming edges and every other vertex has exactly one incoming Edge.  Okay, so  How many edges does a rooted tree have white where's my clicker thing?  Here we go.  How many edges does a rooted tree have?  Good.  Oh you you can use the we can use the example as a as a clue right this one two, three, four five.  five vertices  and for edges  and -1 just like a unrooted Tree in fact rooted trees and unrooted trees. They have like similar structures. If you take a rooted tree and you delete all the arrowheads you get an unrooted tree.  Another way to think about it is every vertex has exactly one incoming Edge except for the root. Therefore. There must be one vertex per non root vertex, which is in -1.  Okay good so you can think about a rooted Tree in layers. Okay. So the root is at the top layer and usually we call this layer 0.  And then the next layer would be one two and three.  Okay, I'll special case of dags. I didn't mean from last class from later later on.  Okay, so let's let's look at some examples which of the following directed graphs are trees with root indicated in green.  Are rooted trees.  Okay. Good only see right what's wrong with a  Write this one has two incoming edges. What's wrong with d?  That is a consequence but really it's because this one has two incoming edges what's wrong with B to incoming edges and these ones don't have any edges in coming every vertex has to have exactly one in coming in.  Okay, so  Rooted trees have a route we talked about and then they have the same kind of meaning for leaf. As you have in a undirected tree, which is a leaf is basically any vertex that doesn't have any outgoing edges.  with out degree  equal to zero  Okay, so here's so I love these tree definitions cuz they're all kind of cute they all have like root and leaf and stuff. So we talk about a tree but you can also think about him as in a family tree. So the route is sort of like the the beginning of the family.  And the vertices directly connected to the root or the children of the route and then you have the grandchildren and in general.  Everything in the tree is a descendant of the root.  Okay, so these are all descendants.  Just like in a family tree and everything kind of higher in the tree than a certain vertex. It would be its ancestor, right if there's a direct line backup.  Okay, so if a Vertex is not the root egg has exactly one incoming Edge and you call that it's parent.  and so think about these roots as like  What do you call an animal? That doesn't?  reproduce that reproduces by only with one individual  asexual think about these and asexual organisms, which means that you don't have to parents right? You can only have one parent.  Okay height of a Vertex is given by this recurrence.  the height of the is equal to the height of its parent plus one that's like because of this plus that edge and the start of the recurrence is that the height of the root is 0  Okay, what is the height of this red vertex?  I know it's kind of messed up and upside down but you can maybe think of the root as like the root of the tree and you're just looking at it upside down.  Okay good. So this is  Dee Wright  any questions about that?  We have Titan 0 1 2 and 3.  Okay good.  Okay, so that's a height of a Vertex the height of the tree is the maximum height of all the vertices in the tree. So the height of this tree here is three.  height  equal to 3  Okay. Now a binary tree is a tree is a rooted tree where every internal vertex has no more than two children.  How many leaves does a binary tree of height 3 have?  Now, it's just you guys are too quick. It was supposed to be like a trick question.  All right. Let's just forget about that.  all of the above  right here is a tree of height 3012.  3  with two leaves, right?  But the maximum that you can have is eight leaves right? And that would be if every if the whole bottom layer was built.  Okay, I'll full binary tree is a rooted tree where every internal vertex has exactly two children part. You should be  more  and one  the about  because I'm writing it in maybe you guys are.  putting that one  Okay good.  So which ones are full binary tree's?  D4 sure, how about sea?  How about be?  Yes.  Yes.  how about a  No.  OK every in every internal vertex has exactly two children. So every internal vertex is a vertex that's not a leaf. Every nanoleaf vertex has exactly two children. So this would also be a full binary tree.  You call it like a full binary tree.  I would call it a a  I'll call it a complete binary tree.  maybe a complete balanced binary tree  Maybe that's not even good enough. I'll complete at a complete binary tree with the bottom level filled.  binary  tree  with all  yeah with all leaves on the same level.  Cuz complete just means that every level is filled except for maybe the last so I complete the tree with the last level field.  Okay, so  at most how many vertices are there in a binary tree of height h  Okay good.  Trinidad right  Or to the H sorry.  And why is that? Well, here's the key Insight the number of vertices doubles at each level at least level right? So you have this nice geometric sequence everybody. Remember this 1 + 2 + 4 + 8 all the way up to plus to the H is equal to 2 to the H + 1 - 1  queso a tree of height H. This is the maximum number of vertices that it can have any questions about that.  This is when it's complete and the the bottom layer layer is built.  Okay, so you can kind of solve for H here and get that.  H is equal to log of n + 1 - 1  so if n is the number of vertices than the minimum height that I can have is Big Theta of log event.  Okay, cool, so  basically  A tree of height H. The minimum height of can have is love and + 1 - 1 what's the maximum maximum number of vertices second half  Maximum number of vertices I can have is login + 1 - 1 what's the minimum number of vertices that can have?  or if let's start at let's say like this if if a tree has n vertices, what's the maximum height I can have  what if you just had like a  And might as well if it's just a along string.  Okay, so we know that the height is got to be in between those two numbers find the maximum minimum.  any questions  alright trees are very nice because often times you can describe them with this recursive description. Okay. So for example, if I told you that a particular family of trees T of n t of zero is just a single root and T of n is the tree sets that the root Vortex has two children and each child is the root of T of N - 1  Okay, so it's kind of like you start with a with a root. It has two children and from those children you hang the Trees of T of n -1. So this will be T of 0.  Tiawan is just a root vertex and its two children are the roots of ta0. But T of zero is just a test.  TF2 right you start with the root vertex. It has two children. Each one of its children is T of one.  So what does tf3 look like?  You have that.  Has two children and each one of these children is TF2.  see  Okay. So as you build the tree the number of edges grow the number of vertices grows a number of leaves grow and you can you can keep track of them using recursion for the number of vertices with v of 0 is equal to 1.  K in order to answer this think about what you're doing you're taking two copies of t + -1 and then what are you doing?  Adding the route also.  so via vallen is going to be  2 * V event - 1 write two copies of the tree with n minus the T of N - 1 tree and then plus one because of the root any questions about that.  Atlas look at another example.  Now I'm going to say let T of zero just be the single vertex Define t of n to be.  A tree such that the roofer text has two children. The left child is a single vertex and the right child is the root of T of N - 1  so you can see we have here we have ta0.  Tf1 TF2 and what is T of 3 look like?  Well, you have a route from the left child. You just hang a single vertex. And from the right child you hang TF2 which looks like this.  So, how did how did the number of leaves grow?  On the right child, you have all the leaves from that tree, right wanted to leave. It's always a leaf so it doesn't change right then.  You're adding the route, which is not going to be a leaf and the left child which is a leaf. So basically you're taking all the leaves from T of n -1 and you're adding one more.  Any questions about that?  Alright, let's move on.  So we looked at definition of trees properties of trees how to build trees by know. What this is. This is a Max Heap.  Just do that. Okay. So let's look at binary search trees. What is it?  And data structures a binary search tree is a data structure that facilitates efficient search and its Dynamic which means well it sufficiently Dynamic which means that you can add to it and take it away also efficiently. Let's compare it to some other types of data structures that can do the same thing. Okay, let's start with  Let's just think about what do we want to do? We're collecting data. Let's say we want to store it in a modifiable can collection you want to be able to search in your data for certain targets you want to be able to insert data into it and delete data from it.  okay, the first maybe idea that you could come up with is just start with an array of integers that has sort of a  Doesn't really have an end right you can kind of keep on making the end bigger.  Okay. So let's say that there are an element's or on the order of n elements in order to search for an element. It's going to take Big O of n time, right?  Cuz you're going to have to just look through it all it's not in any way sordid.  Okay, how how long does it take to insert something?  old one, right  01 and to remove  Well, you kind of have to find it and then when you remove it, you would have to shift everybody over. This is also Big O of n  prank  What's a sure?  to insert  What's a we know?  right  Okay, how about if this array was sorted and so you want to keep it sorted right now? How long does it take to search for an element in a sorted list?  login, right  So we've done a lot better there now. How long does it take to insert something?  Well, we want to maintain the sorted nature of this array. So in order to insert something you have to find out where it's supposed to go, right?  I think also login but then you have to shift everybody over. Let's say big or then.  Because once you find it, then you have to kind of make the array bigger.  Okay, how long does it take to remove something? Also Big O of n for sort of the same reason, right?  So let's take a look at what we have we have that the sorted array is better at searching but the regular rate is better at it starting right and you know, they kind of have their they're both the same at removing so one's kind of better at the other in certain things. So the next thing we're going to look at it as a binary search tree and it's going to be in general better than all of them both of these in every way. So let's see kind of briefly what that looks like.  So we're going to use this recursive definition of the binary tree in order to facilitate this binary search tree. So you have the root, right and every node in the left subtree of the route is going to be smaller value than the route and everything in the right subtree is going to have bigger value.  Sure.  I think it doesn't matter but let's just assume that all the values are unique and then we can.  Yeah, it doesn't change much if if you have repeated values.  Okay. So now how does that how is this going to work?  well  How are we going to store this because storing an array is really easy right now. It's just a a built-in data structure. How do you store a binary search tree? Each vertex is going to basically be its own object with four Fields, right? It's going to have a parent field left child field right child field in a value. So what is it mean if pee is no, what does that mean about a node if it's P value is no  Okay good.  It means that its parent is empty parent field is empty, which means it has no parent.  How sad?  But there's only one vertex out there. That doesn't have a parent. It's the root node. Okay. Good next one.  What happens when the left child is now in the right child is no, what does that mean?  Okay, good guys are catching on  means it is a note. Okay good.  So it's really fast to kind of check to see what type of note it is just by looking at those.  Okay, let's look at an example.  Here's an example and let's say that the date of that were trying to store are integers, right? So if you kind of take a look, our route is 28 take a look at its left subtree. All of the values are less than 28 and it's right subtree. All the values are bigger than 28 and each subtree of each other vertex has that same structure and that's what makes a binary search tree. So efficient is because in order to search all you have to do is figure out which direction to go at each vertex along the  Okay, if I wanted to search for 17, maybe I want to say is 17 already in my data structure. How would you do it you go into here. And then which way do you go?  To the left. Okay, then which way to the right and then to the left 2117 is less than 21 so you go to over to the left also so you can do that for any number and it will tell you whether or not it's in there.  Okay notice that we didn't have to go through the in any of the other half. So the the time it takes is proportional to the height of the tree.  How about if I wanted to insert something something that's not in there. Where would you put it?  Let's say I already know that 32 is not in my data, but I wanted to put in a add it into the tree. Where is a good place to put it?  the child of  okay.  Which child of 50?  Yeah, if so that might cause some problems cuz you don't know the subtree.  Right, cuz if you put if you put 36 as the right child of 32, then you have 30 in there right in that kind of causes problems. So the best place to put it is at the bottom so that it doesn't interfere with anybody else and how do you find it? You just pretend like you're searching for it. So you going here it's bigger than 2850. It's smaller than 50 go to 36. It's smaller than 36 go to 30. It's bigger than 33 doesn't have any children. So put it there.  how to make sense this is also proportional to the height  Okay, last one. How do you remove something? What if I ever wanted to remove 21?  You have to search for it.  Someone like you remove 17 ads remove 17.  Start somewhere with 24th or somewhere remove 21.7 + 24.  Yeah, that would work.  I mean in this particular example.  You could do that. What if 17 had its own tree hanging down from it?  Yeah, maybe you could recursively do it because you want it to be quick to write you wanted to be I'm thinking that the height of the tree is a good amount of time. Right? It's a very efficient amount because you're not going through every single note.  All right, let's we'll talk about that in a minute.  Okay, so here is just like a few algorithms. We're not going to spend a lot of time on it. I just wanted to kind of prison it for completeness. So then to search something you compare to the root if it's bigger you go one-way with smaller go the other way and then you just recurse on those just like when we defined the Peachtree recursively remember we said the route has children and each child is the root of their own subtree. You just kind of deal with it that way.  Okay, so that search. How about insert?  We saw kind of how that works you basically search for it. And then whenever you find a null value you put it in there if you stick it in there.  Okay, here's kind of an idea of how to remove.  So you search for the value then you restructure the tree case one the target is a leaf. You just basically remove it and everybody's okay.  Case to the Target only has one child.  And what are you do?  Yeah, you just basically.  Go like that.  No problem.  Okay, how about here?  His own brother has a child.  Yeah.  I think you just recursively go down right that was the best thing to do.  that is  That is on the 11th Street of the right side of the know your bathroom.  Yeah, I think you just kind of.  What's the best way to do it?  And I'll leave this guy this as an exercise for you guys.  Okay, so  Binary search tree. I put big old login. It's really big O of the height.  This is kind of like the best case.  But you might be unlucky and as you build your search tree, it could kind of like build in like a long line and there are ways around that there are ways to make sure that doesn't happen. I think you learn some of them in 30.  Well, you guys have done this already.  dinosaur  Alright, let's move on.  next type of graph  gag  So basically a dag you can think of as like a curriculum of a university where certain classes are prerequisites of other classes. So if I take course as a prerequisite for corned beef that means you can't take be unless you take a first okay, so  Which of the following orderings are okay with meaning?  I have  Master the prerequisite before I take the next class.  Okay, let's see.  Okay, we're saying see let's look at them. What's wrong with a  you took 100 after 151. What's wrong with B?  You put 21 after 1:05. It's going to be hard.  How about c c is okay, right you first you take 21 then you take 105 and then you take 30 with me 1:30.  Come on.  Okay.  So we can start calling these like good ordering Zorro K ordering. We're going to come up with like another word for them in a minute. But let's just think about them as valid ordering things or something like that. Okay, so  What what would be a way to take all the classes? What if I wanted to include all the vertices? Is it possible? Is it possible for this graph?  Is there a way to take all the classes?  Yeah, right. I mean some of you have already have are already on your way of doing it right or have it planned out.  Are these required classes for everybody?  some of them  Okay, so then the question is is this possible for any graph?  Let's take a look.  what we want to do now is  ask try to ask this question about all grass. Is it possible to have a good ordering which which kind of graph is it possible for? And which is there a simple rule that can tell you if I can make a good ordering?  Okay, let's look at these three which of the following graphs. Have a good ordering.  All right.  Okay.  None of the above, huh?  More than the about more than one.  Which ones?  A&B  A&D  okay.  Okay, let's let's name these and you tell me what you're ordering is.  What's a good ordering here?  All right, I think that's fine, right?  What's one way to tell that?  What was it a VDC and be right that it's a good ordering is if you redraw your graph in that order, all the edges are going in One Direction, right? So Eggos to be that's fine. Sea goes to be  Digos to see that's fine. He goes to D and E goes to be  Okay, so this is a good at ordering any questions about that.  Okay. Hey works too, right?  You could do it for that. Maybe you guys can figure that out as an exercise.  Okay.  next thing  what are the barriers to ordering?  What kind of prevented you from ordering on B&D?  Whenever there's a cycle, you can't have an ordering, right?  You can kind of think about it in this sort of circular way, right?  So, let's I want to take class A. Well, I need to I need to take be before I take class A Class B, but in order to take class B. I need to take class C in order to take class C. I need to take class D. Okay, that's fine. I'll take class D to take class D. I needed to take class A that's fine. I'll take class A.  If you think long enough you're going to keep on going around in circles. Okay, so basically if there's a cycle then you can't find a good ordering right now is the opposite true.  If there is a good ordering.  Does that mean or not? Let's do it this way. If there's not a cycle does that mean that there is a good ordering?  If there is not a cycle.  Is there a good ordering?  What was the question?  Not necessarily you could maybe be taking CSE classes and then you can be taking dance classes and they might not have any prerequisites from one to the other.  What is your best solution?  Maybe that's not a good ordering but it would still be like a legal ordering right as long as you didn't run into this problem where a certain class was dependent on another one and another one that kind of LED back to the same class. That kind of makes sense.  So, what do you guys think?  Is the converse true?  Yeah, it's really the only way that you're going to break this ordering is if you have a cycle, okay?  Okay question.  Has unique pre represent like what's a 15 L take CSE 5 and 12 takes?  880  Write that in.  But you just do one thing. Yeah, just put one thing there.  I think I don't know how that's why I would do it. Let's just pretend this is a world with no co-requisite.  Okay.  So thick to classify the all the grass that have good orderings. They're basically all the directed graphs with no Cycles. These are called directed acyclic graphs. Here's one.  You can't find a cycle in there and the consequences that every directed acyclic graph has a good ordering. It doesn't necessarily mean that there's a unique good ordering but it definitely has one.  Okay. Now let's stop talking about good orderings. It's actually called a topological ordering.  It's a order list of all of its vertices such that for each directed Edge VW in the graph V comes before W in the list that was kind of like what I was saying before we're if you draw in all the arrows, they're always going to go from left to right.  Talk to algorithmic questions one is given a order list. Is it a topological ordering? How would you how would you verify it to given a graph produce a topological ordering if one exists or in other words figure out if it's a dag if it is a dag then find a ordering.  Okay, so let's start with the first question.  Given the order list of all the vertices. Is it a topological ordering. How would you do this?  First of what?  where to start where  Like I'm giving you a list. So let me say I give you this list is a b c d e f g h i and I ask you is this a topological ordering of this graph?  Just doesn't have a root.  What what what makes it fail? Why is this not a topological ordering?  Because there's a arrow from what?  gc2b  Sorry.  What you say G to E.  Yes.  So what do you want to do? How do you prove that? It's a topological ordering Loop through all the edges and check.  Do the endpoints come in order? Maybe what you could do is give each vertex a position in the list.  1 2  Right, and then if if that position if if the edge goes from a higher position to a lower position then you know, it's not a topological ordering.  D after e  is that  I know it's only the edges. It's only Edge directions that that disqualify it.  Okay.  now  given a graph produce a topological ordering at which vertex. Do you guys want to start at?  You can start at any vertex. You must start at a  You choose a Vertex with at least one outgoing Edge or you choose a Vertex with no incoming edges.  Okay, good D through the vortex with no incoming edges.  Okay, so that has a special name. It's called a source. So.  A Vertex with no incoming edges is called a source which of the vertices are sources.  Okay, good. Yeah, that was an easy one. Okay, that's fine. Only Ang Ang are the only sources?  Okay vertices with no outgoing edges are called sinks. So F and I are sinks.  Okay, good thing else is just do whatever so if Dad can have more than one source, I can have more than one sink, but it's got to the top of logical ordering has got to start in a source and it's got to end in the sink right you guys all agree.  Okay, so the next thing is to figure out well.  If it starts in the source than a dag should have a source right and so we're going to prove that every dag has a source.  Or has at least one source. Okay, and he was sort of the idea of the proof is you started any random vertex and ask if it's a store if it's not a source then look at its incoming Edge, right?  And keep on going until you find the source. Why am I always guaranteed to find a source?  There's no cycles and it's finite right? So at some point you're going to have to get to the get to the end.  Que NADA Source keep on going look at found the source. Okay, and then you're done.  Okay, so let's let's think about it in a more mathematical way of proving it.  So assume toward the contradiction that the gag has no Source at all. That means that every vertex has at least one incoming Edge, right? So do the same thing and start with any random vertex and start looking at its incoming edges and keep on going you can you can go on forever right? Because if the dad has no Source than every vertex keeps on having an incoming it. Okay do this and make a list of the vertices that you get  and make a list of n + 1 vertices v1vn + 1  okay by the pigeonhole principle.  One of these vertices has to be a repeat cuz there's and vertices and there's n n + 1.  Kind of pigeon holes or slots for the vertex. So one of those vertices must be repeated, which means that you have a cycle cuz remember what a cycle is. It's a list of or it's a sequence of vertices that starts and ends with the same vertex.  and then that contradicts the fact that it's basically  Okay, good. So  Moving towards an algorithm to sort a dag topological sort of dag. Let's think about some notation. Let's say g - V is the graph that results when we were a movie and all of its outgoing edges from G. Okay, so he's kind of like  take the vertex away and everything that I had to do with the graph.  Okay now.  Let's think about what happens when you take a source away from a dag.  The result is still a dag.  You guys believe that?  Let's prove it.  So we have to sit at the if and only if proof we have to do both directions.  Okay. So the the forward Direction assume G is a dag show that g - V is also attack.  And then the opposite direction we're going to do the contrapositive and show that assume G is not a dag show that Jiva - V is also not attack. Okay, let's do this one first.  Well, we're just going to do kind of like an informal sort of proof here. The idea is you start off with a graph a directed graph with no Cycles. If you take away of vertex, there's no way that you could have created a psycho by doing that right because you're not adding in any edges. You're not adding any vertices. All you're doing is taking away.  Okay good.  Now, let's do the other one.  Let's suppose G is not a dag. What does that mean about G?  Has a cycle.  Okay now remove a source from G.  Could that Source be part of that cycle know there's no way right because every vertex in that cycle must have an incoming Edge when you remove that Source, you haven't touched the cycle at all and the result is still not a dag.  Okay, any questions about that?  You might create some.  Yeah, yeah.  exactly  Okay. Now let's get to this algorithm.  Here's the idea.  Build this while loop while G has at least one vertex.  If she has a source.  Then choose it and output it and then remove it, right.  If it doesn't have a source then it wasn't a dag to begin with right? So this algorithm will detect if the graph is a dag and if it is it will give you this topological sort.  So let's think about how we're going to implement this.  What kind of data do I need? What kind of information do I need about the vertices in order to show in order to detect?  Which avertx which vertices are sources?  Without degrees, right?  so we can keep a  noise in degrees, right?  Yeah, the end agree to terms if it's a source so we can keep an integer array in degree. And so the first thing you do is you can run Graph Search on it and fill this up right for every vertex. Look at all the in incoming edges and count them up that's going to be the in degree.  And then as you go through you kind of output these sources one by one and keep them in some sort of stack or queue.  stupid  so this is sort of like them.  the summary of the  the algorithm  that has to do with the array. Okay. So first choose some X for each why that's adjacent to it first to some source for each why that's adjacent to it decrement the in degree of each one of those neighbors, right?  And if any one of those neighbors falls down to zero then add it to your list of sources.  All right, let's look at how this works on this graph here taking the liberty of  populating this in degree array  And since my two sources are A & G I put them in ass. So then this is where we start the algorithm.  Okay, so the first thing I do.  is  Consider a right that's this part choose some vertex in ass.  Then look at all of the vertices adjacent to it. Okay, so we have B we have C and we have he so decrement each one of those be goes down to zero and never goes down to zero throw it into your set of sources.  Sea goes down to zero.  Annie goes down to one.  Okay, so we just did this whole thing for a  and then the resulting graph we have is now this with a removed and all of the other edges removed.  Okay, so let's just kind of go through this quickly the next vertex to remove. Well, let's say that this was a q. So we're moving the  First one is going to be the first one out, right?  That's how a key works.  Make the first one key was going to be the first one in.  Is going to be the first one out.  like you  first in first out  Okay. Okay. So next one. We're going to take his gk3 take G and we decrement its neighbors, which is he and H.  That goes down to zero gauge goes down to one so you get added to the queue and this is the resulting graph.  and so noticed that every time we do this this set s is our set of  sources. The next one is BB only has one neighbor. So take get rid of him decrement D. And as I'm doing this I'm out putting this list as I go. I can't keep on going with c and then he and then D and then H and then and then I  And this is going to be a topological sort.  How long does a sack?  guess that's  maybe we'll end a little early today. Okay. So this is kind of like the completion of all the material and on Wednesday. We're going to do some more stuff for the review.  Can you see San Diego podcast? "
}