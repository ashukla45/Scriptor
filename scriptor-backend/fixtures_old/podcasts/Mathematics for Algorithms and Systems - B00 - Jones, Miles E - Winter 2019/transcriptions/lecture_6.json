{
    "Blurbs": {
        "12 for 1617 1324 2023 and then you look at 17 and 13 and you swap those as you go along? Okay, so you do that all the way through. The next time you do it you do it again, but you only go to the second to last place, right? And then the third to last fourth the last and then you keep on doing that over and over ": [
            2635.2,
            2664.9,
            52
        ],
        "And then you have 17 so that goes in between 13 and 19. So you put it in there. And you have three? Oh, I've missed the sex. Sorry 16 1317 I missed it. And then this the 16 again that was from the other example. You guys get the idea? Okay, so then you're done great easy. Getting this is nice because as you're doing it, these elements are ": [
            3039.0,
            3090.6,
            64
        ],
        "C are what? So B&B is really what we're seeing here, huh? Okay. So what you saying be was like the main one that wasn't the so let's start with that one is be sorted. In what order? Okay, how about sea? descending order how about a alphabetical write 42 starts with a f pain starts with a t All depends on which way you want to order them. Maybe ": [
            462.4,
            522.1,
            10
        ],
        "Can I have your attention? so Before we begin here's a few things to know about the exam. First of all, it's tomorrow. It's tomorrow night. We're going to be across this Hall in Center 119. And the other class are going to be here in this room, but did you guys see the seating chart yet? Delete an uploaded yet. Oh and our thing. Yeah, we should upload it ": [
            1.9,
            47.5,
            0
        ],
        "I guess it is because it's true after every iteration and that would be helpful when we start talking about run time. You mean the algorithm stops after Anna durations? Actually, that's that's good. That's important. I'm going to write it up here. algorithm stop after and iterations This is important. This is actually the step 3 in my three-step process because you're going to say okay this Loop invariant ": [
            3976.9,
            4033.1,
            88
        ],
        "I want you to write it down. And then you're going to have one representative come right up on the board. Write down your strategy. Okay. What is a drinking? Okay. Okay. Yeah, so just take a piece of paper and you can just rip off a corner or something just need like one one portion of paper per person. What's your first name on it short then or come ": [
            689.2,
            734.5,
            17
        ],
        "N smallest? But that doesn't really make much difference because it's just all of the things right the end smallest. Okay. So next time we're going to prove prove the loop invariant for this algorithm. And then once you did that, everything else will fall into place cuz we've already made our conclusion here. Okay, so you guys want to end a little bit early today? Okay. Thank you for ": [
            4174.0,
            4203.3,
            92
        ],
        "Okay, so I have my for loop from I 2 from 1 2 N -1 and you find the minimum of the last and minus I and then you interchange them. Here's more of like a lower-level pseudocode which to me is just like kind of takes time to understand for me at least cuz you have to keep track of all the indices and there's like, okay, what are ": [
            2166.9,
            2197.8,
            39
        ],
        "Team sets vault? Wow, you actually did this. Yeah. And then you kept going until it was done. You kind of merge them together. You may have called something like merge sort or something. Okay, very good. Thank you. Okay, they're still working on theirs, right? Team unsorted. I like that. Okay, should I come back to them their unsorted by now? Okay. How about you guys over here? Oh ": [
            1274.7,
            1393.0,
            22
        ],
        "Then the next thing you do is well, you kind of want to lock this one in since it's the smallest element. Anyway, you never ever want to touch it again. We want to keep it there then find the next smallest element, which is 2 and swap it with the second element. and then you lock in one into and so on guys kind of get the idea. So ": [
            2360.0,
            2389.1,
            44
        ],
        "Yes, so let's I'm going to answer that question with the previous algorithm just because we have an example for it, right so. Once once I've once I've taken care of the the second to last element 77, I don't have to worry about the element because it's it's already necessarily the biggest and that's sort of the same idea of the other one, too. Is there an element's? So ": [
            2519.9,
            2556.5,
            49
        ],
        "You did what? three way Did you say twist storm? quicksort Okay. Can you explain to me what that means? Okay. I see. Cool, great. Thank you. Okay. How about you guys back here? Wait, you mean team segfault? She put them into piles and then you sorted each pile. Oh, okay. So it's sort of like a combination of Alvin and segfault. What is your team name? Wait, what ": [
            1477.1,
            1588.5,
            24
        ],
        "You just kind of run this running thing and it keep updating at once you find a smaller element, right? So I'm just going to replace it with minimum and also interchange a and a inam well, Kind of depends on what computer program you're looking at how to do this the most efficiently, but in either case the end result is I'm going to be interchanging these two values. ": [
            2141.2,
            2164.2,
            38
        ],
        "again. Here's here's a here's another sort of example. SO3 is less than 6 so you keep it 6 is greater than 1 so you swap those six is greater than for that so you swap those and it's 6 is greater than 2 so you swap and what's going to happen. It may not be perfectly clear at this point. But we're going to talk about it a little ": [
            2664.9,
            2690.5,
            53
        ],
        "all guaranteed to be in sorted order as you go. So like maybe you get interrupted. This one is at least like making your way there you can kind of hand your boss the first part of the listen sale at least these ones are sorted. Okay. This is kind of what you guys were talking about. You make little ranges for the numbers and you put them all in ": [
            3090.6,
            3116.4,
            65
        ],
        "and I'll and I'll kind of give you a hint of how to start your Loop invariant it often starts something like this. after t theater Asians What is true? about the list Ready go. okay, here's another hint You might want to use the letter T in your in what in the loop invariant may be off in time to Loop invariant you say after so many iterations. The ": [
            3692.7,
            3803.2,
            84
        ],
        "be after. t iterations a 1 through 80 are all How you want to say it are the smallest? Are the T smallest? elements right So they're sorted and they're the smallest so you can see back here write 17 is the smallest 17 and 20 or smaller than 17 through 26 or smaller than the rest and so on. Okay, so let's just go with our conclusion. So we're ": [
            4075.9,
            4126.3,
            90
        ],
        "be up by tomorrow. Any other questions? So there's going to be some counting questions some recursion questions some Big O questions. Those are the things to look for. Okay, let's get started. Sorting or ordering. This is a very important topic in computer science your computer sorts things like a million times per second every second. Maybe that's not true. But a lot of times your phone is always ": [
            227.0,
            271.9,
            5
        ],
        "better because I've got those two holes, you know. Huh? bigger bubbles float faster than Oh because there was a big hole big bubble. I don't know bigger numbers bigger numbers bubble up. Let's just go in that. Okay, so then yeah, so that one goes all the way there. You got the six and then this one. We didn't do all the comparisons, but then you get the for ": [
            2726.6,
            2773.1,
            55
        ],
        "bit later is that at the end of the first iteration? The biggest number is all the way to the right? Okay. It's at the end. It's in his right positions in correct position and that's why it's bubble sore is because the biggest number is going to Bubble Up To The Top I guess because it's the biggest bubble. the lightest density I feel like at 8 would float ": [
            2690.5,
            2726.6,
            54
        ],
        "but If it does, then it doesn't really fast to do it that way but it's got to be kind of be ordered in a special way for it to to workout. Okay, great. So let's let's take a look at how we're going to generally talk about algorithms. So we're going to analyze algorithm. So all those things that you gave me there all algorithms. What are some questions ": [
            1903.1,
            1929.9,
            30
        ],
        "certain range, right? So if you know something about the data you can get you can maybe get an advantage on some of these things. questions about that Okay, so let's talk about from how to why all those things I showed you you say. Oh, that's nice that sorts the list because I showed you one example. Okay, you guys got to start thinking about how does it work ": [
            3498.7,
            3529.1,
            78
        ],
        "changing. What is the thing that stays true or does not change as you go through the iterations of So I'll Loop invariant does a property that remains true after each time. The body of the loop is executed. So at for an iterative algorithm like this, how do you prove the correctness you look for a loop invariant and you state it precisely. You proved that is invariant. Guess ": [
            3593.6,
            3622.0,
            81
        ],
        "class, right? You can kind of just keep on passing the pile but the last person is going to do the most work, right because the last person have to look through their pile to figure out where the name is, but at least the pilot he's given is in sorted order. Does that help right if his name is starts with And is and the middle number? LOL, yeah, ": [
            2803.7,
            2830.2,
            57
        ],
        "computer do it. You kind of have to take your array, right? If you want to insert something you're going to have to move everything over to create a spot for it. Now this element has been inserted where it belongs to the same for the next element. Okay, here's here's a mid-level description. So now now instead of going from 1 2 N -1. This one goes from 2 ": [
            2855.4,
            2884.1,
            59
        ],
        "cool. Okay, cool. Great. Maybe you might recall that bucket sort or something. Okay, great. Thanks. Okay. How about you guys back there or you were you guys part of Team No Name? Okay. How about you guys over? Here we go as part of team segfault. What is your name? Okay, great. Okay. How about you guys back there? Okay team stack overflow. How did you guys do it? ": [
            1393.0,
            1474.2,
            23
        ],
        "day that you bought them. Welcome to my life with my wife. like every day come home and it's like yeah, it was sitting on the floor over there because that's what I knew her supposed to be everybody has like a different way of organizing their stuff, right? So it all depends on the context. speaking of which Which of the following collections of elements is sorted? B and ": [
            385.6,
            462.4,
            9
        ],
        "do you mean like at 2 or 4 written out? Like I haven't. Okay. Thank you. All right sort of like I'll just go like this. two piles sordid emerged Okay, I think we're ready for team unsorted. Are you guys team sorted yet? sort of thank you. All right. What are you guys do? a tree So nice. And then you say you built the tree and then you ": [
            1588.5,
            1656.0,
            25
        ],
        "element, you put it in the order of the first two when you get the fourth you find it in the order of the first three and so on. was that yeah, there's not what you guys did it kind of. Yeah. Okay, this nightmare is the low-level pseudocode. Okay, I mean looking at it is maddening at least for me. Maybe you guys are more attuned to what this ": [
            2908.6,
            2946.7,
            61
        ],
        "every one of those sorting algorithm. We were making progress as we went along we kept on every iteration we kept on adding a new thing there and in at the end of this was all the way sorted. Okay, so what is a loop invariant? In means not variant means changing. And I think it is that Latin or Greek. Same same time invariant means not changing Loop not ": [
            3555.9,
            3593.6,
            80
        ],
        "factorial. Yeah, we'll talk more about that to expected value. Okay, then there's quicksort which I kind of talked about. But did you guys say you used quicksort? So you take one of the elements at random and you kind of use it as a pivot and put everything to the right everything bigger to the right and everything smaller to the left. Then just like merge sort you recursively ": [
            3390.8,
            3418.5,
            74
        ],
        "first of all, They're going to be good practice for your homework questions and your exam questions, but also job interviews and stuff like that. If you ever do any kind of technical job interview, sometimes they ask you algorithm questions and it's good to know. What kind of sorting algorithms you need some algorithms are better than others. And what do I mean by better? Well Does it use ": [
            3443.5,
            3473.9,
            76
        ],
        "for them. Yeah, okay. We're going to we're going to give you a seating chart and Just take a look and know your seat. Come in here. Are we accommodating for left-handed seat rating for left-handed seats? And Yeah, or we could just because you're leaving the other left-handed seats open right now. so so the review so Andrews class the other instructor. He has a class like right before ": [
            47.5,
            98.5,
            1
        ],
        "from one meeting one is the first position and then go to the end - 1st position any other questions about that? Guess that might be confusing for you guys moving for it. So sometimes it's nice to kind of group those things together when it's such a mundane easy. Okay, let's look at how it works on this example. so The first thing you do is you find the ": [
            2291.8,
            2326.3,
            42
        ],
        "go down and then go back and then you go up, right? Yes, something like that. Okay. Thanks everybody for participating. Hope it wasn't too annoying to do but I did I wanted you two to try it out. You know, what would you do? I mean you we only had groups of around 10 to 20 which ones which one of these things would scale well to maybe the ": [
            1750.9,
            1777.8,
            27
        ],
        "go through a few approaches and there are a few quotes from previous Quarters at Otis about what how do they explain it? And you might see approaches that are similar to what you guys did. Okay, so we have selection sort. It's also called men's sort. Okay, and psyche trying to trying to sort your DVDs. Is anybody even own DVDs anymore? It's not Blu-ray. What about bhs's Anyhow ": [
            2037.0,
            2078.7,
            35
        ],
        "going to talk about how to do that at the end of this class in certain types of algorithms. And then when do we get an answer? This is going to be how efficient is it? Is it going to scale well, and that's why we talked about all those Big O notation asymptotics. Those are going to be sort of our tools to measure how efficient algorithm is. Does ": [
            1959.6,
            1983.3,
            32
        ],
        "going to we're probably going to prove it on Wednesday, but I just want to kind of jump to the conclusion because if if you guys believe these Loop invariants, how do you show that the algorithm actually works based upon them you say Do I best conclusion? conclusion conclusion after n iterations A1 through a n are sorted and just for fun, we can also say And are the ": [
            4126.3,
            4174.0,
            91
        ],
        "have to have some sort of total ordering on them whether that be alphabetical or numerical or I don't know if I serial numbers or by Price or do you know if your air flights cost or by distance, right? So all of these kinds of things So on this slide, we have two different pictures. Which one is sorted and which one is unsorted? What kind of depends on ": [
            304.8,
            347.1,
            7
        ],
        "here's another sort of. Figure that that you can see it happen throughout the whole thing. So you can kind of look at it see how it works. Knights the first element has 17 you swallow with 54 and as you go you can see that these elements are going to start to be fixed. right And that's going to be important. because at the end they should all be ": [
            2389.1,
            2430.6,
            45
        ],
        "how we're going to prove it. Induction exactly induction happens to be the best tool for looping variance. Why is because if it stays true after however many iterations then it's got to stay true for the next iteration. And so that's exactly the type of structure of a proof that you want. Okay, so prove that the invariant is true. That's part 2 don't forget about part 3. You ": [
            3622.0,
            3653.3,
            82
        ],
        "if the exams were sorted in the same order as a spreadsheet, right? Cuz if you could just kind of put one on one to one and keep on hitting tab away return which is the one that goes down. return keep on hitting return unless you have it. No, everybody does it that way? Or another really good thing about sorting is it's nice to find duplicate duplicate values ": [
            554.6,
            579.0,
            12
        ],
        "if the if the consecutive numbers if AJ is bigger than AJ plus one than interchange them. So we're going to look at it example, but you can see it's sort of like in the biggest numbers are bubbling up to the top. Okay, and so at the end of the first iteration, you'll see that the highest numbers at the top in the next highest in the next time. ": [
            2486.9,
            2511.6,
            48
        ],
        "in a long list, right? You just sort it and then you can just go down the list and see whenever there is there together. I kind of collect things collect duplicate values together. Okay. So the main point is that once it's sorted it's easier to access because you know, I wouldn't I wouldn't say, you know exactly where to find it. Maybe I should say, you know kind ": [
            579.0,
            602.2,
            13
        ],
        "in front of the 13, right? Then you introduce the 19 so you put that at the end. Can you introduce the two and really what the computers going to have to do is shift everybody over to make place for the 2 to put in the front? Yeah. Right. So it all depends depends on what sort of thing you're using. But the idea is the same either way. ": [
            3000.0,
            3036.7,
            63
        ],
        "in order. Okay, let's look at another one bubble sort. What happened with that? Okay. So this is one way to describe bubble sort compare. The first two cards answer you think about like your names are on cards. If the first is bigger keep comparing it to the next card in the stack until you find a larger one. And then when it's larger start comparing that one repeat ": [
            2430.6,
            2459.7,
            46
        ],
        "is AJ. Let's AJ is equal to one is a 1 bigger than a to. Yes, so you swap them. Okay, then the next thing you do is. Look at the next two numbers and if it's bigger than you swap them, right 12 for 1617 1324 2023. Okay, then you look at the next two elements and since 16 is less than 17 you don't swap it. You get ": [
            2591.3,
            2635.2,
            51
        ],
        "is doing, but essentially This thing here is finding. where to put it and then this bit here is this is just like the shifting things over to make room Let's look at an example. So basically you just start with the first element 13 and you put that sub list in sorted order. It's already in order. So we're fine. Then you introduce the six. Until you put it ": [
            2946.7,
            3000.0,
            62
        ],
        "is true after every iteration. So it must be true after and iterations which means after Generations a 1 through a n is sorted and that's what I wanted. So that's actually kind of going forward. Cuz it's another loop invariant that's actually important for the for approving this correct. Hey buddy, have a another one. Okay, good. So So this will be one and two will be. Two will ": [
            4033.1,
            4075.9,
            89
        ],
        "it going to scale linearly? Is it going to scale like and squared is it going to scale like analog again? It depends on what the algorithm is doing. Okay, so we got the problem specification algorithm description correctness and Time Performance. So let's start with sorting. What is the problem you're given a list you rearrange the values so that they're in sorted order. They're in increasing order and ": [
            1983.3,
            2010.9,
            33
        ],
        "just took him two things off Leaf by leaf. And then you put them in order based on the tree order traversal. Okay, did I get everybody? You kind of do like a like if this is your tree. It's a bad tree. You do something like this, right? you go up there and then down like that you start from the left and you go up and then you ": [
            1656.0,
            1750.9,
            26
        ],
        "let's look at this example. Okay. So what you do is where's my I guess I'll start here. So I starts at 1 and Jay goes from 1 to n minus. I so in the first iteration it goes from 1 to n -1. Okay, and what it does is it kind of swaps these elements and moves along? No queso. It looks first looks at 16 and 12. Right ": [
            2556.5,
            2591.3,
            50
        ],
        "like a as like a sequence, right? Good you guys have that understand basically after one iteration. The first element is sorted, of course after to iteration the first two elements are sorted and so on. What I was thinking was that like after T iteration. We've done a total of cheetahs cheapest One Compares inside of the year that include comparing and to the left that's not part of ": [
            3906.4,
            3955.7,
            86
        ],
        "little half here. And then maybe you guys can even either be part of that group or this group. Who won? from yeah from another person I used to play a lot more. I don't know if I haven't played in a long time. You guys getting a good thing. Merge sort is it work? Okay, so you guys are all pretty much done. Okay, I'm going to need a ": [
            774.7,
            1148.7,
            19
        ],
        "merge sort the other side of the list. Right and then put them back together merge, the two sorted lists. We're going to talk about this sorting algorithm in more detail a little bit later. Just wanted to give you kind of the way that that we're going to present in this class questions. was that So it doesn't the it doesn't matter actually how you split the list. This ": [
            3212.5,
            3244.4,
            69
        ],
        "minimum element and how are you going to do that? You kind of just keep on going until and keep on updating, right? So we won't we won't go through that every time just to give you an idea. So we find the minimum element is 1 So what we do is we take one and we replace it or we swap it with 15128. 313-2312. Okay. O15. Thank you. ": [
            2326.3,
            2356.8,
            43
        ],
        "more memory does it is it more efficient with time? Is it better for certain types of data, like four integers or four strings are for this or for that? Is it better if you know that the set is already kind of sordid and you just need to kind of clean it up or is it better if if you know that the that the elements are in a ": [
            3473.9,
            3498.7,
            77
        ],
        "of the general area of where to find it. Okay. So how do you store let's say you're organizing some event and you have a bunch of cars with first names and their sort of all in random orders. You want to sort them out the medically, so they're easier to distribute. How do you put them in order? so sorting we're going to talk up the most mostly mostly ": [
            602.2,
            632.0,
            14
        ],
        "on all inputs? Is it going to work every time on all inputs? Okay. So that's where we're going to talk about the correctness proof the proof of correctness, and we're going to start off by looking at something called a loop invariant. Okay. So the for these loop-based algorithms What happens after every iteration? Okay, how we make progress to the end? You saw from all those examples that ": [
            3529.1,
            3555.9,
            79
        ],
        "on it. And I want you guys to first of all sort them. They're going to come in a random order but more importantly think about how did you sort them come up with a strategy and I want this strategy to be clear and I want it to be scalable right? Not just for your size of people. Can you can you can do it for more people? Okay. ": [
            662.4,
            687.0,
            16
        ],
        "project. Okay. So basically what we did is we just gather. Rachel put two piles and then searched where The next name goes right? and then repeat Play what's the deal with the two piles are you just did two people? We're doing it at once and then you put them together. Okay. Okay. Great. Thank you. So what was this again team Alvin? Okay. Thank you. Okay, how about ": [
            1200.1,
            1274.7,
            21
        ],
        "property is based on however many iterations you've been through. Are you guys drinking? We're planning on what we're going to do Wednesday. knowledge I would Starbucks I realize he did a that's fine. Oh, that is just a Try it kind of blocked out what I said there anybody have a loop invariant. Master tea iterations Hey 1 through 80. is sorted right if you think about it as ": [
            3803.2,
            3906.4,
            85
        ],
        "representative from each group. Let's start with this group. What's your group name? team, Alvin Okay. So maybe what we will do is do you guys prefer to write it on the board or just explain it in words? finding words How about you? Set vault. Okay. What do you say? Okay, you can just come explain it or you can do you want the microphone or okay, you can ": [
            1148.7,
            1200.1,
            20
        ],
        "short. because quicksort you sort of like unravel the the list and then you just stick it back together. Where is merge sort you kind of break up the list sort them and then kind of interleaf. We'll talk about that a little later. Okay, here's some others BOGO sort. Has anybody heard of that before? Buy one get one. No, it's where you randomly arranged the elements and then ": [
            3307.2,
            3346.8,
            72
        ],
        "so find the first name alphabetically put it to the front then for the look for the next one put it to the front and so on so pretty easy to follow. Another thing that you can think about is use a linear search to find the smallest element or used like a routine like a minimum finding algorithm find the minimum swap its element with the element that in ": [
            2078.7,
            2105.2,
            36
        ],
        "some tea. So you can have the topics right all the material basically, big'o stuff counting stuff and recursive counting. So all the stuff in the first 3 weeks. There's a things to know Google doc. That's posted on Piazza, but you guys can take a look at and you can bring one sided sheet of handwritten notes handwritten. question That's right. That's correct. Dayton in the seating chart, it'll ": [
            175.9,
            227.0,
            4
        ],
        "sort each side with quick sort and then you just stick them together because you know, all of these are bigger than all of these. We just put them back together. Binary search tree traversal. Did you guys see that? It's a good one. So there's a bunch of sorting algorithms even more than what we're going to go over. Okay? Why are we talkin about so many algorithms? Well, ": [
            3418.5,
            3443.5,
            75
        ],
        "sorting is going to be you have all these distinct objects or maybe someday or some duplicates and you sort them by comparing them in Paris. What I want you guys to do is figure out how to do this queso in groups of maybe like I don't know 10 to 20 people. Get a piece of paper. You can break it up if you like everybody put their name ": [
            632.0,
            662.4,
            15
        ],
        "sorting things, right? It's a way that you can organize your data so that you can access it easily in the future, right? so one big question is what is the most efficient way to sort things? Okay. And usually what we think about sorting things that the easiest thing to sort his number so will generally be sorting numbers, but you can sort other types of things. You just ": [
            271.9,
            304.8,
            6
        ],
        "still have to kind of figure out why does the loop invariant? Imply that the algorithm is correct. questions about that alright, so let's go back to selection sort. So I want you guys to take a few minutes talk it over with your neighbor come up with a loop invariant for selection store. Okay, you want me to put up the example? It might be a might be helpful ": [
            3653.3,
            3692.7,
            83
        ],
        "that's name starts with an L. But maybe there's like more. I don't know. Maybe the letters aren't distribute. Anyhow. Yeah, you can kind of find it. Okay, so put another way take an element of a and find out where it belongs relative to the elements before it shift everything back to make room and put the element in his proper place. Okay, so I actually how does a ": [
            2830.2,
            2855.4,
            58
        ],
        "the buckets and then depending on how many things are in the buckets that you use some sort of other sorting algorithm to sort within the buckets. Pseudo pseudo code crate empty buckets put the buckets in the list in the correct button start with E to fucking concatenate the buckets in order. Okay, then there's merge sort. This one is what you guys did right? And this is how ": [
            3116.4,
            3146.9,
            66
        ],
        "the exam. And we decided that it would be you know, not very helpful if we went over new material during that class. So he's going to go over a little bit of review but it's going to be right before the exam. So only like maybe just to brush up on on certain Concepts and is going to be I think it's in there. It says what? here I ": [
            98.5,
            135.0,
            2
        ],
        "the first slot, right and then repeat this and -1 * Let's look at how this looks in a pseudocode. Okay, so I like to call this more like a mid-level pseudocode because I'm replacing some of like the mundane. operations with sort of subroutines for example I'm just going to take it to that. Everybody knows how to code up this algorithm. How do you find the minimum? Right? ": [
            2105.2,
            2141.2,
            37
        ],
        "the list a bunch of times right? This one is you just split it up and let the algorithm do the work on each side and then you put it together. So it's sort of like this one's like more Magic. Or at least you just have to have faith in your algorithm that it works and then it puts together. I don't know if anybody knows what that is ": [
            3282.4,
            3307.2,
            71
        ],
        "the story part. Lifesaver example to pick the second number, you know, you have to compare it with the first number if you pick the third number, you know, if you're looking for the third time, you have to compare it with the two numbers on the left, right? Okay. So we're going to talk about that when we talk about run time. So that's not really a loop invariant. ": [
            3955.7,
            3976.9,
            87
        ],
        "the three and then the two and then you're done. Okay any questions about that? Okay, how about this one insertion sort? Pass the cards from right to left each individual and starting their own card into the correct position as they relayed the pile So This Groove actually used like everybody as part of the process actually this this might be something that you could do for the whole ": [
            2773.1,
            2803.7,
            56
        ],
        "there's a maybe maybe it's important to you to have them in alphabetical order for some reason. okay, what's what's what's another nice thing for sorting while you know, like back when we used to use blue books. Have all the pile of blue books. It's much nicer if they're in sorted order, right? So imagine you're trying to input scores into a spreadsheet. It's a lot easier if the ": [
            522.1,
            554.6,
            11
        ],
        "thought you was in. Warren lecture hall Oh here that's because right because I took this slide from him. I think it's 2005 on there. It will start at 6:30. That's when his class starts and he's really only going to spend like 45 minutes or so so that you guys have another almost an hour before the exam start so you can kind of get yourself together. We'll have ": [
            135.0,
            175.9,
            3
        ],
        "to n. And the idea is because the first element in the list if you just look at it by itself. It's already in sorted order. If you really only start to figure out the sorted order when you get the second element, so when you get the second element, you kind of you make sure it's in the right order with the first element when you get the third ": [
            2884.1,
            2908.6,
            60
        ],
        "until the stack is sorted kind of works. In a different way, let's see what the pseudocode looks like. Now this one it's hard to come up with like a mid-level pseudocode cuz it's already pretty simple. You just kind of have this double Loop or The Loop the first live goes from 1 2 N -1 and the second Loop goes from 1 to n minus. I Okay, then ": [
            2459.7,
            2486.9,
            47
        ],
        "up into two groups. You merge few. You sort them with the actual algorithm. And then you enter leave them. Put it back together. So here's the pseudocode former store. Okay, if the list has just one element, then you're done. You don't have to do anything otherwise divided into two pieces and Split into half as best as you can. then merge sort one side of the list and ": [
            3180.2,
            3212.5,
            68
        ],
        "up with a strategy? So maybe like you guys hear this first like quadrant? You guys all work together and then you guys back here, or maybe you could split it up into two. That sounds good. And then yeah, maybe we could split it up into maybe like this half and that hat. and then you guys maybe can all just be one thing and then you guys this ": [
            734.5,
            774.7,
            18
        ],
        "we always start at 1 and I know in computer science you always start at zero. Why is that? It's just a convention. Well, so yeah. Yeah, I guess you're just going to have to get used to it cuz this is going to be how we're we're looking at it. A good question. So when I say start from 1 to go up 2 N -1, I mean start ": [
            2255.4,
            2291.8,
            41
        ],
        "we can ask about them the what what problem are we solving this case is just sorting I saw the problem. That's the actual algorithm. That's what you guys provided. It's either a step-by-step process a pseudocode an actual computer code. Or just some sort of description. Okay, why do the step solve the problem this is going to be the proof of correctness. This is going to be we're ": [
            1929.9,
            1959.6,
            31
        ],
        "we're going to present it you split into two groups and organization of the group's then we get back together and figured out how to enter leave the groups in order. So you've split into two groups and organized the groups. How did you do that? Well? You merge sort them. Right, you sort them with the same algorithm. So this is a recursive algorithm. Where are you? Split it ": [
            3146.9,
            3180.2,
            67
        ],
        "what you mean by sorted, right? So this is some kids room maybe he wants the pizza box right down there on the floor next to the dog bowl. Yeah, there's a kid in there. He's right here. So maybe maybe he wants to be like that and maybe you don't want them to be sorted by height. Maybe want them to be sorted by I don't know. Yeah the ": [
            347.1,
            385.6,
            8
        ],
        "whole class. Which one would you guys like to do? I'm going binary tree. Tim Allen Stack overflow. Yeah. I like no name for the whole class cuz then you could like put them all in buckets and then give the buckets out to other people different groups and then you can like do some parallel computer. Exactly. Yeah. Oh. Was that what you put it in the stack, then ": [
            1777.8,
            1861.8,
            28
        ],
        "will work either way, but if it's odd that you just split it so that one one list has one more element the other you want to listen to happy as possible so you can get the best run time. I don't know. I don't know. Will bubble sort think about this is like the main difference. I see bubble sort is like you got to kind of go through ": [
            3244.4,
            3282.4,
            70
        ],
        "you can you can re rearrange this problem to be in decreasing order or alphabetical order or whatever you want, but we're going to for Simplicity from now on when we talked about starting over and we're going to use integers. Okay, so so it's just kind of easy to do. Oh your approaches. How'd you do it? Right this is what we just talked about. So I'm going to ": [
            2010.9,
            2037.0,
            34
        ],
        "you check to see if it's in sorted order. And if it's not then you repeat. Did anybody try that one when you were sorting? How how long do you have to wait till that one works? n factorial Wisconsin time if you're very lucky. yes, best case scenario constant time worst case scenario and factorial or Well, if that's the case, then I would say expected run time and ": [
            3346.8,
            3390.8,
            73
        ],
        "you doing here what's going on? But if you if you break it down, you can just see that this whole part here. Is to find the minimum. Sorry. Yeah. Oh. So if you look at the input, you see that it starts at A1A to all the way up to a n. Sorry. I have it on two lines. A1822 a n and I apologize. I'm Psych in mathematics, ": [
            2197.8,
            2255.4,
            40
        ],
        "you either put something on top of it or you pop it out? stack sort Yes tax or-tis is really significant for me because it was one of the first kind of. algorithms that I used when I was doing my research in in the math department but stack search Stacks or only works if the if the ordering avoids a certain pattern we don't have to go into it, ": [
            1861.8,
            1903.1,
            29
        ],
        "your participation. UC San Diego podcast ": [
            4203.3,
            4208.0,
            93
        ]
    },
    "File Name": "Mathematics for Algorithms and Systems - B00 - Jones, Miles E - Winter 2019-lecture_6.flac",
    "Full Transcript": "Can I have your attention?  so  Before we begin here's a few things to know about the exam.  First of all, it's tomorrow.  It's tomorrow night. We're going to be across this Hall in Center 119. And the other class are going to be here in this room, but did you guys see the seating chart yet?  Delete an uploaded yet.  Oh and our thing. Yeah, we should upload it for them.  Yeah, okay. We're going to we're going to give you a seating chart and  Just take a look and know your seat. Come in here. Are we accommodating for left-handed seat rating for left-handed seats? And  Yeah, or we could just because you're leaving the other left-handed seats open right now.  so  so the review  so Andrews class the other instructor. He has a class like right before the exam.  And we decided that it would be you know, not very helpful if we went over new material during that class. So he's going to go over a little bit of review but it's going to be right before the exam. So only like maybe just to brush up on on certain Concepts and is going to be I think it's in there.  It says what?  here  I thought you was in.  Warren lecture hall  Oh here that's because right because I took this slide from him.  I think it's 2005 on there. It will start at 6:30. That's when his class starts and he's really only going to spend like 45 minutes or so so that you guys have another almost an hour before the exam start so you can kind of get yourself together. We'll have some tea.  So you can have the topics right all the material basically, big'o stuff counting stuff and recursive counting. So all the stuff in the first 3 weeks.  There's a things to know Google doc.  That's posted on Piazza, but you guys can take a look at and you can bring one sided sheet of handwritten notes handwritten.  question  That's right. That's correct.  Dayton in the seating chart, it'll be up by tomorrow.  Any other questions?  So there's going to be some counting questions some recursion questions some Big O questions.  Those are the things to look for. Okay, let's get started.  Sorting or ordering. This is a very important topic in computer science your computer sorts things like a million times per second every second.  Maybe that's not true. But a lot of times your phone is always sorting things, right? It's a way that you can organize your data so that you can access it easily in the future, right?  so  one big question is what is the most efficient way to sort things? Okay.  And usually what we think about sorting things that the easiest thing to sort his number so will generally be sorting numbers, but you can sort other types of things. You just have to have some sort of total ordering on them whether that be alphabetical or numerical or I don't know if I serial numbers or by Price or do you know if your air flights cost or by distance, right? So all of these kinds of things  So on this slide, we have two different pictures.  Which one is sorted and which one is unsorted?  What kind of depends on what you mean by sorted, right?  So this is some kids room maybe he wants the pizza box right down there on the floor next to the dog bowl.  Yeah, there's a kid in there.  He's right here.  So maybe maybe he wants to be like that and maybe you don't want them to be sorted by height. Maybe want them to be sorted by I don't know.  Yeah the day that you bought them.  Welcome to my life with my wife.  like every day come home and it's like  yeah, it was sitting on the floor over there because that's what I knew her supposed to be everybody has like a different way of organizing their stuff, right?  So it all depends on the context.  speaking of which  Which of the following collections of elements is sorted?  B and C are what?  So B&B is really what we're seeing here, huh?  Okay.  So what you saying be was like the main one that wasn't the so let's start with that one is be sorted.  In what order?  Okay, how about sea?  descending order  how about a  alphabetical  write 42 starts with a f pain starts with a t  All depends on which way you want to order them.  Maybe there's a maybe maybe it's important to you to have them in alphabetical order for some reason.  okay, what's what's what's another nice thing for sorting while you know, like  back when we used to use blue books.  Have all the pile of blue books. It's much nicer if they're in sorted order, right? So imagine you're trying to input scores into a spreadsheet.  It's a lot easier if the if the exams were sorted in the same order as a spreadsheet, right? Cuz if you could just kind of put one on one to one and keep on hitting tab away return which is the one that goes down.  return keep on hitting return  unless you have it. No, everybody does it that way?  Or another really good thing about sorting is it's nice to find duplicate duplicate values in a long list, right? You just sort it and then you can just go down the list and see whenever there is there together. I kind of collect things collect duplicate values together.  Okay. So the main point is that once it's sorted it's easier to access because you know, I wouldn't I wouldn't say, you know exactly where to find it. Maybe I should say, you know kind of the general area of where to find it.  Okay. So how do you store let's say you're organizing some event and you have a bunch of cars with first names and their sort of all in random orders. You want to sort them out the medically, so they're easier to distribute. How do you put them in order?  so  sorting we're going to talk up the most mostly mostly sorting is going to be you have all these distinct objects or maybe someday or some duplicates and you sort them by comparing them in Paris. What I want you guys to do is figure out how to do this queso in groups of maybe like I don't know 10 to 20 people.  Get a piece of paper. You can break it up if you like everybody put their name on it. And I want you guys to first of all sort them. They're going to come in a random order but more importantly think about how did you sort them come up with a strategy and I want this strategy to be clear and I want it to be scalable right? Not just for your size of people. Can you can you can do it for more people? Okay.  I want you to write it down.  And then you're going to have one representative come right up on the board.  Write down your strategy.  Okay.  What is a drinking?  Okay. Okay. Yeah, so just take a piece of paper and you can just rip off a corner or something just need like one one portion of paper per person.  What's your first name on it short then or come up with a strategy?  So maybe like you guys hear this first like quadrant?  You guys all work together and then you guys back here, or maybe you could split it up into two.  That sounds good. And then  yeah, maybe we could split it up into maybe like this half and that hat.  and then you guys maybe can all just be one thing and then you guys  this little half here.  And then maybe you guys can even either be part of that group or this group.  Who won?  from yeah  from another person  I used to play a lot more. I don't know if I haven't played in a long time.  You guys getting a good thing.  Merge sort is it work?  Okay, so you guys are all pretty much done.  Okay, I'm going to need a representative from each group.  Let's start with this group.  What's your group name?  team, Alvin  Okay.  So maybe what we will do is do you guys prefer to write it on the board or just explain it in words?  finding words  How about you?  Set vault.  Okay.  What do you say?  Okay, you can just come explain it or you can do you want the microphone or  okay, you can project.  Okay. So basically what we did is we just gather.  Rachel put two piles  and then searched  where  The next name goes right?  and then repeat  Play what's the deal with the two piles are you just did two people? We're doing it at once and then you put them together.  Okay. Okay. Great. Thank you.  So what was this again team Alvin?  Okay. Thank you.  Okay, how about Team sets vault?  Wow, you actually did this.  Yeah.  And then you kept going until it was done.  You kind of merge them together. You may have called something like merge sort or something.  Okay, very good. Thank you.  Okay, they're still working on theirs, right?  Team unsorted. I like that.  Okay, should I come back to them their unsorted by now? Okay. How about you guys over here?  Oh cool.  Okay, cool. Great. Maybe you might recall that bucket sort or something.  Okay, great. Thanks.  Okay. How about you guys back there or you were you guys part of Team No Name? Okay. How about you guys over? Here we go as part of team segfault.  What is your name?  Okay, great. Okay. How about you guys back there?  Okay team stack overflow.  How did you guys do it?  You did what?  three way  Did you say twist storm?  quicksort  Okay.  Can you explain to me what that means?  Okay.  I see.  Cool, great. Thank you.  Okay. How about you guys back here?  Wait, you mean team segfault?  She put them into piles and then you sorted each pile.  Oh, okay. So it's sort of like a combination of Alvin and segfault.  What is your team name?  Wait, what do you mean like at 2 or 4 written out?  Like I haven't. Okay. Thank you. All right sort of like I'll just go like this.  two piles  sordid  emerged  Okay, I think we're ready for team unsorted. Are you guys team sorted yet?  sort of  thank you. All right. What are you guys do?  a tree  So nice.  And then you say you built the tree and then you just took him two things off Leaf by leaf.  And then you put them in order based on the tree order traversal.  Okay, did I get everybody?  You kind of do like a like if this is your tree.  It's a bad tree.  You do something like this, right?  you go up there and then  down like that  you start from the left and you go up and then you go down and then go back and then you go up, right?  Yes, something like that. Okay. Thanks everybody for participating.  Hope it wasn't too annoying to do but I did I wanted you two to try it out. You know, what would you do? I mean you we only had groups of around 10 to 20 which ones which one of these things would scale well to maybe the whole class.  Which one would you guys like to do? I'm going binary tree.  Tim Allen  Stack overflow.  Yeah.  I like no name for the whole class cuz then you could like put them all in buckets and then give the buckets out to other people different groups and then you can like do some parallel computer.  Exactly. Yeah.  Oh.  Was that what you put it in the stack, then you either put something on top of it or you pop it out?  stack sort  Yes tax or-tis is really significant for me because it was one of the first kind of.  algorithms that I used when I was doing my research in in the math department but stack search Stacks or only works if the if the ordering avoids a certain pattern we don't have to go into it, but  If it does, then it doesn't really fast to do it that way but it's got to be kind of be ordered in a special way for it to to workout.  Okay, great. So let's let's take a look at how we're going to generally talk about algorithms. So we're going to analyze algorithm. So all those things that you gave me there all algorithms. What are some questions we can ask about them the what what problem are we solving this case is just sorting I saw the problem. That's the actual algorithm. That's what you guys provided.  It's either a step-by-step process a pseudocode an actual computer code.  Or just some sort of description.  Okay, why do the step solve the problem this is going to be the proof of correctness. This is going to be we're going to talk about how to do that at the end of this class in certain types of algorithms. And then when do we get an answer? This is going to be how efficient is it? Is it going to scale well, and that's why we talked about all those Big O notation asymptotics. Those are going to be sort of our tools to measure how efficient algorithm is. Does it going to scale linearly? Is it going to scale like and squared is it going to scale like analog again? It depends on what the algorithm is doing.  Okay, so we got the problem specification algorithm description correctness and Time Performance. So let's start with sorting. What is the problem you're given a list you rearrange the values so that they're in sorted order. They're in increasing order and you can you can re rearrange this problem to be in decreasing order or alphabetical order or whatever you want, but we're going to for Simplicity from now on when we talked about starting over and we're going to use integers. Okay, so so it's just kind of easy to do.  Oh your approaches. How'd you do it? Right this is what we just talked about. So I'm going to go through a few approaches and there are a few quotes from previous Quarters at Otis about what how do they explain it? And you might see approaches that are similar to what you guys did.  Okay, so we have selection sort. It's also called men's sort.  Okay, and psyche trying to trying to sort your DVDs. Is anybody even own DVDs anymore?  It's not Blu-ray.  What about bhs's  Anyhow so find the first name alphabetically put it to the front then for the look for the next one put it to the front and so on so pretty easy to follow.  Another thing that you can think about is use a linear search to find the smallest element or used like a routine like a minimum finding algorithm find the minimum swap its element with the element that in the first slot, right and then repeat this and -1 *  Let's look at how this looks in a pseudocode. Okay, so I like to call this more like a mid-level pseudocode because I'm replacing some of like the mundane.  operations with sort of subroutines for example  I'm just going to take it to that. Everybody knows how to code up this algorithm. How do you find the minimum? Right? You just kind of run this running thing and it keep updating at once you find a smaller element, right? So I'm just going to replace it with minimum and also interchange a and a inam well,  Kind of depends on what computer program you're looking at how to do this the most efficiently, but in either case the end result is I'm going to be interchanging these two values.  Okay, so  I have my for loop from I 2 from 1 2 N -1 and you find the minimum of the last and minus I and then you interchange them. Here's more of like a lower-level pseudocode which to me is just like  kind of  takes time to understand for me at least cuz you have to keep track of all the indices and there's like, okay, what are you doing here what's going on? But if you if you break it down, you can just see that this whole part here.  Is to find the minimum.  Sorry.  Yeah.  Oh.  So if you look at the input, you see that it starts at A1A to all the way up to a n. Sorry. I have it on two lines. A1822 a n  and I apologize. I'm  Psych in mathematics, we always start at 1 and I know in computer science you always start at zero.  Why is that?  It's just a convention.  Well, so yeah. Yeah, I guess you're just going to have to get used to it cuz this is going to be how we're we're looking at it.  A good question. So when I say start from 1 to go up 2 N -1, I mean start from one meeting one is the first position and then go to the end - 1st position any other questions about that?  Guess that might be confusing for you guys moving for it. So sometimes it's nice to kind of group those things together when it's such a mundane easy.  Okay, let's look at how it works on this example.  so  The first thing you do is you find the minimum element and how are you going to do that? You kind of just keep on going until and keep on updating, right? So we won't we won't go through that every time just to give you an idea. So we find the minimum element is 1  So what we do is we take one and we replace it or we swap it with 15128. 313-2312.  Okay.  O15. Thank you.  Then the next thing you do is well, you kind of want to lock this one in since it's the smallest element. Anyway, you never ever want to touch it again. We want to keep it there then find the next smallest element, which is 2 and swap it with the second element.  and then you lock in one into  and so on guys kind of get the idea.  So here's another sort of.  Figure that that you can see it happen throughout the whole thing. So you can kind of look at it see how it works.  Knights the first element has 17 you swallow with 54 and as you go you can see that these elements are going to start to be fixed.  right  And that's going to be important.  because at the end  they should all be in order.  Okay, let's look at another one bubble sort.  What happened with that?  Okay. So this is one way to describe bubble sort compare. The first two cards answer you think about like your names are on cards. If the first is bigger keep comparing it to the next card in the stack until you find a larger one. And then when it's larger start comparing that one repeat until the stack is sorted kind of works.  In a different way, let's see what the pseudocode looks like.  Now this one it's hard to come up with like a mid-level pseudocode cuz it's already pretty simple. You just kind of have this double Loop or The Loop the first live goes from 1 2 N -1 and the second Loop goes from 1 to n minus. I Okay, then if the  if the consecutive numbers if AJ is bigger than AJ plus one than interchange them.  So we're going to look at it example, but you can see it's sort of like in the biggest numbers are bubbling up to the top. Okay, and so at the end of the first iteration, you'll see that the highest numbers at the top in the next highest in the next time.  Yes, so let's I'm going to answer that question with the previous algorithm just because we have an example for it, right so.  Once once I've once I've taken care of the the second to last element 77, I don't have to worry about the element because it's it's already necessarily the biggest and that's sort of the same idea of the other one, too.  Is there an element's?  So let's look at this example.  Okay. So what you do is where's my I guess I'll start here. So I starts at 1 and Jay goes from 1 to n minus. I so in the first iteration it goes from 1 to n -1. Okay, and what it does is it kind of swaps these elements and moves along? No queso.  It looks first looks at 16 and 12.  Right is AJ. Let's AJ is equal to one is a 1 bigger than a to. Yes, so you swap them.  Okay, then the next thing you do is.  Look at the next two numbers and if it's bigger than you swap them, right 12 for 1617 1324 2023. Okay, then you look at the next two elements and since 16 is less than 17 you don't swap it.  You get 12 for 1617 1324 2023 and then you look at 17 and 13 and you swap those as you go along? Okay, so you do that all the way through.  The next time you do it you do it again, but you only go to the second to last place, right? And then the third to last fourth the last and then you keep on doing that over and over again.  Here's here's a here's another sort of example.  SO3 is less than 6 so you keep it 6 is greater than 1 so you swap those six is greater than for that so you swap those and it's 6 is greater than 2 so you swap and what's going to happen. It may not be perfectly clear at this point. But we're going to talk about it a little bit later is that at the end of the first iteration? The biggest number is all the way to the right? Okay. It's at the end. It's in his right positions in correct position and that's why it's bubble sore is because the biggest number is going to Bubble Up To The Top  I guess because it's the biggest bubble.  the lightest density  I feel like at 8 would float better because I've got those two holes, you know.  Huh?  bigger bubbles float faster than  Oh because there was a big hole big bubble.  I don't know bigger numbers bigger numbers bubble up. Let's just go in that.  Okay, so then yeah, so that one goes all the way there. You got the six and then this one.  We didn't do all the comparisons, but then you get the for the three and then the two and then you're done. Okay any questions about that?  Okay, how about this one insertion sort?  Pass the cards from right to left each individual and starting their own card into the correct position as they relayed the pile So This Groove actually used like everybody as part of the process actually this this might be something that you could do for the whole class, right? You can kind of just keep on passing the pile but the last person is going to do the most work, right because the last person have to look through their pile to figure out where the name is, but at least the pilot he's given is in sorted order. Does that help right if his name is starts with  And is and the middle number?  LOL, yeah, that's name starts with an L.  But maybe there's like more.  I don't know.  Maybe the letters aren't distribute. Anyhow. Yeah, you can kind of find it. Okay, so put another way take an element of a and find out where it belongs relative to the elements before it shift everything back to make room and put the element in his proper place. Okay, so I actually how does a computer do it. You kind of have to take your array, right? If you want to insert something you're going to have to move everything over to create a spot for it.  Now this element has been inserted where it belongs to the same for the next element.  Okay, here's here's a mid-level description.  So now now instead of going from 1 2 N -1. This one goes from 2 to n.  And the idea is because the first element in the list if you just look at it by itself. It's already in sorted order.  If you really only start to figure out the sorted order when you get the second element, so when you get the second element, you kind of you make sure it's in the right order with the first element when you get the third element, you put it in the order of the first two when you get the fourth you find it in the order of the first three and so on.  was that  yeah, there's not what you guys did it kind of.  Yeah.  Okay, this nightmare is the low-level pseudocode.  Okay, I mean looking at it is maddening at least for me. Maybe you guys are more attuned to what this is doing, but essentially  This thing here is finding.  where to put it  and then this bit here is  this is just like the  shifting things over to make room  Let's look at an example. So basically you just start with the first element 13 and you put that sub list in sorted order. It's already in order. So we're fine. Then you introduce the six.  Until you put it in front of the 13, right?  Then you introduce the 19 so you put that at the end.  Can you introduce the two and really what the computers going to have to do is shift everybody over to make place for the 2 to put in the front?  Yeah.  Right. So it all depends depends on what sort of thing you're using. But the idea is the same either way.  And then you have 17 so that goes in between 13 and 19. So you put it in there.  And you have three?  Oh, I've missed the sex. Sorry 16 1317 I missed it. And then this the 16 again that was from the other example.  You guys get the idea?  Okay, so then you're done great easy.  Getting this is nice because as you're doing it, these elements are all guaranteed to be in sorted order as you go. So like maybe you get interrupted. This one is at least like making your way there you can kind of hand your boss the first part of the listen sale at least these ones are sorted. Okay. This is kind of what you guys were talking about. You make little ranges for the numbers and you put them all in the buckets and then depending on how many things are in the buckets that you use some sort of other sorting algorithm to sort within the buckets.  Pseudo pseudo code crate empty buckets put the buckets in the list in the correct button start with E to fucking concatenate the buckets in order.  Okay, then there's merge sort. This one is what you guys did right? And this is how we're going to present it you split into two groups and organization of the group's then we get back together and figured out how to enter leave the groups in order. So you've split into two groups and organized the groups.  How did you do that? Well?  You merge sort them.  Right, you sort them with the same algorithm. So this is a recursive algorithm. Where are you? Split it up into two groups.  You merge few. You sort them with the actual algorithm. And then you enter leave them. Put it back together.  So here's the pseudocode former store. Okay, if the list has just one element, then you're done. You don't have to do anything otherwise divided into two pieces and  Split into half as best as you can.  then  merge sort one side of the list and merge sort the other side of the list.  Right and then put them back together merge, the two sorted lists. We're going to talk about this sorting algorithm in more detail a little bit later. Just wanted to give you kind of the way that that we're going to present in this class questions.  was that  So it doesn't the it doesn't matter actually how you split the list.  This will work either way, but if it's odd that you just split it so that one one list has one more element the other you want to listen to happy as possible so you can get the best run time.  I don't know. I don't know.  Will bubble sort think about this is like the main difference. I see bubble sort is like you got to kind of go through the list a bunch of times right? This one is you just split it up and let the algorithm do the work on each side and then you put it together. So it's sort of like this one's like more Magic.  Or at least you just have to have faith in your algorithm that it works and then it puts together. I don't know if anybody knows what that is short.  because quicksort you sort of like unravel the  the list and then you just stick it back together. Where is merge sort you kind of break up the list sort them and then kind of interleaf.  We'll talk about that a little later.  Okay, here's some others BOGO sort. Has anybody heard of that before?  Buy one get one. No, it's where you randomly arranged the elements and then you check to see if it's in sorted order. And if it's not then you repeat.  Did anybody try that one when you were sorting?  How how long do you have to wait till that one works?  n factorial  Wisconsin time if you're very lucky.  yes, best case scenario constant time worst case scenario and factorial  or  Well, if that's the case, then I would say expected run time and factorial.  Yeah, we'll talk more about that to expected value.  Okay, then there's quicksort which I kind of talked about. But did you guys say you used quicksort?  So you take one of the elements at random and you kind of use it as a pivot and put everything to the right everything bigger to the right and everything smaller to the left.  Then just like merge sort you recursively sort each side with quick sort and then you just stick them together because you know, all of these are bigger than all of these. We just put them back together.  Binary search tree traversal. Did you guys see that?  It's a good one.  So there's a bunch of sorting algorithms even more than what we're going to go over. Okay? Why are we talkin about so many algorithms? Well, first of all,  They're going to be good practice for your homework questions and your exam questions, but also job interviews and stuff like that. If you ever do any kind of technical job interview, sometimes they ask you algorithm questions and it's good to know. What kind of sorting algorithms you need some algorithms are better than others.  And what do I mean by better? Well  Does it use more memory does it is it more efficient with time? Is it better for certain types of data, like four integers or four strings are for this or for that? Is it better if you know that the set is already kind of sordid and you just need to kind of clean it up or is it better if if you know that the that the elements are in a certain range, right? So if you know something about the data you can get you can maybe get an advantage on some of these things.  questions about that  Okay, so let's talk about from how to why all those things I showed you you say. Oh, that's nice that sorts the list because I showed you one example. Okay, you guys got to start thinking about how does it work on all inputs? Is it going to work every time on all inputs? Okay. So that's where we're going to talk about the correctness proof the proof of correctness, and we're going to start off by looking at something called a loop invariant. Okay. So the for these loop-based algorithms  What happens after every iteration? Okay, how we make progress to the end? You saw from all those examples that every one of those sorting algorithm. We were making progress as we went along we kept on every iteration we kept on adding a new thing there and in at the end of this was all the way sorted.  Okay, so what is a loop invariant?  In means not variant means changing.  And I think it is that Latin or Greek.  Same same time invariant means not changing Loop not changing. What is the thing that stays true or does not change as you go through the iterations of  So I'll Loop invariant does a property that remains true after each time. The body of the loop is executed. So at for an iterative algorithm like this, how do you prove the correctness you look for a loop invariant and you state it precisely.  You proved that is invariant.  Guess how we're going to prove it.  Induction exactly induction happens to be the best tool for looping variance. Why is because if it stays true after however many iterations then it's got to stay true for the next iteration. And so that's exactly the type of structure of a proof that you want.  Okay, so prove that the invariant is true. That's part 2 don't forget about part 3.  You still have to kind of figure out why does the loop invariant?  Imply that the algorithm is correct.  questions about that  alright, so  let's go back to selection sort.  So I want you guys to take a few minutes talk it over with your neighbor come up with a loop invariant for selection store. Okay, you want me to put up the example? It might be a might be helpful and I'll and I'll kind of give you a hint of how to start your Loop invariant it often starts something like this.  after t theater Asians  What is true?  about  the list  Ready go.  okay, here's another hint You might want to use the letter T in your  in what in the loop invariant may be off in time to Loop invariant you say after so many iterations. The property is based on however many iterations you've been through.  Are you guys drinking?  We're planning on what we're going to do Wednesday.  knowledge  I would  Starbucks  I realize he did a  that's fine.  Oh, that is just a  Try it kind of blocked out what I said there anybody have a loop invariant.  Master tea iterations  Hey 1 through 80.  is sorted  right if you think about it as like a as like a sequence, right?  Good you guys have that understand basically after one iteration. The first element is sorted, of course after to iteration the first two elements are sorted and so on.  What I was thinking was that like after T iteration. We've done a total of cheetahs cheapest One Compares inside of the year that include comparing and to the left that's not part of the story part.  Lifesaver example to pick the second number, you know, you have to compare it with the first number if you pick the third number, you know, if you're looking for the third time, you have to compare it with the two numbers on the left, right? Okay. So we're going to talk about that when we talk about run time. So that's not really a loop invariant. I guess it is because it's true after every iteration and that would be helpful when we start talking about run time.  You mean the algorithm stops after Anna durations?  Actually, that's that's good. That's important. I'm going to write it up here.  algorithm  stop  after and iterations  This is important. This is actually the step 3 in my three-step process because you're going to say okay this Loop invariant is true after every iteration. So it must be true after and iterations which means after Generations a 1 through a n is sorted and that's what I wanted. So that's actually kind of going forward.  Cuz it's another loop invariant that's actually important for the for approving this correct.  Hey buddy, have a another one.  Okay, good. So  So this will be one and two will be.  Two will be after.  t iterations  a 1 through 80  are all  How you want to say it are the smallest?  Are the T smallest?  elements  right  So they're sorted and they're the smallest so you can see back here write 17 is the smallest 17 and 20 or smaller than 17 through 26 or smaller than the rest and so on.  Okay, so  let's just go with our conclusion.  So we're going to we're probably going to prove it on Wednesday, but I just want to kind of jump to the conclusion because if if you guys believe these Loop invariants, how do you show that the algorithm actually works based upon them you say  Do I best conclusion?  conclusion conclusion  after n iterations  A1 through a n  are sorted  and just for fun, we can also say  And are the N smallest?  But that doesn't really make much difference because it's just all of the things right the end smallest.  Okay. So next time we're going to prove prove the loop invariant for this algorithm. And then once you did that, everything else will fall into place cuz we've already made our conclusion here.  Okay, so you guys want to end a little bit early today?  Okay. Thank you for your participation.  UC San Diego podcast "
}