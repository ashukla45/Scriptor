{
    "Blurbs": {
        "+ 2K? I'll give you guys maybe two minutes. Why don't you try to evaluate this algebraically? Okay ready to go? All right. What did you guys get? anybody 2 to the end to the end plus 2K like that. wait, what happened to the Okay, Alex. Let's try that out. So it this is 2 to the K log 2 of n / k +. Went to the log ": [
            763.0,
            912.8,
            19
        ],
        "3 and 4 and now that gives you a configuration and you're guaranteed to have a night in each Castle because of the way you set it up, so I'll be all so nice shoes for Okay. Okay question. Like a 01 as like a single thing. Yeah, I think I think you could argue it that way, too. Okay good. So how about if I had K castles in ": [
            2604.7,
            2667.1,
            59
        ],
        "Big O and big Omega imply? Okay, so that gives you a sense. Of how big this is it's in between these two numbers any questions about that. Okay, so let's switch gears a little bit. We're going to start off with something things that we've seen before, but I want us to kind of Address it from the sort of new idea of thinking bijective Lee what it is. ": [
            1206.6,
            1246.0,
            26
        ],
        "Good. We're going to just jump on the bandwagon here. We're going to come back to this. Okay? I'll show you what the right answer is when we come back. Okay, so there's a great way to solve this problem. But we need to use a very simple bijection. Okay, but we're going to do is we're going to create a bijection between these configurations and fix density 7 bit ": [
            1824.2,
            1862.0,
            41
        ],
        "I don't know. But anyhow, you get the idea. That makes sense. So then this would be the last one in the binary order of the biggest cuz you can just think lexicographic ordering is the same as ordering of integers by their size So that's the biggest string on the list. just the biggest but I wanted to introduce it this way because I know you don't I'm not ": [
            3846.3,
            3881.3,
            88
        ],
        "I had five castles and 10 soldiers. Now how many different configurations are there? Okay good. salt remember the bars divide the castles from each other. So if there are five castles, there's got to be Ford of dividers. Can I make sense? questions about that Okay, here's another exercise. Same kind of thing. I have five castles in 10 soldiers which binary string would this configuration map to? Okay, ": [
            2172.4,
            2252.9,
            50
        ],
        "I kind of wanted to get. Okay, so there's a bijection f between the K element subsets of a set of n elements. Okay. I'm going to call that s7k. To the length and binary strings with exactly K ones. Let's call that be of NK. Okay, so a bijection between them. write f SNK to B&K it should map every element from SNK to a different element of B&K ": [
            1601.4,
            1641.6,
            36
        ],
        "I make a mistake? Okay, wait, so. The number of boxes is oh, you're right. Oh my God. right Nope. Sorry, I did it wrong again. Why is that we had it. Okay, wait this why don't why don't I just use n&k like I had here. Okay, so you have The balls and balls and then x -1. Yeah, you need that many dividers now this one you have ": [
            3335.6,
            3407.8,
            76
        ],
        "Listen to a podcast. All right, what's going on everyone? Thanks for coming. so Long weekend this weekend. Next time I see you after this class will be during the quiz on next Tuesday. So there's like some practice problems any questions about it before we begin? Yeah, same general link to the topics are really just kind of like iterative algorithms and recursive algorithms and how to analyze then ": [
            1.9,
            64.6,
            0
        ],
        "N soldiers and I wanted to put at least one soldier in each castle and fill in all fill them up after that. Well, if you think about it this way. If there are any soldiers, there's and minus one kind of vacancies, but between them and if they're right you want to put K - 1 bars to separate. That's where you got and -1 choose K - 1. ": [
            2667.1,
            2701.0,
            60
        ],
        "No, not really. Maybe like the Big O is like kind of the thing that's going to carry over but it's going to be more related to how it how you do run time analysis on outer like the master theorem recurrence is counting Counting comparisons and stuff Okay. So today we're going to finish up that and coding that weird window and coding algorithm and we're going to get ": [
            98.5,
            136.6,
            2
        ],
        "No. from 20 one to one and onto right? So I guess I should put that in a sleeve a bijection. Well, but I'll get to that in a minute. Let's let's let's answer this question. First how many 3 element subsets of 1 2 3 4 5 are there? This was one of the ways that we defined what the 5 choose 3 means write any questions about that. ": [
            1249.7,
            1292.8,
            27
        ],
        "Okay, what other types of objects does 5 2-3 count? exactly strings of length 5 with exactly three ones Okay, so where's my mouse? so that's what I want to show you guys with this bijective counting is that So I guess let's just say it like this 3 is equal to 10. So here are the 10. Hear our ears the set of all 1003 element subsets of 1 ": [
            1295.7,
            1350.3,
            28
        ],
        "San Diego podcast? ": [
            4409.1,
            4410.1,
            100
        ],
        "So if the without restrictions you get n + K - 1 choose K - 1 and width restrictions. Write at least one soldier. That's this one. okay, stop I mean Good to kind of learn how to do this. But also it's it's going to be helpful to sort of recognize when when you need to use this type of counting technique or when you need to use a ": [
            2709.3,
            2740.0,
            61
        ],
        "So we'll go back to encoding and we're going to use it to get the optimal number of bits needed to encode a certain type of object. Okay, so I theoretically optimal encoding Of length and binary strings with K ones would use the ceiling of log base 2 of n choose K fits right? Remember this is what we tried to encode before using the window and code and ": [
            3550.3,
            3580.0,
            80
        ],
        "UK ones. any questions or a clock All right, we all jumping on the bandwagon here. Anybody have a explanation for sea? Her window so arrogant. Okay good cell in each window of size n / K. You can put the one in any Andover Cay positions. So for this window, there's an over K-pop abilities X Andover Cay possibilities for that window times and so on. Can I sequel ": [
            1081.9,
            1177.4,
            24
        ],
        "Wait, shouldn't this is this this one's wrong to then, isn't it? This one should be cnx. my God now this one's X and all right, cuz out of all the boxes you're choosing and of them. And then this one is you have X castles, right? So you are choosing x minus one of them. And you have and -1 positions. That's what okay. That should be good. Sorry ": [
            3415.0,
            3459.8,
            77
        ],
        "What is 3 to the 5? 243 Okay now. What If instead we have to place five indistinguishable soldiers into the three different kinds So now it doesn't really matter. Who they are it just matters how many of them are in a castle? Can I make sense? You see how the problems different now they're going to be fewer than 243. How many you guys reckon they'll be? Okay. ": [
            1749.4,
            1823.2,
            40
        ],
        "about that. It's a good exercise for everybody, right? Yes. How can you? Okay, so you have to talk about this excuse and So you're saying I have 10. 10 balls and and and five boxes. How are you going to put it? How you going to make any Arrangement where each ball has at most one each box has It's impossible. Okay. moving on all this stuff is not ": [
            3459.8,
            3517.3,
            78
        ],
        "all the strings that start with zero come before all the strings that start with one skobac. All the strings that start with zero come before all the strings that start with one. right now if I Lop off the zero. What kind of strings am i counting? thanks for with three once right So it's kind of like I've taken the big problem and reduced it down to a ": [
            4136.9,
            4183.3,
            94
        ],
        "alright, cuz you're giving them that way. and each person has at least one ball. right wait till should that be this one here? Oh you mean this it's going to be I was going to be this one Oh, maybe that is the same thing. Yeah, you're right. I don't even realize that. All right, so this is the card problem. And in general is going to be like ": [
            3130.8,
            3182.1,
            71
        ],
        "always you're not always going to be ordering strings by binary strings. You could be ordering subsets or you could be ordering strings of words for things like that. Okay, so Let's go back to the length and binary strings with exactly three ones here. They are graphic order. Okay, ready go. I'll give you a hint. The first one is zero zero one one one and the last one ": [
            3881.3,
            3932.8,
            89
        ],
        "amount so we can kind of count them in the same way. Okay, so consider some random configuration. Remember it doesn't matter. Who who who all that really matters. Is that how many nights are in each Castle? Okay. So this right this has a two nights here one night here in two nights here. Okay. So the the bijection is the first thing you do. Is you put a ": [
            1892.9,
            1924.5,
            43
        ],
        "and I'm going to count the subset where there's exactly one 1 in each one of those windows. So how many such strings are there? KDs I'll just give you another idea each one of these is length and over k. Right and there are Okay, if that right because K times a number K is equal to end. Exactly one one in each one of them so that gives ": [
            1047.9,
            1081.9,
            23
        ],
        "and it should have a reasonably simple rule to map one to the other and that rule. Should also have a inverse you can go back and forth pretty easily. Okay. So for this example F inverse is well, you just take the positions of the one and put them in your subset. Okay. So now let some switch switch back to the counting that we've seen before from the ": [
            1641.6,
            1672.3,
            37
        ],
        "and it's because like you can think about the bars as the sort of separators and the stars as like the soldiers, okay. And basically you have 7 spaces to fill right and you need to choose two of those spaces to be bars. And then the other remaining thing will be Stars. In general, what does that mean? Well, if I wanted to put an indistinguishable soldiers in 2K ": [
            2059.6,
            2094.5,
            47
        ],
        "and positions. So how many zeros did we record? to and how does that relate to K, which is 3 Give me K - 1 right. It's okay the upper bound. Right and it's mostly because we we chose the window size so that there would be exactly K Windows if you just even evenly spread them out. Okay, so you have at most K bits for those zeros. Then ": [
            607.1,
            650.8,
            15
        ],
        "are in a really nice order. So they're easy to find So so the encoding and decoding is easy an easy concept to understand but it seems like it's a little waste of memory to do this right to store them all. So we're going to look at today is a way to algorithmically figure out what its position should be and also figure out given a position which string ": [
            3636.4,
            3665.5,
            83
        ],
        "asset into disjoint subsets? And that's kind of what we're doing right? We're dividing up the set of cards in two disjoint subsets that we're giving to people. I got it. Thank you. Okay, great. Okay, so that means okay. Let's go back to this one. So each box has at most one ball. You can't put two balls in a box. So basically since the balls are unlabeled, all ": [
            3219.5,
            3249.6,
            73
        ],
        "at most one Balinese box. You can't have more than one ball in each box for this one. Yes. White all the cards are labeled and all the people are labeled. That would be like another. don't be another call him here and it would be each yes, so the so in this case the people are the Balls, and the cards at the cards are the boxes. right Alright, ": [
            3054.3,
            3130.8,
            70
        ],
        "ball. I can't put it in that box anymore. So there's X - 1 and then x - 2 Okay, how about each ball has at least each box has at least one ball. Well, we're not going to this class. This has something to do with something called the Sterling numbers and we're not going to do it in this class so we can skip that we're not going ": [
            2981.3,
            3006.6,
            68
        ],
        "base 2 of Andover K raised to the K like that. Yeah, right. and then because of the log rules the band these ones cancel, right? And this is what? 4 and over K raised to the k any questions so this is this is great because now we can say that C&K which is the number of length and binary strings with K ones is less than or equal ": [
            912.8,
            990.0,
            20
        ],
        "binary strings with exactly two ones How in the world does this problem relate to that? I'm going to show you and then the rule is simple enough that you can convince yourself that for every configuration. There is a unique fixed density binary string 7 with two ones and for every one of those strings there's a unique configuration there for Thor bijection. Therefore there the there's the same ": [
            1862.0,
            1892.9,
            42
        ],
        "boxes? well think about like right EXO. How many ways are there to put one ball in Xboxes? You can choose any of the Xboxes, right? there's two balls then the second ball you can put in any of the Xboxes and so on so you get x to the end Okay, how about if each box has at most one ball? Okay, so I can't ever put two balls ": [
            2873.4,
            2920.0,
            66
        ],
        "can kind of think of aligning the nights up like this and then separating them with four bars. And that will guarantee that there's a night in each castle. And so how many vacancies are there? There's one two, three, four, five six, seven eight nine. Wait, I did this wrong tonight. I know this is there's 10 soldiers, right? So we just choose four of those vacancies 1 2 ": [
            2567.0,
            2604.7,
            58
        ],
        "different Castles, I could instead count the number of ways of ordering K - 1 bars and enstars which is the same. I mean if you just want to change bars to ones and stars two zeros, isn't that's another easy by Jackson then that's the same as counting K - 1 ones and end zeros stop which we already know how to count right? So, how do you count ": [
            2094.5,
            2128.6,
            48
        ],
        "different one. So we'll talk about that in a minute. Okay, so Okay. So these are the two things that we that we learned. Okay. Wait, this is just repeated. Okay, this is what I wanted to get to so. What we've done kind of in the first week and then what we did today was we started filling in this table is called the twelvefold way because there's 12 ": [
            2740.0,
            2776.2,
            62
        ],
        "far down plus how much farther Scotty idea Okay, so Let's see how much more we have today. All right. So I want you guys to do this. as an exercise take home. Take home exercise and key and code this find the position of this string without actually writing all of them down. And then we'll we'll kind of discuss it together on Wednesday. weekend Thanks. Can you see ": [
            4319.5,
            4409.1,
            99
        ],
        "first week. So suppose we're playing a game where we had to put different soldiers into three different Castles. Okay, so you have to put all the soldiers into the castles. You can put more than one into one of the castle. Maybe you want to put them all into Castle three, or maybe you want to put two of them in the castle 1/2 of into Castle two and ": [
            1672.3,
            1693.5,
            38
        ],
        "friends or something. Right? You've taken away the labels. So when we that's good because you see at least and you say okay. We should probably do counting by the compliment or inclusion exclusion. Good. This is a There's another way to do it. We don't have to do that. and why y9 shoes for she put his he put a zero. Okay good so we can start with. Put ": [
            2450.1,
            2512.8,
            56
        ],
        "going to be less than this polynomial. Okay, let's get a lower bound now. Okay. so in order to find a lower bound on N choose k I'm just going to count the number of elements in a certain subset. Okay, so this subset is going to be I'm going to split it up into these windows. Each of size n / k for their r k of them, right ": [
            1013.2,
            1047.9,
            22
        ],
        "good. Yeah, this one was easy, right? Okay good. So right you just kind of do the drawing 1 0 0 0 1 0 0 0 1 and then 100000 Wait, I didn't I didn't need that one. Sorry. K & A so any questions about that? Now you can kind of like I said before you certain properties of one set. You can kind of inherit into the other ": [
            2252.9,
            2307.9,
            51
        ],
        "got to one draw zero between each one of the Four Knights. So just be like that. Okay good. So now replace each soldier with a zero and put a space between the knights would want. Okay, that's what we just did. Okay, any questions about that? So you can find this in the textbook in 424. It's usually this type of problem is referred to as stars and bars ": [
            2027.6,
            2059.6,
            46
        ],
        "if I need this many bits. Or if this many bits another way to say is if this many bits is sufficient to describe every single possible string, right, then this is to to this power is an upper bound on the number of strings. Pranks that mr. Most are too many to to that Tower many set strings. So what is 2 to the K log and / k ": [
            732.8,
            763.0,
            18
        ],
        "in a box is what I'm saying. close close also You guys are both close. How can we combine those two? permutation permutation of a can What's what is this? What is this look like? This looks like x * X - 1 * x - 2 all the way down to x minus and plus one right because I have extra for my first ball pen for my second ": [
            2920.0,
            2981.3,
            67
        ],
        "in each castle at least one soldier. Frank and let's say I still have five castles in 10 soldiers. So without the Restriction we started with 14 blank spaces, right and basically chose for them to be bars for for example, and maybe these two and then this one and then that one and then these would all be stars or soldiers. But if we just do that willy-nilly we ": [
            2343.5,
            2377.8,
            53
        ],
        "in one right and so zero comes before 1 And so if I wanted to look up a certain word that started with zero, maybe this is not the best thing. Let's let's talk about just like a dictionary right? I was looking up the word. miles right and I found another word which was micro Which one comes first in the dictionary? Write what you do is you compare ": [
            3753.9,
            3803.4,
            86
        ],
        "in that list kind of like having like a an address book, right if I want to encode a certain string I look for it into in my address book. I look for what number it is in my list and I'll put that position if I want to decode a position I look for that position in my address book and I'll put the string right and the strings ": [
            3612.3,
            3636.4,
            82
        ],
        "is 11100. You guys can just do it in your head like that. Maybe I'll help you guys out. What's the next one? 01011 and then what? like that and then 1 110 Wright Weight and now I have to start at 1, right. 10011 10101 right and then one 0110 and then 11001 Wait, did I did I get off pace? And then is that it? Can I get ": [
            3932.8,
            4030.1,
            90
        ],
        "it off. Okay, so that was all this stuff and we did all that. Okay. Okay, let's think about the worst-case where they're the ones are at the end of the string which means that there's like going to be some bits that that represent the zeros in each window and then you have a bunch of ones at the end. So what's an upper bound on the number of ": [
            379.0,
            410.0,
            10
        ],
        "it's like now I start counting from 0. I really only wanted to count from zero so that I could use the position the the binary strings Actually the binary strings here don't really matter that much. It's more just like the number that actually tutor. Okay, so if I start at 0 then we know right before or after so. in general any any string that starts with 0 ": [
            4258.4,
            4296.7,
            97
        ],
        "know there's there's a finite number of ejections. no, soy mean all all bijections from from the set of three element subsets to the set of all five length binary strings with three wants N factorial cuz it's kind of like the number of ways you can order them. So there's n factorial different bijections. This is just one of them but we like this one because there's a rule ": [
            1481.4,
            1525.1,
            32
        ],
        "let's fill this out. I'm going to have an balls and Xboxes, okay? What happened balls and Xboxes? Do you want to put the balls in the boxes another way to think about it is that it's just a function from n to X. Right. It's basically for each ball. You tell me which box you put it in and that's kind of the result of the function. Okay, how ": [
            2818.6,
            2848.6,
            64
        ],
        "look by Define the window size to Andover k k is 0 then the window size is now infinity and it doesn't really make sense is not really that good in general. It only really works. Well if there are a lot more bits than there are ones. Okay, let's go back to this thing. so Let's go back to the string of length 12 again. Right? We had one ": [
            538.0,
            575.2,
            13
        ],
        "many functions are there in total if my balls and my boxes are both labeled. What do I mean by labeled? Well, maybe their label with just numbers or maybe they're all different colors. Okay. So all the boxes are labeled all the balls are labeled. How many goes in how many are there for just kind of no restrictions. How many ways can I put involved in to end ": [
            2848.6,
            2873.4,
            65
        ],
        "mapped onto the entire set. So a consequence was that they had the same set. Now I'm going to kind of go backwards and say I know that these two sets have the same cardinality. So that should be that there's a bijection that links them. Okay. So, how can I map these two binary strings? For example, what would I map 1232? What binary string? 1 binary corresponds to ": [
            1380.2,
            1415.4,
            30
        ],
        "markets position 00. Okay, then move the window over and now we have just a window full of zeros. So mark that was just a single 0 and how do you know that that single zero is not part of a position? Because we didn't put the marker bit there. You know that whenever you see him of one, you know that than the first time you see a one ": [
            267.0,
            296.7,
            7
        ],
        "might run into this situation where there's two ones together, right? And if that ever happens that means that castles empty. Okay. I want to do it in a way that none of the castles are empty. Does anybody have any ideas on how to do this? Okay, you can do that. Yes, you could do that that would definitely work. Right because the those two things correspond to each ": [
            2377.8,
            2409.6,
            54
        ],
        "minus one choose + -1 right because it's basically like putting the soldiers in the castles. And you can put as many as you want into that has no restrictions. And then this one is going to be the x minus one shoes and minus one. This is the second one where each Castle needs to have at least one soldier. x + 10 - 1 + - 1 did ": [
            3295.6,
            3335.6,
            75
        ],
        "must have position before and -1 shoes K and an E string that starts with one at must have position or after and -1 choose k And so what you do is you figure out what the first position is and then you if it's if it's a one you add that position to the recursion, right? You were curse on the remaining parts and you know, it's been that ": [
            4296.7,
            4319.5,
            98
        ],
        "not all of those bijections have such a nice rule like this. So that's kind of what we're going for is a nice rule is what we have that rule now, we can generalize it to all subsets or fix density by any restraint no matter how big or small they are and this gives you a link between the two. This is a very powerful concept because once you ": [
            1525.1,
            1549.7,
            33
        ],
        "of a think of a scenario where Okay, I'm not good at drawing a castle. Let's think of a scenario where Maybe. The second castle has one soldier. Here's a sword and shield. and maybe the third Castle has I don't know for soldiers. I'll just write. For soldiers. Okay, so now what would the what would the String B that corresponds to this. I ain't got to one. You ": [
            1974.6,
            2027.6,
            45
        ],
        "of them all then you can map one to the other because it's written there. But what I'm going to share with you is a way to actually get from one of the other kind of algorithmically so that you don't have to look it up. Okay, so Here's the idea. We're going to use recursion. Okay? the key Insight that we have to think about is in lexicographic order ": [
            4105.1,
            4134.7,
            93
        ],
        "on until they differ once they differ the one with the lower bit comes before the one with the higher bit. So if they're all the same then that means they're the same number. So which one of these comes last in Lex order lexicographic order? Okay. Good see. right Are there any questions about that? so like imagine that you had a dictionary, but the only letters were zero ": [
            3705.3,
            3753.9,
            85
        ],
        "once you're able to do something like this certain properties of one of the sets you can Kind of carry over to the other set and ask about what that means. Right? So for example, you could say something like well if there's ever two ones in a row in my binary string that corresponds to consecutive numbers in my subset and so you can kind of think about what ": [
            1549.7,
            1574.2,
            34
        ],
        "one between each Castle? Okay, then you put a zero underneath each night. So this configuration? What binary string would it map to? 0010100 So for every configuration, you can do that now going the other way. How would you do it? Well, those ones you kind of extend as like dividers between the castles and then the zeros become all the nights. Meaning are you? okay, so let's think ": [
            1924.5,
            1974.6,
            44
        ],
        "one night. in each Castle And then forget about him they're there. Then you just solved the problem of filling them up again, right? 9 nights leftover to put into 5 castles Oh, sorry. There would be five nights left over to put into five castles and that would be 9 shoes for. Picard Looks like kind of a more direct way to do it. There's another way where? You ": [
            2512.8,
            2567.0,
            57
        ],
        "one of them in the castle 3 how many different ways are there to do this? Okay, good, does anybody have a explanation? of 3 to the 5 was that Write each night has three castles that he can choose from and they're all independent of each other right doesn't matter. So, okay good. So now Let's change the problem slightly, but you're going to see a big difference. Right? ": [
            1693.5,
            1749.4,
            39
        ],
        "other. Any other ideas? Also can't start and end with one, right? Oh, okay. I'm happy that you said that because this problem is a lot like that problem where we we gave out the cards to the to your friends except for this time. You're giving out the cards but they don't have any they're all the same card. Like maybe you're just giving out index cards to your ": [
            2409.6,
            2450.1,
            55
        ],
        "part of this class. I mean you can fill it in but you kind of have to go into more into the Sterling numbers again and partitions and these kind of things that we're not going to cover. Stop just B6 and I forgot about that one up there. That's Remember that for next quarter? Okay. Now let's use this concept this bijective counting so that we can encode things. ": [
            3517.3,
            3550.3,
            79
        ],
        "point. All I really want you to see is that we're just listing them in a in a certain order and like the the bijection kind of the the naive way to think about the bijection is just to say oh well. Just look it up in the list and go to that number go to that position. It's more of just like if you had like a a list ": [
            4081.7,
            4105.1,
            92
        ],
        "run time that kind of thing. There won't be any I won't give you any design problem. So you're not going to have to come up with any other items yourself. I'll give you the algorithm and basically asked you to prove the correctness that kind of thing maybe count some comparisons, maybe some true-false questions about algorithms receive sorting algorithms runtime, maybe some Big O stuff, but basically that ": [
            64.6,
            92.4,
            1
        ],
        "set. Will you can sort of see what they mean, right? So for example, if you ever have a substring of 1-1 in your string that corresponds to an empty Castle so you can kind of think about what those properties mean in those different situations. Okay. So, let's see. Let's change it up a little bit and now I have the Restriction that I want to put a soldier ": [
            2307.9,
            2343.5,
            52
        ],
        "should be in that position. Okay, in the way to do that is to use something called lexicographic ordering. It's basically dictionary ordering and even better. If you're talking about binary strings. It's actually ordering. The less than like The Ordering of the actual numbers in binary. Okay, so Here's kind of the idea is you compare each bit starting from the left and if they're the same you move ": [
            3665.5,
            3705.3,
            84
        ],
        "smaller problem of the same nature. How about if I lock off this one? What am i counting here? Okay, so and I know we're kind of getting closer and closer to the end of class here. But what I wanted to kind of share with you here. Is that the first thing you do is you look at the first bit. Okay, so wait before we before we do ": [
            4183.3,
            4225.3,
            95
        ],
        "so that We can remind ourselves. Where's my? We can remind ourselves how it works. Okay, so so the idea here. If n is equal to 12 + K is equal to 3 are window size we make is n / K is equal to 4. Okay. Now the idea is the first window is going to be the first four elements if there is a 1u output A1, then ": [
            191.0,
            233.4,
            5
        ],
        "some results from it that are going to be able to bound us. We're out. We're going to be able to bound the binomial coefficients, which is cool because then we can figure out kind of a a rough estimate of how big they are without Computing them then going to switch gears a little bit. I guess. I don't think we're going to get the probability today. I'll probably ": [
            136.6,
            162.1,
            3
        ],
        "that in a way imply that like we are ending with a Market bit and then like the two bit that indicate the locations along. Sure. Well, we know before this encoding algorithm is dependent on knowing what n and K are. So I know that there's an bits total and I know that there are exactly K ones and so with that information you're able to kind of finish ": [
            338.1,
            379.0,
            9
        ],
        "that, let's just do something here. How many of these are there? 4 choose 3 witches for right and how many of these are there? 4 choose 2 which is 6 if my string starts with a zero, I know that I have to come before position for. Right if it's starts with the one I know has to come after or before or after. Frank Well, if my position ": [
            4225.3,
            4258.4,
            96
        ],
        "the first three 00 R1 Oh, no, we want we want we want to fix density we want. length of 5 write 3 ones the positions of the ones who would be what? There is a right and what about 2 3 4? 01110 and so on. And so this this is not the only bijection. This is just one of many bijections how many bijections are there possible? I ": [
            1415.4,
            1481.4,
            31
        ],
        "the first two they're the same. So move on compare the second to they're the same. So move on compare these now see comes before it's the same idea except for you just using ones and zeros. It kind of makes sense. So, what's the last what's the last word in the alphabet? I mean in the dictionary? zzyzx or something Is that a word? Yeah, it's like something weird. ": [
            3803.4,
            3846.3,
            87
        ],
        "the next two bits are position. Okay, so then we've taken care of those four zeros. So start on that one. we get a one and then a one one right and now we can kind of stop because we've taken care of all the ones and you can sort of see that because there are three kind of places where we marked where that one is any questions does ": [
            296.7,
            338.1,
            8
        ],
        "them all? They all line up. Yes. Okay, great. Okay, I just had him here. No big deal. Anybody have any questions. Yeah, this is a bijection. It's kind of like. It's a bijection to the integers write the integers from 0 to 9. I'm going to make a bijection from the integers to the strings. Yeah, you mean would like a rule? Yeah. Oh, okay. Yeah know at this ": [
            4030.1,
            4081.7,
            91
        ],
        "these? It's the number of bits that you need to to to record the full windows of zeros Okay, let's let's just take a look here. Okay, so I like I kind of like that. a lot of people put in because how do I get the smaller? And certainly is an upper bound right there and bit so they can't get any more of those. But there's a tighter ": [
            410.0,
            484.3,
            11
        ],
        "this big inclusion-exclusion thing. Okay, good. Thank you for that. We have seen it before we did learn it in this class. Each box guy in each person gets at least one card. So this Sterling number is basically that I just know it as Stirling numbers, but I never thought to related to that problem. Yeah, the Sterling number is basically how many ways can you divide up a ": [
            3182.1,
            3219.5,
            72
        ],
        "this? Right, but how do you do it in terms of N and K? N + K - 1 right because you're basically you have K - 1 ones and zeros. So total you have n + K - 1 bits choose what? choose K - 1 or equivalently you could go like this and + K - 1 choose an some questions about that. All right now. Let's say ": [
            2128.6,
            2172.4,
            49
        ],
        "through 5. Now. There's also like you said, there's 10 fix density binary strings with a blank 5 with exactly three ones. So what I want to do is build a bijection remember the consequence of a bijection was that the two sets of equal size. So a bijection just means that there is an output for every input. There's a different output for every input and the output you've ": [
            1350.3,
            1380.2,
            29
        ],
        "to 4 and over K race the K. So this gives us an upper bound. We know that it can't be any more than that. It also gives us a sense of how fast is going to grow right? We've already started seen this before. But with this we can say for sure that n choose K is got to be Big O of n to the K right cuz ": [
            990.0,
            1013.2,
            21
        ],
        "to Andover Cay race of the K any questions? Okay good. So now that gives us a lower bound. and with this lower bound now we can say for sure that n choose K is now big Omega of N2 the K. Right and with those to write this kind of gives us that n choose K. Is Big O of n to the K. They go Mega. What does ": [
            1177.4,
            1206.6,
            25
        ],
        "to fill them all out today. We just have a few more to fill out. Okay. How about this one right here? Now my balls are unlabeled, but my boxes are labeled. Yes. Why? Write the back of the balls are unlabeled. So it doesn't matter where they went. All that matters is which once you put them in, right? I talked to juggling and also you can only have ": [
            3006.6,
            3054.3,
            69
        ],
        "two, three, four, five six. Seven eight nine 10 11 12 Okay, and if we had we have one two, three, four, five seven eight nine and then we had the rest ones right? So really what we're looking at is A window here. So that would be a 0 a window here. That would be a 0 and then we have to fill this window in with like markers ": [
            575.2,
            607.1,
            14
        ],
        "types of properties transfer over and what do they mean? This is kind of like a lot of the stuff that I was doing when I was a grad student. So that's why I'm so excited about it. Anyhow. So this is sort of review of what a bijection is. But so what let's just kind of go over this briefly and then we'll go on to the next what ": [
            1574.2,
            1601.4,
            35
        ],
        "upper bound. Let me give you kind of a reason for what for why it is. well If you just if you have if n is equal to like say 20 and K is equal to 0 there's only one string that it could possibly be. I mean Yeah, maybe the empty string. Or 0 to represent it all but this algorithm wouldn't really work. So well because if you ": [
            484.3,
            538.0,
            12
        ],
        "vacancies. Okay. So the the idea here is we figure out how to count every single possible combination of putting soldiers in castles or pudding or giving cards two players or what are the other kind of things we counted. I don't know making up Mario characters. I mean Nintendo characters this kind of thing. So just to generalize it. We're going to think about putting balls into boxes. So ": [
            2776.2,
            2818.6,
            63
        ],
        "wait until next Wednesday to start that so. But we're going to after that. We're going to kind of shift gears a little bit and talk about another kind of counting technique and then tie that into another type of encoding technique. So we'll see how that goes. All right, so let's start so do you guys remember this window and coding we're just going to go through it quickly ": [
            162.1,
            191.0,
            4
        ],
        "we saw that the number of bits we use kind of ranged a bunch but we want to do is use the optimal number of bits. So no more than log base 2 of n choose k So, how do we do it is very simple in concept. You list all of the all of the possible strings. in a certain order and then you encode them by their position ": [
            3580.0,
            3612.3,
            81
        ],
        "we're really doing is choosing a selection of boxes right choosing Xboxes out of the end and that should be exercising. Chips are choosing Xboxes and of the Xboxes. Sorry, I kind of got a little mixed around there. Okay. These are the two that we learn today. Okay, so This one is going to be the first thing we learned which was a n. Excuse me. X plus and ": [
            3249.6,
            3295.6,
            74
        ],
        "you got k + K for the zeros + K for the ones? Plus que log Andover Cay for the positions. Okay. So this is the worst case. This is how many bits you got to use. So that means for any string. The size of the encoded the encoded string is going to be K log and / k + 2K. What did I ask if that? Okay, so ": [
            684.3,
            729.2,
            17
        ],
        "you have one bit for each one. To indicate the marker bit and you have log base 2 of n / K bits for each position right for each. Time you record the position. Because the window is of size and over K. So you need at least log base 2 of end over K bit to record the position. Okay, and then you have there are K ones. So ": [
            650.8,
            684.3,
            16
        ],
        "you output the position of this one in those for so We're going to Mark the positions as 0 0 0 1 1 0 and 1 1. So that one is in position 01. Okay, then we're done with that. So then we move the window to be right after the one we just counted that we just marked. Then we have another one. Give a marker bit and then ": [
            233.4,
            267.0,
            6
        ]
    },
    "File Name": "Mathematics for Algorithms and Systems - B00 - Jones, Miles E - Winter 2019-lecture_11.flac",
    "Full Transcript": "Listen to a podcast.  All right, what's going on everyone? Thanks for coming.  so  Long weekend this weekend. Next time I see you after this class will be during the quiz on next Tuesday. So there's like some  practice problems  any questions about it before we begin?  Yeah, same general link to the topics are really just kind of like iterative algorithms and recursive algorithms and how to analyze then run time that kind of thing. There won't be any I won't give you any design problem. So you're not going to have to come up with any other items yourself. I'll give you the algorithm and basically asked you to prove the correctness that kind of thing maybe count some comparisons, maybe some true-false questions about algorithms receive sorting algorithms runtime, maybe some Big O stuff, but basically that  No, not really. Maybe like the Big O is like kind of the thing that's going to carry over but it's going to be more related to how it how you do run time analysis on outer like the master theorem recurrence is  counting Counting comparisons and stuff  Okay. So today we're going to finish up that and coding that weird window and coding algorithm and we're going to get some results from it that are going to be able to bound us. We're out. We're going to be able to bound the binomial coefficients, which is cool because then we can figure out kind of a a rough estimate of how big they are without Computing them then going to switch gears a little bit. I guess. I don't think we're going to get the probability today.  I'll probably wait until next Wednesday to start that so.  But we're going to after that. We're going to kind of shift gears a little bit and talk about another kind of counting technique and then tie that into another type of encoding technique. So we'll see how that goes. All right, so let's start  so do you guys remember this window and coding we're just going to go through it quickly so that  We can remind ourselves.  Where's my?  We can remind ourselves how it works. Okay, so  so the idea here.  If n is equal to 12 + K is equal to 3 are window size we make is n / K is equal to 4. Okay. Now the idea is the first window is going to be the first four elements if there is a 1u output A1, then you output the position of this one in those for so  We're going to Mark the positions as 0 0 0 1 1 0 and 1 1.  So that one is in position 01.  Okay, then we're done with that.  So then we move the window to be right after the one we just counted that we just marked.  Then we have another one.  Give a marker bit and then markets position 00.  Okay, then move the window over and now we have just a window full of zeros.  So mark that was just a single 0 and how do you know that that single zero is not part of a position?  Because we didn't put the marker bit there. You know that whenever you see him of one, you know that than the first time you see a one the next two bits are position.  Okay, so then we've taken care of those four zeros.  So start on that one.  we get a one and then a one one right and now we can kind of stop because we've taken care of all the ones and you can sort of see that because there are three kind of  places where we marked where that one is any questions  does that in a way imply that like we are ending with a  Market bit and then like the two bit that indicate the locations along.  Sure.  Well, we know before this encoding algorithm is dependent on knowing what n and K are.  So I know that there's an bits total and I know that there are exactly K ones and so with that information you're able to kind of finish it off.  Okay, so that was all this stuff and we did all that.  Okay.  Okay, let's think about the worst-case where they're the ones are at the end of the string which means that there's like going to be some bits that that represent the zeros in each window and then you have a bunch of ones at the end.  So what's an upper bound on the number of these?  It's  the number of bits that you need to to  to record the full windows of zeros  Okay, let's let's just take a look here.  Okay, so I like I kind of like that.  a lot of people put in  because  how do I get the smaller?  And certainly is an upper bound right there and bit so they can't get any more of those.  But there's a tighter upper bound.  Let me give you kind of a reason for what for why it is.  well  If you just if you have if n is equal to like say 20 and K is equal to 0 there's only one string that it could possibly be.  I mean  Yeah, maybe the empty string.  Or 0 to represent it all but this algorithm wouldn't really work. So well because if you look by Define the window size to Andover k k is 0 then the window size is now infinity and it doesn't really make sense is not really that good in general. It only really works. Well if there are a lot more bits than there are ones.  Okay, let's go back to this thing.  so  Let's go back to the string of length 12 again. Right? We had one two, three, four, five six. Seven eight nine 10 11 12  Okay, and if we had we have one two, three, four, five seven eight nine and then we had the rest ones right? So really what we're looking at is  A window here. So that would be a 0 a window here. That would be a 0 and then we have to fill this window in with like markers and positions.  So how many zeros did we record?  to and how does that relate to K, which is 3  Give me K - 1 right. It's okay the upper bound.  Right and it's mostly because we we chose the window size so that there would be exactly K Windows if you just even evenly spread them out.  Okay, so you have at most K bits for those zeros.  Then you have one bit for each one.  To indicate the marker bit and you have log base 2 of n / K bits for each position right for each.  Time you record the position.  Because the window is of size and over K. So you need at least log base 2 of end over K bit to record the position.  Okay, and then you have  there are K ones.  So you got k + K for the zeros + K for the ones?  Plus que log Andover Cay for the positions. Okay. So this is the worst case. This is how many bits you got to use.  So that means for any string.  The size of the encoded the encoded string is going to be K log and / k + 2K.  What did I ask if that?  Okay, so  if I need this many bits.  Or if this many bits another way to say is if this many bits is sufficient to describe every single possible string, right, then this is to to this power is an upper bound on the number of strings.  Pranks that mr. Most are too many to to that Tower many set strings. So what is 2 to the K log and / k + 2K?  I'll give you guys maybe two minutes. Why don't you try to evaluate this algebraically? Okay ready to go?  All right. What did you guys get?  anybody  2 to the end to the end plus 2K like that.  wait, what happened to the  Okay, Alex. Let's try that out. So it this is 2 to the K log 2 of n / k +.  Went to the log base 2 of Andover K raised to the K like that.  Yeah, right.  and then  because of the log rules  the band these ones cancel, right?  And this is what?  4 and over K raised to the k  any questions  so this is this is great because now  we can say that C&K which is the number of length and binary strings with K ones is less than or equal to 4 and over K race the K. So this gives us an upper bound. We know that it can't be any more than that. It also gives us a sense of how fast is going to grow right? We've already started seen this before.  But with this we can say for sure that n choose K is got to be Big O of n to the K right cuz going to be less than this polynomial.  Okay, let's get a lower bound now.  Okay.  so  in order to find a lower bound on N choose k  I'm just going to count the number of elements in a certain subset. Okay, so this subset is going to be I'm going to split it up into these windows.  Each of size n / k for their r k of them, right and I'm going to count the subset where there's exactly one 1 in each one of those windows. So how many such strings are there?  KDs I'll just give you another idea each one of these is length and over k.  Right and there are  Okay, if that right because K times a number K is equal to end. Exactly one one in each one of them so that gives UK ones.  any questions or  a clock  All right, we all jumping on the bandwagon here.  Anybody have a explanation for sea?  Her window so arrogant. Okay good cell in each window of size n / K. You can put the one in any Andover Cay positions. So for this window, there's an over K-pop abilities X Andover Cay possibilities for that window times and so on.  Can I sequel to Andover Cay race of the K any questions?  Okay good. So now that gives us a lower bound.  and with this lower bound  now we can say for sure that n choose K is now big Omega of N2 the K. Right and with those to write this kind of gives us that n choose K. Is Big O of n to the K. They go Mega. What does Big O and big Omega imply?  Okay, so that gives you a sense.  Of how big this is it's in between these two numbers any questions about that.  Okay, so let's switch gears a little bit. We're going to  start off with something things that we've seen before, but I want us to kind of  Address it from the sort of new idea of thinking bijective Lee what it is.  No.  from 20  one to one and onto right?  So I guess I should put that in a sleeve a bijection.  Well, but I'll get to that in a minute. Let's let's let's answer this question. First how many 3 element subsets of 1 2 3 4 5 are there?  This was one of the ways that we defined what the 5 choose 3 means write any questions about that.  Okay, what other types of objects does 5 2-3 count?  exactly strings of length 5 with exactly three ones  Okay, so  where's my mouse?  so that's what I want to show you guys with this bijective counting is that  So I guess let's just say it like this 3 is equal to 10. So here are the 10.  Hear our ears the set of all 1003 element subsets of 1 through 5. Now. There's also like you said, there's 10 fix density binary strings with a blank 5 with exactly three ones. So what I want to do is build a bijection remember the consequence of a bijection was that the two sets of equal size.  So a bijection just means that there is an output for every input. There's a different output for every input and the output you've mapped onto the entire set.  So a consequence was that they had the same set. Now I'm going to kind of go backwards and say I know that these two sets have the same cardinality.  So that should be that there's a bijection that links them. Okay.  So, how can I map these two binary strings? For example, what would I map 1232? What binary string?  1 binary corresponds to the first three  00 R1  Oh, no, we want we want we want to fix density we want.  length of 5  write 3 ones the positions of the ones who would be what?  There is a right and what about 2 3 4?  01110 and so on.  And so this this is not the only bijection. This is just one of many bijections how many bijections are there possible?  I know there's there's a finite number of ejections.  no, soy mean all all bijections from from the set of three element subsets to the set of all five length binary strings with three wants  N factorial cuz it's kind of like the number of ways you can order them.  So there's n factorial different bijections. This is just one of them but we like this one because there's a rule not all of those bijections have such a nice rule like this. So that's kind of what we're going for is a nice rule is what we have that rule now, we can generalize it to all subsets or fix density by any restraint no matter how big or small they are and this gives you a link between the two. This is a very powerful concept because once you once you're able to do something like this certain properties of one of the sets you can  Kind of carry over to the other set and ask about what that means. Right? So for example, you could say something like well if there's ever two ones in a row in my binary string that corresponds to consecutive numbers in my subset and so you can kind of think about what types of properties transfer over and what do they mean?  This is kind of like a lot of the stuff that I was doing when I was a grad student. So that's why I'm so excited about it. Anyhow.  So this is sort of review of what a bijection is. But so what let's just kind of go over this briefly and then we'll go on to the next what I kind of wanted to get. Okay, so there's a bijection f between the K element subsets of a set of n elements. Okay. I'm going to call that s7k.  To the length and binary strings with exactly K ones. Let's call that be of NK.  Okay, so a bijection between them.  write f  SNK to B&K  it should map every element from SNK to a different element of B&K and it should have a reasonably simple rule to map one to the other and that rule.  Should also have a inverse you can go back and forth pretty easily.  Okay. So for this example F inverse is well, you just take the positions of the one and put them in your subset.  Okay. So now let some switch switch back to the counting that we've seen before from the first week.  So suppose we're playing a game where we had to put different soldiers into three different Castles. Okay, so you have to put all the soldiers into the castles. You can put more than one into one of the castle. Maybe you want to put them all into Castle three, or maybe you want to put two of them in the castle 1/2 of into Castle two and one of them in the castle 3 how many different ways are there to do this?  Okay, good, does anybody have a explanation?  of 3 to the 5  was that  Write each night has three castles that he can choose from and they're all independent of each other right doesn't matter. So, okay good.  So now  Let's change the problem slightly, but you're going to see a big difference. Right? What is 3 to the 5?  243  Okay now.  What If instead we have to place five indistinguishable soldiers into the three different kinds  So now it doesn't really matter.  Who they are it just matters how many of them are in a castle?  Can I make sense?  You see how the problems different now they're going to be fewer than 243.  How many you guys reckon they'll be?  Okay.  Good. We're going to just jump on the bandwagon here.  We're going to come back to this. Okay?  I'll show you what the right answer is when we come back. Okay, so there's a great way to solve this problem. But we need to use a very simple bijection. Okay, but we're going to do is we're going to create a bijection between these configurations and  fix density 7 bit binary strings with exactly two ones  How in the world does this problem relate to that?  I'm going to show you and then the rule is simple enough that you can convince yourself that for every configuration. There is a unique fixed density binary string 7 with two ones and for every one of those strings there's a unique configuration there for Thor bijection. Therefore there the there's the same amount so we can kind of count them in the same way.  Okay, so consider some random configuration. Remember it doesn't matter. Who who who all that really matters. Is that how many nights are in each Castle?  Okay. So this right this has a two nights here one night here in two nights here. Okay. So the the bijection is  the first thing you do.  Is you put a one between each Castle? Okay, then you put a zero underneath each night.  So this configuration?  What binary string would it map to?  0010100  So for every configuration, you can do that now going the other way. How would you do it? Well, those ones you kind of extend as like dividers between the castles and then the zeros become all the nights.  Meaning are you?  okay, so let's think of a think of a scenario where  Okay, I'm not good at drawing a castle.  Let's think of a scenario where Maybe.  The second castle has one soldier.  Here's a sword and shield.  and maybe the third Castle has  I don't know for soldiers. I'll just write. For soldiers.  Okay, so now what would the what would the  String B that corresponds to this.  I ain't got to one. You got to one draw zero between each one of the Four Knights. So just be like that.  Okay good.  So now replace each soldier with a zero and put a space between the knights would want. Okay, that's what we just did.  Okay, any questions about that?  So you can find this in the textbook in 424. It's usually this type of problem is referred to as stars and bars and it's because like you can think about the bars as the sort of separators and the stars as like the soldiers, okay.  And basically you have 7 spaces to fill right and you need to choose two of those spaces to be bars. And then the other remaining thing will be Stars.  In general, what does that mean?  Well, if I wanted to put an indistinguishable soldiers in 2K different Castles, I could instead count the number of ways of ordering K - 1 bars and enstars which is the same. I mean if you just want to change bars to ones and stars two zeros, isn't that's another easy by Jackson then that's the same as counting K - 1 ones  and end zeros  stop which we already know how to count right? So, how do you count this?  Right, but how do you do it in terms of N and K?  N + K - 1 right because you're basically you have K - 1 ones and zeros. So total you have n + K - 1 bits choose what?  choose K - 1  or equivalently you could go like this and + K - 1 choose an  some questions about that.  All right now.  Let's say I had five castles and 10 soldiers. Now how many different configurations are there?  Okay good.  salt remember  the bars divide the castles from each other. So if there are five castles, there's got to be Ford of dividers.  Can I make sense?  questions about that  Okay, here's another exercise.  Same kind of thing. I have five castles in 10 soldiers which binary string would this configuration map to?  Okay, good. Yeah, this one was easy, right?  Okay good. So right you just kind of do the drawing 1 0 0 0 1 0 0 0 1 and then 100000  Wait, I didn't I didn't need that one.  Sorry.  K & A  so any questions about that?  Now you can kind of like I said before you certain properties of one set. You can kind of inherit into the other set. Will you can sort of see what they mean, right? So for example, if you ever have a substring of 1-1 in your string that corresponds to an empty Castle so you can kind of think about what those properties mean in those different situations.  Okay.  So, let's see.  Let's change it up a little bit and now  I have the Restriction that I want to put a soldier in each castle at least one soldier.  Frank and let's say I still have five castles in 10 soldiers. So without the Restriction we started with 14 blank spaces, right and basically chose for them to be bars for for example, and maybe these two and then this one and then that one and then these would all be stars or soldiers.  But if we just do that willy-nilly we might run into this situation where there's two ones together, right? And if that ever happens that means that castles empty. Okay. I want to do it in a way that none of the castles are empty.  Does anybody have any ideas on how to do this?  Okay, you can do that.  Yes, you could do that that would definitely work. Right because the those two things correspond to each other.  Any other ideas?  Also can't start and end with one, right?  Oh, okay. I'm happy that you said that because this problem is a lot like that problem where we we gave out the cards to the to your friends except for this time. You're giving out the cards but they don't have any they're all the same card. Like maybe you're just giving out index cards to your friends or something. Right? You've taken away the labels. So when we that's good because you see at least and you say okay. We should probably do counting by the compliment or inclusion exclusion. Good. This is a  There's another way to do it. We don't have to do that.  and why y9 shoes for  she put his  he put a zero.  Okay good so we can start with.  Put one night.  in each Castle  And then forget about him they're there. Then you just solved the problem of filling them up again, right?  9 nights  leftover  to put into 5 castles  Oh, sorry.  There would be five nights left over to put into five castles and that would be 9 shoes for.  Picard  Looks like kind of a more direct way to do it. There's another way where?  You can kind of think of aligning the nights up like this and then separating them with four bars.  And that will guarantee that there's a night in each castle. And so how many vacancies are there? There's one two, three, four, five six, seven eight nine.  Wait, I did this wrong tonight.  I know this is there's 10 soldiers, right? So we just choose four of those vacancies 1 2 3 and 4 and now that gives you a configuration and you're guaranteed to have a night in each Castle because of the way you set it up, so I'll be all so nice shoes for  Okay.  Okay question.  Like a 01 as like a single thing.  Yeah, I think I think you could argue it that way, too.  Okay good. So how about if I had K castles in N soldiers and I wanted to put at least one soldier in each castle and fill in all fill them up after that.  Well, if you think about it this way.  If there are any soldiers, there's and minus one kind of vacancies, but between them and if they're right you want to put K - 1 bars to separate.  That's where you got and -1 choose K - 1.  So if the without restrictions you get n + K - 1 choose K - 1 and width restrictions.  Write at least one soldier. That's this one.  okay, stop I mean  Good to kind of learn how to do this. But also it's it's going to be helpful to sort of recognize when when you need to use this type of counting technique or when you need to use a different one. So we'll talk about that in a minute.  Okay, so  Okay. So these are the two things that we that we learned. Okay. Wait, this is just repeated.  Okay, this is what I wanted to get to so.  What we've done kind of in the first week and then what we did today was we started filling in this table is called the twelvefold way because there's 12 vacancies. Okay. So the the idea here is we figure out how to count every single possible combination of putting soldiers in castles or pudding or giving cards two players or what are the other kind of things we counted.  I don't know making up Mario characters. I mean Nintendo characters this kind of thing. So just to generalize it. We're going to think about putting balls into boxes.  So let's fill this out. I'm going to have an balls and Xboxes, okay?  What happened balls and Xboxes?  Do you want to put the balls in the boxes another way to think about it is that it's just a function from n to X. Right. It's basically for each ball. You tell me which box you put it in and that's kind of the result of the function.  Okay, how many functions are there in total if my balls and my boxes are both labeled. What do I mean by labeled? Well, maybe their label with just numbers or maybe they're all different colors. Okay. So all the boxes are labeled all the balls are labeled. How many goes in how many are there for just kind of no restrictions. How many ways can I put involved in to end boxes?  well think about like  right EXO. How many ways are there to put one ball in Xboxes? You can choose any of the Xboxes, right?  there's two balls then the second ball you can put in any of the Xboxes and so on so you get  x to the end  Okay, how about if each box has at most one ball?  Okay, so I can't ever put two balls in a box is what I'm saying.  close  close  also  You guys are both close. How can we combine those two?  permutation  permutation of a can  What's what is this? What is this look like?  This looks like x * X - 1 * x - 2 all the way down to x minus and plus one right because I have extra for my first ball pen for my second ball. I can't put it in that box anymore. So there's X - 1 and then x - 2  Okay, how about each ball has at least each box has at least one ball.  Well, we're not going to this class.  This has something to do with something called the Sterling numbers and we're not going to do it in this class so we can skip that we're not going to fill them all out today.  We just have a few more to fill out.  Okay. How about this one right here?  Now my balls are unlabeled, but my boxes are labeled.  Yes.  Why?  Write the back of the balls are unlabeled. So it doesn't matter where they went. All that matters is which once you put them in, right?  I talked to juggling and also you can only have at most one Balinese box. You can't have more than one ball in each box for this one.  Yes.  White  all the cards are labeled and all the people are labeled. That would be like another.  don't be another call him here and it would be  each  yes, so the so in this case the people are the  Balls, and the cards at the cards are the boxes.  right  Alright, alright, cuz you're giving them that way.  and each person has  at least one ball.  right  wait till should that be this one here?  Oh you mean this it's going to be I was going to be this one  Oh, maybe that is the same thing.  Yeah, you're right.  I don't even realize that. All right, so this is the card problem.  And in general is going to be like this big inclusion-exclusion thing. Okay, good. Thank you for that. We have seen it before we did learn it in this class.  Each box guy in each person gets at least one card.  So this Sterling number is basically that I just know it as Stirling numbers, but I never thought to related to that problem.  Yeah, the Sterling number is basically how many ways can you divide up a asset into disjoint subsets?  And that's kind of what we're doing right? We're dividing up the set of cards in two disjoint subsets that we're giving to people.  I got it. Thank you. Okay, great. Okay, so that means okay. Let's go back to this one.  So each box has at most one ball. You can't put two balls in a box. So basically since the balls are unlabeled, all we're really doing is choosing a selection of boxes right choosing Xboxes out of the end and that should be exercising.  Chips are choosing Xboxes and of the Xboxes.  Sorry, I kind of got a little mixed around there. Okay. These are the two that we learn today.  Okay, so  This one is going to be the first thing we learned which was a n.  Excuse me.  X plus and minus one  choose + -1  right because it's basically like putting the soldiers in the castles.  And you can put as many as you want into that has no restrictions.  And then this one is going to be the x minus one shoes and minus one. This is the second one where each Castle needs to have at least one soldier.  x + 10 - 1 + - 1  did I make a mistake?  Okay, wait, so.  The number of boxes is oh, you're right.  Oh my God.  right  Nope. Sorry, I did it wrong again.  Why is that we had it.  Okay, wait this why don't why don't I just use n&k like I had here.  Okay, so  you have  The balls and balls and then x -1. Yeah, you need that many dividers now this one you have  Wait, shouldn't this is this this one's wrong to then, isn't it?  This one should be cnx.  my God  now this one's X and  all right, cuz out of all the boxes you're choosing and of them.  And then this one is you have X castles, right? So you are choosing x minus one of them.  And you have and -1 positions. That's what okay.  That should be good. Sorry about that.  It's a good exercise for everybody, right?  Yes.  How can you?  Okay, so you have to talk about this excuse and  So you're saying I have 10.  10 balls and and and five boxes. How are you going to put it? How you going to make any Arrangement where each ball has at most one each box has  It's impossible.  Okay.  moving on  all this stuff is not part of this class.  I mean you can fill it in but you kind of have to go into more into the Sterling numbers again and partitions and these kind of things that we're not going to cover.  Stop just B6 and I forgot about that one up there. That's  Remember that for next quarter?  Okay. Now let's use this concept this bijective counting so that we can encode things. So we'll go back to encoding and we're going to use it to get the optimal number of bits needed to encode a certain type of object. Okay, so I theoretically optimal encoding  Of length and binary strings with K ones would use the ceiling of log base 2 of n choose K fits right? Remember this is what we tried to encode before using the window and code and we saw that the number of bits we use kind of ranged a bunch but we want to do is use the optimal number of bits. So no more than log base 2 of n choose k  So, how do we do it is very simple in concept.  You list all of the all of the possible strings.  in a certain order  and then you encode them by their position in that list kind of like having like a an address book, right if I want to encode a certain string I look for it into in my address book. I look for what number it is in my list and I'll put that position if I want to decode a position I look for that position in my address book and I'll put the string right and the strings are in a really nice order. So they're easy to find  So so the encoding and decoding is easy an easy concept to understand but it seems like it's a little waste of memory to do this right to store them all. So we're going to look at today is a way to algorithmically figure out what its position should be and also figure out given a position which string should be in that position.  Okay, in the way to do that is to use something called lexicographic ordering.  It's basically dictionary ordering and even better. If you're talking about binary strings. It's actually ordering.  The less than like The Ordering of the actual numbers in binary.  Okay, so  Here's kind of the idea is you compare each bit starting from the left and if they're the same you move on until they differ once they differ the one with the lower bit comes before the one with the higher bit.  So if they're all the same then that means they're the same number. So which one of these comes last in Lex order lexicographic order?  Okay. Good see.  right  Are there any questions about that?  so like imagine that you had a dictionary, but the only letters were zero in one right and so zero comes before 1  And so if I wanted to look up a certain word that started with zero, maybe this is not the best thing. Let's let's talk about just like a dictionary right? I was looking up the word.  miles  right  and I found another word which was  micro  Which one comes first in the dictionary?  Write what you do is you compare the first two they're the same. So move on compare the second to they're the same. So move on compare these now see comes before it's the same idea except for you just using ones and zeros.  It kind of makes sense.  So, what's the last what's the last word in the alphabet? I mean in the dictionary?  zzyzx or something  Is that a word?  Yeah, it's like something weird. I don't know. But anyhow, you get the idea.  That makes sense.  So then this would be the last one in the binary order of the biggest cuz you can just think lexicographic ordering is the same as  ordering of integers by their size  So that's the biggest string on the list.  just the biggest but I wanted to introduce it this way because  I know you don't I'm not always you're not always going to be ordering strings by binary strings. You could be ordering subsets or you could be ordering strings of words for things like that.  Okay, so  Let's go back to the length and binary strings with exactly three ones here. They are graphic order. Okay, ready go.  I'll give you a hint. The first one is zero zero one one one and the last one is 11100.  You guys can just do it in your head like that.  Maybe I'll help you guys out.  What's the next one?  01011  and then what?  like that and then  1  110 Wright  Weight and now I have to start at 1, right.  10011  10101  right and then one  0110  and then 11001  Wait, did I did I get off pace?  And then is that it?  Can I get them all?  They all line up. Yes. Okay, great.  Okay, I just had him here. No big deal. Anybody have any questions.  Yeah, this is a bijection. It's kind of like.  It's a bijection to the integers write the integers from 0 to 9. I'm going to make a bijection from the integers to the strings.  Yeah, you mean would like a rule?  Yeah.  Oh, okay. Yeah know at this point. All I really want you to see is that we're just listing them in a in a certain order and like the the bijection kind of the the naive way to think about the bijection is just to say oh well.  Just look it up in the list and go to that number go to that position.  It's more of just like if you had like a a list of them all then you can map one to the other because it's written there. But what I'm going to share with you is a way to actually get from one of the other kind of algorithmically so that you don't have to look it up.  Okay, so  Here's the idea. We're going to use recursion. Okay?  the key Insight that we have to think about is  in lexicographic order  all the strings that start with zero come before all the strings that start with one skobac.  All the strings that start with zero come before all the strings that start with one.  right  now  if I Lop off the zero.  What kind of strings am i counting?  thanks for  with three  once right  So it's kind of like I've taken the big problem and reduced it down to a smaller problem of the same nature.  How about if I lock off this one?  What am i counting here?  Okay, so and I know we're kind of getting closer and closer to the end of class here. But what I wanted to kind of share with you here.  Is that the first thing you do is you look at the first bit.  Okay, so wait before we before we do that, let's just do something here. How many of these are there?  4 choose 3 witches for right and how many of these are there?  4 choose 2 which is 6  if my string starts with a zero, I know that I have to come before position for.  Right if it's starts with the one I know has to come after or before or after.  Frank  Well, if my position it's like now I start counting from 0.  I really only wanted to count from zero so that I could use the position the  the binary strings  Actually the binary strings here don't really matter that much. It's more just like the number that actually tutor.  Okay, so if I start at 0 then we know right before or after so.  in general any any string that starts with 0 must have position before and -1 shoes K and an E string that starts with one at must have position or after and -1 choose k  And so what you do is you figure out what the first position is and then you if it's if it's a one you add that position to the recursion, right? You were curse on the remaining parts and you know, it's been that far down plus how much farther  Scotty idea  Okay, so  Let's see how much more we have today.  All right.  So I want you guys to do this.  as  an exercise  take home.  Take home exercise and key and code this find the position of this string without actually writing all of them down.  And then we'll we'll kind of discuss it together on Wednesday.  weekend  Thanks.  Can you see San Diego podcast? "
}