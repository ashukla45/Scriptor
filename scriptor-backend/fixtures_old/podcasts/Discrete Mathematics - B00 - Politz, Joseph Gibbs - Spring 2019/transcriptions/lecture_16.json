{
    "Blurbs": {
        "1 and I've got this one. And try tracing it if you're confused about what order things will come out and try tracing it out. Okay cooking again 5 4 3 2 1 Append and then we have this list. It is. 3 is Tupelo, Ms. To Tupelo or this ordered pair that has three of the first element and its other people as its second element and that other ": [
            1783.4,
            1882.8,
            44
        ],
        "3 and then whatever the results of append. on 7 empty list and 9 produces tell me another step until we get down to concrete will next have that L is equal to identity of us will still be in recursive step that L is equal to the empty lettuce and is equal to 7 and M is equal to 9 again in recursive broke things down by how the ": [
            1948.7,
            1991.0,
            47
        ],
        "80 is greater than or equal to Bass count of ATA. We were based on what the proof told us to do assume that DNA land is greater than or equal to base count. Of AA and we would use that plus the definitions and some structure of some logical structure. To come up with the implication that this next step must be true. And this is really no extra ": [
            1525.4,
            1563.1,
            36
        ],
        "Alright, let's get started. So happy Monday everybody. Hope you had a good weekend deadline reminders warm up in homework number for both do this evening together. We did that just so you can talk about for warm up with a bunch of definition for homework more broadly Partners part of the assignment to do just in the apartment groups give us feedback by tonight on that mid-quarter feedback form. ": [
            1.9,
            47.4,
            0
        ],
        "And thanks, for those of you who have already given some really great feedback on the course today sets and recursively defined functions that we started on Friday. So, I'm Friday. We talked a bit about defining DNA double helix. He's and linked list with this new strategy of Icarus. Redefining sets and talk about some functions with them. So your hand out the front page of your handout is ": [
            47.4,
            75.0,
            1
        ],
        "Can we different? What how would I get from our assumptions to demonstrate any of these things are true. Now these two statements are true now. When I get there. So you're pointing out that there is the high-level think we can talk from here this assumption. Looks an awful lot like these goals. Prince is the extra assumption. We made looks a lot like it's not exactly the same ": [
            1198.9,
            1261.5,
            29
        ],
        "I want to do is just talk about based on the definition of an English of contains. I've left part of it blank hear some definition in English and what are some examples for what we expect to happen when we use contain. What do we expect expected useful to test it out first for what we expect before we come up with the definition examples for examples examples samples ": [
            2111.8,
            2150.5,
            52
        ],
        "Of a say equal 0 and so that's good that that satisfies the property to sew this basis case if we went on to this recursive and try to show it with just the information we have here. I need a little bit more information here. I'm going to give the strategy first without motivating it or saying much about it other than about why this is actually an okay ": [
            411.5,
            454.0,
            10
        ],
        "So we broke down the value by using the recursive part of the set definition and then we use that smaller piece. In this case in the same properties. We substituted that the property and used it as an assumption. And our goal here is to show that contains. upend L100 100 is true. That's the goal here. So one of the nice things here is in this case in ": [
            2844.5,
            2887.7,
            71
        ],
        "We allowed ourselves to make we made the Strand one shorter. And then we use that information to prove this final statement that information along the definitions and some of the structure of arithmetic with the definitions in that got us to that that final statement. The thing that's interesting about this is we could run this process again. If I said well how would we proved that DNA land ": [
            1490.4,
            1525.4,
            35
        ],
        "What things? where You tell me. Arguments no me talk about the result. Give me an example example in books. Temptation to link less than a number in the result will be true or false. What's a specific linked list? We could number we can try. We can try the 3791. So we can try this one that we just talked about where we used. 3 seven 9 and what's ": [
            2153.1,
            2198.2,
            53
        ],
        "a suggestion. since we know this statement Oh cool lines. since we know this Can add one to both? science and get exactly our goal we can definitely add one to both sides of an inequality not change the meaning of the inequality and then we've gone from our assumption exactly to our goal by subtracting from both sides. It looks exactly like the goal for me to get there ": [
            1288.8,
            1350.1,
            31
        ],
        "and I would say 3 is equal to 3 + 7 is equal to 3 + 9 is equal to 3 now definitely evaluate the false so he doesn't work and if we switched Seaworks works really well here there's a good question of it both C and A work so see either the first element is equal to the element we're looking for are we can find the element ": [
            2465.6,
            2495.8,
            60
        ],
        "and the other cases similar if we know If this is true, I mean this use a sort of one more property about numbers. Which is we can add one? To the left hand side and adding one to something that's greater than something else doesn't change. Greater than relationship. And there would be no way to finish this proof. If we didn't allow ourselves this extra assumption. We need ": [
            1350.1,
            1391.9,
            32
        ],
        "assumptions aside from what we get from the bay system. Because in that case would be using a very first case of the proof where the Strand is one base long faces, and that's that we could look at all the cases and see that it's true. And so no matter how long we make the Strand we could come up with a could have strands that are millions of ": [
            1563.1,
            1583.6,
            37
        ],
        "bases long and we would always be able to use the proof to run this process backwards. Keep breaking down the Strand one base at a time and you actually you literally could talk about this giant chain of implications in the arrow there. I really mean implication like the implication we've been talking about The if-then Logical statement and you get this giant chain of implications where there's a ": [
            1583.6,
            1606.6,
            38
        ],
        "bunch of sort of Ann's and logical structure is in each step, but it all ends up evaluating to True at the end in the proof has given us a way to construct that chain of implications. This ends up working out as a proof technique also has an argument for why software Works anything that ends up with this kind of recursive definition. It's a nice strategy that gives ": [
            1606.6,
            1631.9,
            39
        ],
        "by calculating this out for the four-one-one elements trans a t g and C. But there's this extra piece that we need in the recursive case. I'm going to use it without saying just assuming that there were there is a prefix of a strand in a base that we can put together to make this information going to assume that the property is true. For the pieces we use ": [
            507.4,
            543.4,
            13
        ],
        "can stick together to make up this the Strand that we're looking at. So in this case is kind of like there must be some other strand. And there must be a base. Where where the Strand were looking at this arbitrary element s is this other shorter strand? With this base added on at the end as we have to think about maybe when we did a bunch of ": [
            301.3,
            335.0,
            7
        ],
        "case tells us they were going to take that out existing element in El which is and then we will append to AL Prime 100. And we're taking it 100 is contained there. I was just using the way we broke down L into these two pieces and the definition of a pain to get there. Then we can use the definition of contains. And contain says that either and ": [
            2922.5,
            2960.8,
            73
        ],
        "case we can think about. and another case Is that interesting? How do we express this other case? There must be some other strand and some bass that put together make up the S. We're looking at we were any other case there must be some other strand some shorter strand that shorter by one base but has all the same bases in it. And then another base that we ": [
            269.4,
            301.3,
            6
        ],
        "cool case of this that really comes up in and real software all the time and he's pretty things about these properties end up being important. So first question I want to ask about linked list is just using a definition and making sure we remember what our definition of linked list in this class look like mission of a recursively defined function called a pen that takes a linked ": [
            1697.4,
            1723.2,
            42
        ],
        "could use the same idea and try and substitute in the recursive step for the definition of base count. The definition of base count has these two different things that could happen. Either base that we're looking at in base count that base that we called be one in the recursive case of the Bass Down definition. Either be one is equal to be to the base were looking for ": [
            1041.2,
            1074.2,
            25
        ],
        "element on an empty list, we always expect to get false. So the number 11 is definitely not in the emptiness we get false back. What are some examples we could also just to give one more example to make something one case that will come up pretty clear. Is that if we look for a number that's not the first element littlest like if we looked for 9, we ": [
            2230.2,
            2253.8,
            55
        ],
        "elements. And that's like the prefix of the Strand and some breaking down elements like this into two pieces when we rode the recursive definitions of these functions. If we just knew this if this was all the information we had to go on. We actually wouldn't have quite enough information to finish this proof. I mean in in the first case the case where we have all the elements ": [
            335.0,
            370.9,
            8
        ],
        "empty list here. and then we're checking for 100 here and this is by the definition of pain and this is the recursive case just to be really explicit about the definition. We get 100 equals 100 or contains on empty list 100. I contain this evaluates the true this evaluates the fall switch all evaluates the truth. So the basic steps and we just push that single value. There's ": [
            2713.2,
            2751.5,
            67
        ],
        "end of the current be in this case is equal to And this case is going to say 1 +. Pace count S Prime And it's actually really starts at this moment. Sammy match some of the way I just think about this problem. When I look at the original statement is the length of the Strand has to be greater than or equal to the number of A's and ": [
            1129.6,
            1174.4,
            27
        ],
        "examples which of these filled in the definition of contains which of these Hills in the definition for actually it matches that answer for all of us. 5 4 3 2 1 discuss briefly Okay freaking again. 5 4 3 2 1 So does a couple interesting ones here maybe a little more straightforward to rule out. He has this problem that a man is supposed to be the number ": [
            2274.9,
            2410.9,
            57
        ],
        "going to call it in and help rhyme and we know that El Prime is a list. nn in some number and we get this one more assumption. The property were trying to prove is true for this smaller element that we use to build this up. So the property that were trying to prove is contains upend Alpine 100 100 and that is everything we get to it soon. ": [
            2800.3,
            2840.8,
            70
        ],
        "good Arguments for things that are defined recursively defined recursively. There's ways to Define things like my friends of friends of friends of friends of friends on different social media sites so different properties of recursive way and you can make good arguments about them. So this idea? It's called proof by induction. And this style in particular is called structural induction and we're breaking that structure down at every ": [
            1631.9,
            1674.6,
            40
        ],
        "greater than or equal to bass count ATA evaluate the two functions and three is greater than we can do that ended up telling us what was the structure that the proof gave us because the proof should be this thing that gives us the argument prove this what if we assume we assume that the property was true. For the Strand that was one shorter. That was an assumption. ": [
            1441.7,
            1490.4,
            34
        ],
        "hand up this idea of doing a proof of an element that came from recursively defined set show me up at Universal this like we did on the first slide in the first case will be to prove a property for all of the elements in the base of steps. So you assume the element has one of the ones that's provided in the NFL beat it up there just ": [
            474.5,
            507.4,
            12
        ],
        "if it weren't exactly the same. It's not exactly the same but it's closed our assumption says inequality between DNA land as Prime and base town as Prime. He's a really close. Until there's a couple ways we can make the argument that we can get from there to here. And we can say something like so let me just say let's take the second case first since I was ": [
            1261.5,
            1288.8,
            30
        ],
        "if the argument looks like that then we're going to add one to the to the recursive use of Dannielynn on that prefix. What would be a similar thing? We'd say if we were using the definition of base count. We're going to take another step here trying to get towards our goal and we were going to use the definition of base count here. I interesting so maybe we ": [
            991.1,
            1041.2,
            24
        ],
        "in is the recursive case of a pain over a little bit on the right is equal to this 7 empty list Tuple. And is equal to 3 and M is equal to 9. Match the arguments there with what the recursive steps to do to break things down. And so the result this part tells us that we're going to have a tooth pulled that has an which is ": [
            1914.0,
            1948.7,
            46
        ],
        "in the Strand can be broken up into some prefix followed by a base. So we know that we could rewrite our to show just by substituting in what it says in the definition in the recursive case here did this is going to be 1 + DNA line of S Prime because of how s is built up we have that in our assumptions and because the definition says ": [
            958.7,
            991.1,
            23
        ],
        "in the base from the base of Step. It's pretty easy to finish. This proof vests is equal to a DNA land Avast is equal to 1 1/8 count of essay is equal to 1 + 1 + 1 those are equal so greater than equal to satisfied. So that's true in here if that's is not equal to a then CNA line of us equals 1 and base count. ": [
            370.9,
            410.3,
            9
        ],
        "in this proof and my justification for it is going to be that its definition of DNA one. What it look like? Yeah. So we have a definition for DNA when it says if the argument F looks like a strand with a base added on at the end, then that's the recursive case of DNA Len definition definition for the recursive case exactly the case. Where is an argument ": [
            909.3,
            958.7,
            22
        ],
        "instead this would be saying the first element of the list has to be equal to this number and all the rest of the elements in the list have to be equal to the number the first the first element of Sweden up with this big and of n equals m for every single and in the list which definitely can't be true. We would end up like with Anne ": [
            2441.8,
            2465.6,
            59
        ],
        "is equal to 100. or Contains on the list that we had here and that list that we gave the rest of the list. Is this append L Prime 100. I was just applying a pain and applying contain and just being really. Can you see sandiego.edu? ": [
            2960.8,
            2994.6,
            74
        ],
        "is in a list 102 then we expect that to be true. So there's two steps happening in the body here one one. Is that where first a pending 102 a list and then using the results of that the argument that contains and so the idea here is we're going to use this new idea of proof by structural induction and so will end up with these two cases ": [
            2632.0,
            2660.9,
            65
        ],
        "list and a number as arguments and produces a new linked list and the idea is that end of the list. So the list is this ordered ordered collection represented by all of these nested tuples and the idea is the end of the list so definition of append and what are should come out based on this definition of the result. For the first round 5 4 3 2 ": [
            1723.2,
            1783.4,
            43
        ],
        "little Peace here is doing is saying this corresponds to the cases where? We like left the Ellen and 3 which was the first element at the beginning. We made this new to bowl that kept that album Into the beginning and then we process the next you sit up and that's what's happening. So the answer here is d and this gives us a little bit of matching between ": [
            2054.9,
            2087.3,
            50
        ],
        "look like the steps to approve this property. Where do you find a challenger where to get stuff? Alright. Alright any ideas about what the first step would be done so far. We have a universal vacation. What do we usually do quantification? We use generalization and we'd say something like let's assume. s is an arbitrary elements of capital s interesting in this case that if we wanted to ": [
            142.7,
            232.2,
            4
        ],
        "needs two cases match where the end of the Strand is either a or not a sew in the case where it's not the length is definitely going to be bigger than the number of ants in the case where the end is in a turbo that won the length and the account today is out of these two cases that I think about why is probably true sister show ": [
            1174.4,
            1197.4,
            28
        ],
        "not the goal here. So a has trouble with duplicates because it will end up with duplicates don't work so well with a so she's the only one I really works in all cases. So that contains independent and here's an interesting an interesting property that we might want to talk about for listen to interesting properties on your sheet. We'll talk about this when we won't get to the ": [
            2564.2,
            2598.5,
            63
        ],
        "one of these arbitrary elements of space and we get this extra something. That's the new information we get. What do you think we're going to do that? We're trying to show what are some of the rest of the steps of the proof going to look like and I'll say now that we have all this information the rest of the steps of this proof start to look like ": [
            701.4,
            730.8,
            18
        ],
        "only one value in the basest up here, which is being Fearless. We just push that all the way through and can see that it works. Let me have this recursive step. And the most important part of the recursive step in these induction proofs is to make sure that we get the assumptions all laid out carefully. Usually once we get the assumptions laid out carefully, then we can ": [
            2751.5,
            2777.8,
            68
        ],
        "or equal to M. But if it's something with duplicates can make that go wrong because if you have a list this one of those simple cases to show that it doesn't work very well is if you drive. On just a single element. I sorry sorry the same element just repeated ones. Somewhere in here will end up getting a Truex or true because we found element twice and ": [
            2529.9,
            2564.2,
            62
        ],
        "or it's not so either we want to show that we can think of this as there's two possible things that can happen here one is the base for looking at is equal to a and I might even just name the case that way so the case one where B is not equal to a 1 plus the DNA of S Prime which is where the base at the ": [
            1074.2,
            1129.6,
            26
        ],
        "other one today the one with remove at the bottom of the way encourage you to think about if you can prove or disprove the one at the bottom pictures of statement the statement is that for all list, if we add 100 to the list, then it contains 100 then what we can do is say to make to make an English Max a little more if we 100 ": [
            2598.5,
            2632.0,
            64
        ],
        "other variables that we talked about in this turns into this stupid that has nine and then ends in the empty list. Some sort of took this element 9 that we wanted to add to the list and pushed it through all of the nest until we made this and we left all of the other numbers are dove in the same place in the same order. That's what this ": [
            2024.9,
            2054.9,
            49
        ],
        "pieces were used to build it up and then we'll see where we can get given this information. This is all things that we get to assume. This box is assumptions. And our to show has not changed to show is still that. DNA land of us is greater than or equal to. bass count of s that's what we're trying to show. We still are assuming the S is ": [
            660.3,
            701.4,
            17
        ],
        "proving conditional statements proof by contraposition through bite proof by cases match our goal for what we're trying to prove. So we use them this is a strategy is to prove a universal quantification over one of these recursively defined stats and the girl says we Define all the variables that came from that recursive case and then make this extra assumption that the property is true for those smaller ": [
            629.7,
            660.3,
            16
        ],
        "pursue seen before so there's not a brand new techniques going to be needs that we're going to need to introduce to finish. This is going to use techniques like we've seen before finish off this proof and give this demonstrates his to show given the assumptions we have In a big Kansas to look at the definitions of DNA Len and bass count and see what it would mean ": [
            730.8,
            801.1,
            19
        ],
        "some of the English in the description. It says at the end so that end means it's going to appear that the rightmost when we write these things out and it sort of the innermost messed it to pull that we have. So the next thing I want to talk about is another function not a pain, but another function called contains over these linked list. And the first thing ": [
            2087.3,
            2111.8,
            51
        ],
        "somewhere else in the list, but even if we don't find it now as long as there's more elements to look at we could find it somewhere in the rest of the list as well. So see we're not work. Yeah, so we're all of the list is a more even if they're depending on how what order exactly there in maybe we're two of them next to each other ": [
            2495.8,
            2529.9,
            61
        ],
        "start to see the structure. We need to finish things off blue really need to lay out the structure carefully. So I'm in or just refer to the definition of linked lists here and make sure that I talked about each of these variables. Now I'm going to say that L is equal to 2 some Tuple that is in and I usually use a prime for these so I'm ": [
            2777.8,
            2800.3,
            69
        ],
        "step by splitting it into these pieces in this case. A strand of the base is the Deep structure and we do and then we we break it down and eventually get down to our base and then we can talk about the implication going all the way back up. I want to do another couple of properties about this based on linked list on Friday, and they're actually pretty ": [
            1674.6,
            1697.4,
            41
        ],
        "strands written recursively the length is at least as long as the number of A's in the Strand days in the Strand. It's interesting to think about what it would take to prove this property might make an argument that no matter what no matter what the Strand looks like. This property is going to be true. I think about based on what we've seen so far what it would ": [
            107.1,
            142.7,
            3
        ],
        "talk about wouldn't what new evidence we get from knowing that as a DNA strand and go back and look at the definition. The definition of these two cases. The definition has this case That's the basis stuff that says, well, we know that if a strand because of the basis step one case we can talk about where is an element of a g c. And that's at 1 ": [
            232.2,
            269.4,
            5
        ],
        "that? What number what do you want to look for? And we expect the results of this to be. If we look for some number that was not there. Like if we took this same list and we look for 11, we would then expect the results to be false. And one of the things that helps us get to this and point is that if we look for an ": [
            2198.2,
            2230.2,
            54
        ],
        "the DNA line of the Strand. Is greater than or equal to the base count of the Strand? On a 7/8 he's in the Strand. And just to make it really clear. What changed. This is prime. Is this smaller strand that the prefix of the Strand? They were using in all these places. And this is the rule for prove it. Just like direct proof is a rule for ": [
            584.7,
            629.7,
            15
        ],
        "the page with the DNA definitions on it. And there is also the two functions that we wrote a partially together and partially provided on Friday at 1 that counts the length of DNA and one that counts up how many times a particular base appears within a DNA strand and now almost called base count. So those definition definition of a DNA strand are the set of all DNA ": [
            75.0,
            107.1,
            2
        ],
        "thing to do and why it works out pretty well. I'm going to leave the basis case as done and just take this and say this recursive case as I've written. It isn't the real way. We're going to handle these recursive cases and scroll down to where I have this definition right now, which is the same definition you have at the bottom of the front page of the ": [
            454.0,
            474.5,
            11
        ],
        "this extra assumption in order to tie off the end of this information to demonstrate that this is true in terms for some arbitrary strand that maybe has a really long length and what The Logical structure looks like So make sure you use in space that I left on the previous. Let's imagine instantiating is proof for a really specific value and a t a n a t a ": [
            1391.9,
            1440.4,
            33
        ],
        "this proof looking at the definitions of a pens and contains. There's no like conditional case like there wasn't bass count. So it's a little more direct. We don't have to split into those two different cases for append. We know that of nnl prime. We can expand the definition of a pens here. and we know we're in the recursive case and the definition of a pending a recursive ": [
            2887.7,
            2922.5,
            72
        ],
        "to build that up. We're going to assume that the property were trying to prove is true for that smaller strand. We're going to say equals this other strand and then a base. where the base is a base in the smaller strand is we're also going to go get the property. We were talking about and assume that it's true for S Prime. So that property were talking about ": [
            543.4,
            584.7,
            14
        ],
        "to talk about and we have a basis step. Where L is the empty list? And in that case what we're trying to show is that contains. Append and we can substitute in empty list for L 100 100. And here we can just use the definitions and push this through. So just making sure they were careful to use the definition of a pens correctly and we get 100 ": [
            2660.9,
            2713.2,
            66
        ],
        "to use those definitions to expand rewrite substitute different parts of the to show and our assumptions. So what are the definitions help us do Okay, so let's talk about this a dip. Is there a definition for there's DNA land in base town or two definitions that they're one of those definitions that seems useful to maybe expand or apply or used first in one of these places definition ": [
            801.1,
            877.0,
            20
        ],
        "two full has seven and then ends in the empty list list are always going to have bees nest in 2 apples. And finally the innermost best in Tuple has an empty list as the second the second part and that's the list. So this first call to upend is happening not just on this with the argument 9 as the elements being added. And the stuff we end up ": [
            1882.8,
            1914.0,
            45
        ],
        "variables are listed and we still have this three in the front but the pain has to turn into putting the value of n first and then whatever we get from doing append on the value of L and the value of n now we have a use of append where the first argument is empty list definition of repent. So we just have that m equals 9, there's no ": [
            1991.0,
            2024.9,
            48
        ],
        "we're looking for them and we don't work at all. We're going to keep looking for a different element every time so it doesn't really capture the idea here. Bee has the same problem that it uses n as the argument that it passes on. And also there's an and they're so even if this said m in the even if this one said him and if we imagined that ": [
            2410.9,
            2441.8,
            58
        ],
        "would also expect that to produce true. So it's important that we don't just look at the first element with all the elements in the list. So there's some interesting cases we can think about and I'm in a copy these down 7 question on the next on the next slide that I want to ask. So the question is based on this description and now we have some nice ": [
            2253.8,
            2274.9,
            56
        ],
        "you'd looked after you went to first to try and understand what's going on. definition what would it mean to use one of the definitions? Like I said, we're going to use the definition of DNA in the next step of this proof is the definition of DNA land in the next step. If I were trying to use that like I'm going to fill in some next next line ": [
            877.0,
            909.3,
            21
        ]
    },
    "File Name": "lecture_16.flac",
    "Full Transcript": "Alright, let's get started.  So happy Monday everybody. Hope you had a good weekend deadline reminders warm up in homework number for both do this evening together. We did that just so you can talk about for warm up with a bunch of definition for homework more broadly Partners part of the assignment to do just in the apartment groups give us feedback by tonight on that mid-quarter feedback form. And thanks, for those of you who have already given some really great feedback on the course today sets and recursively defined functions that we started on Friday. So, I'm Friday. We talked a bit about defining DNA double helix. He's and linked list with this new strategy of Icarus.  Redefining sets and talk about some functions with them. So your hand out the front page of your handout is the page with the DNA definitions on it.  And there is also the two functions that we wrote a partially together and partially provided on Friday at 1 that counts the length of DNA and one that counts up how many times a particular base appears within a DNA strand and now almost called base count. So those definition definition of a DNA strand are the set of all DNA strands written recursively the length is at least as long as the number of A's in the Strand days in the Strand. It's interesting to think about what it would take to prove this property might make an argument that no matter what no matter what the Strand looks like. This property is going to be true.  I think about based on what we've seen so far what it would look like the steps to approve this property. Where do you find a challenger where to get stuff?  Alright. Alright any ideas about what the first step would be done so far. We have a universal vacation. What do we usually do quantification?  We use generalization and we'd say something like let's assume.  s is an  arbitrary elements of capital s  interesting in this case that if we wanted to talk about wouldn't what new evidence we get from knowing that as a DNA strand and go back and look at the definition. The definition of these two cases. The definition has this case That's the basis stuff that says, well, we know that if a strand because of the basis step one case we can talk about where is an element of a g c.  And that's at 1 case we can think about.  and another case  Is that interesting? How do we express this other case?  There must be some other strand and some bass that put together make up the S. We're looking at we were any other case there must be some other strand some shorter strand that shorter by one base but has all the same bases in it. And then another base that we can stick together to make up this the Strand that we're looking at. So in this case is kind of like there must be some other strand.  And there must be a base.  Where where the Strand were looking at this arbitrary element s is this other shorter strand?  With this base added on at the end as we have to think about maybe when we did a bunch of elements.  And that's like the prefix of the Strand and some breaking down elements like this into two pieces when we rode the recursive definitions of these functions.  If we just knew this if this was all the information we had to go on.  We actually wouldn't have quite enough information to finish this proof.  I mean in in the first case the case where we have all the elements in the base from the base of Step. It's pretty easy to finish. This proof vests is equal to a  DNA land  Avast is equal to 1 1/8 count of essay is equal to 1 + 1 + 1 those are equal so greater than equal to satisfied. So that's true in here if that's is not equal to a then CNA line of us equals 1 and base count.  Of a say equal 0 and so that's good that that satisfies the property to sew this basis case if we went on to this recursive and try to show it with just the information we have here.  I need a little bit more information here.  I'm going to give the strategy first without motivating it or saying much about it other than about why this is actually an okay thing to do and why it works out pretty well.  I'm going to leave the basis case as done and just take this and say this recursive case as I've written. It isn't the real way. We're going to handle these recursive cases and scroll down to where I have this definition right now, which is the same definition you have at the bottom of the front page of the hand up this idea of doing a proof of an element that came from recursively defined set show me up at Universal this like we did on the first slide in the first case will be to prove a property for all of the elements in the base of steps. So you assume the element has one of the ones that's provided in the NFL beat it up there just by calculating this out for the four-one-one elements trans a t g and C.  But there's this extra piece that we need in the recursive case. I'm going to use it without saying just assuming that there were there is a prefix of a strand in a base that we can put together to make this information going to assume that the property is true.  For the pieces we use to build that up. We're going to assume that the property were trying to prove is true for that smaller strand.  We're going to say equals this other strand and then a base.  where  the base is a base in the smaller strand is we're also going to go get the property. We were talking about and assume that it's true for S Prime.  So that property were talking about the DNA line of the Strand.  Is greater than or equal to the base count of the Strand?  On a 7/8 he's in the Strand.  And just to make it really clear. What changed.  This is prime.  Is this smaller strand that the prefix of the Strand?  They were using in all these places.  And this is the rule for prove it. Just like direct proof is a rule for proving conditional statements proof by contraposition through bite proof by cases match our goal for what we're trying to prove. So we use them this is a strategy is to prove a universal quantification over one of these recursively defined stats and the girl says we Define all the variables that came from that recursive case and then make this extra assumption that the property is true for those smaller pieces were used to build it up and then we'll see where we can get given this information.  This is all things that we get to assume.  This box is assumptions.  And our to show has not changed to show is still that.  DNA land of us is greater than or equal to.  bass count of s  that's what we're trying to show.  We still are assuming the S is one of these arbitrary elements of space and we get this extra something. That's the new information we get. What do you think we're going to do that? We're trying to show what are some of the rest of the steps of the proof going to look like and I'll say now that we have all this information the rest of the steps of this proof start to look like pursue seen before so there's not a brand new techniques going to be needs that we're going to need to introduce to finish. This is going to use techniques like we've seen before finish off this proof and give this demonstrates his to show given the assumptions we have  In a big Kansas to look at the definitions of DNA Len and bass count and see what it would mean to use those definitions to expand rewrite substitute different parts of the to show and our assumptions. So what are the definitions help us do  Okay, so let's talk about this a dip.  Is there a definition for there's DNA land in base town or two definitions that they're one of those definitions that seems useful to maybe expand or apply or used first in one of these places definition you'd looked after you went to first to try and understand what's going on.  definition  what would it mean to use one of the definitions? Like I said, we're going to use the definition of DNA in the next step of this proof is the definition of DNA land in the next step. If I were trying to use that like I'm going to fill in some next next line in this proof and my justification for it is going to be that its definition of DNA one.  What it look like? Yeah.  So we have a definition for DNA when it says if the argument F looks like a strand with a base added on at the end, then that's the recursive case of DNA Len definition definition for the recursive case exactly the case. Where is an argument in the Strand can be broken up into some prefix followed by a base. So we know that we could rewrite our to show just by substituting in what it says in the definition in the recursive case here did this is going to be  1 + DNA line of S Prime  because of how s is built up we have that in our assumptions and because the definition says if the argument looks like that then we're going to add one to the to the recursive use of Dannielynn on that prefix.  What would be a similar thing? We'd say if we were using the definition of base count.  We're going to take another step here trying to get towards our goal and we were going to use the definition of base count here.  I interesting so maybe we could use the same idea and try and substitute in the recursive step for the definition of base count. The definition of base count has these two different things that could happen.  Either base that we're looking at in base count that base that we called be one in the recursive case of the Bass Down definition. Either be one is equal to be to the base were looking for or it's not  so either we want to show that we can think of this as there's two possible things that can happen here one is  the base for looking at is equal to a and I might even just name the case that way so the case one where B is not equal to a 1 plus the DNA of S Prime which is where the base at the end of the current be in this case is equal to  And this case is going to say 1 +.  Pace count  S Prime  And it's actually really starts at this moment. Sammy match some of the way I just think about this problem. When I look at the original statement is the length of the Strand has to be greater than or equal to the number of A's and needs two cases match where the end of the Strand is either a or not a sew in the case where it's not the length is definitely going to be bigger than the number of ants in the case where the end is in a turbo that won the length and the account today is out of these two cases that I think about why is probably true sister show  Can we different? What how would I get from our assumptions to demonstrate any of these things are true. Now these two statements are true now.  When I get there.  So you're pointing out that there is the high-level think we can talk from here this assumption.  Looks an awful lot like these goals.  Prince is the extra assumption. We made looks a lot like it's not exactly the same if it weren't exactly the same. It's not exactly the same but it's closed our assumption says inequality between DNA land as Prime and base town as Prime. He's a really close.  Until there's a couple ways we can make the argument that we can get from there to here.  And we can say something like so let me just say let's take the second case first since I was a suggestion.  since we know  this statement  Oh cool lines.  since we know this  Can add one to both?  science  and get exactly  our goal we can definitely add one to both sides of an inequality not change the meaning of the inequality and then we've gone from our assumption exactly to our goal by subtracting from both sides. It looks exactly like the goal for me to get there and the other cases similar if we know  If this is true, I mean this use a sort of one more property about numbers.  Which is we can add one?  To the left hand side and adding one to something that's greater than something else doesn't change. Greater than relationship.  And there would be no way to finish this proof. If we didn't allow ourselves this extra assumption. We need this extra assumption in order to tie off the end of this information to demonstrate that this is true in terms for some arbitrary strand that maybe has a really long length and what The Logical structure looks like  So make sure you use in space that I left on the previous. Let's imagine instantiating is proof for a really specific value and a t a n a t a  greater than or equal to  bass count  ATA evaluate the two functions and three is greater than we can do that ended up telling us what was the structure that the proof gave us because the proof should be this thing that gives us the argument prove this what if we assume we assume that the property was true.  For the Strand that was one shorter.  That was an assumption. We allowed ourselves to make we made the Strand one shorter. And then we use that information to prove this final statement that information along the definitions and some of the structure of arithmetic with the definitions in that got us to that that final statement.  The thing that's interesting about this is we could run this process again. If I said well how would we proved that DNA land 80 is greater than or equal to Bass count of ATA. We were based on what the proof told us to do assume that DNA land is greater than or equal to base count.  Of AA and we would use that plus the definitions and some structure of some logical structure.  To come up with the implication that this next step must be true. And this is really no extra assumptions aside from what we get from the bay system.  Because in that case would be using a very first case of the proof where the Strand is one base long faces, and that's that we could look at all the cases and see that it's true.  And so no matter how long we make the Strand we could come up with a could have strands that are millions of bases long and we would always be able to use the proof to run this process backwards. Keep breaking down the Strand one base at a time and you actually you literally could talk about this giant chain of implications in the arrow there. I really mean implication like the implication we've been talking about The if-then Logical statement and you get this giant chain of implications where there's a bunch of sort of Ann's and logical structure is in each step, but it all ends up evaluating to True at the end in the proof has given us a way to construct that chain of implications. This ends up working out as a proof technique also has an argument for why software Works anything that ends up with this kind of recursive definition. It's a nice strategy that gives good Arguments for things that are defined recursively defined recursively.  There's ways to Define things like my friends of friends of friends of friends of friends on different social media sites so different properties of recursive way and you can make good arguments about them.  So this idea?  It's called proof by induction.  And this style in particular is called structural induction and we're breaking that structure down at every step by splitting it into these pieces in this case. A strand of the base is the Deep structure and we do and then we we break it down and eventually get down to our base and then we can talk about the implication going all the way back up.  I want to do another couple of properties about this based on linked list on Friday, and they're actually pretty cool case of this that really comes up in and real software all the time and he's pretty things about these properties end up being important.  So first question I want to ask about linked list is just using a definition and making sure we remember what our definition of linked list in this class look like mission of a recursively defined function called a pen that takes a linked list and a number as arguments and produces a new linked list and the idea is that end of the list. So the list is this ordered ordered collection represented by all of these nested tuples and the idea is the end of the list so definition of append and what are should come out based on this definition of the result.  For the first round 5 4 3 2 1 and I've got this one.  And try tracing it if you're confused about what order things will come out and try tracing it out.  Okay cooking again  5 4 3 2 1  Append and then we have this list.  It is.  3 is Tupelo, Ms. To Tupelo or this ordered pair that has three of the first element and its other people as its second element and that other two full has seven and then ends in the empty list list are always going to have bees nest in 2 apples. And finally the innermost best in Tuple has an empty list as the second the second part and that's the list.  So this first call to upend is happening not just on this with the argument 9 as the elements being added.  And the stuff we end up in is the recursive case of a pain over a little bit on the right is equal to this 7 empty list Tuple.  And is equal to 3 and M is equal to 9. Match the arguments there with what the recursive steps to do to break things down.  And so the result this part tells us that we're going to have a tooth pulled that has an which is 3 and then whatever the results of append.  on 7 empty list and 9 produces  tell me another step until we get down to concrete will next have that L is equal to  identity of us will still be in recursive step that L is equal to the empty lettuce and is equal to 7 and M is equal to 9 again in recursive broke things down by how the variables are listed and we still have this three in the front but the pain has to turn into putting the value of n first and then whatever we get from doing append on the value of L and the value of n  now we have a use of append where the first argument is empty list definition of repent. So we just have that m equals 9, there's no other variables that we talked about in this turns into this stupid that has nine and then ends in the empty list.  Some sort of took this element 9 that we wanted to add to the list and pushed it through all of the nest until we made this and we left all of the other numbers are dove in the same place in the same order. That's what this little  Peace here is doing is saying this corresponds to the cases where?  We like left the Ellen and 3 which was the first element at the beginning. We made this new to bowl that kept that album Into the beginning and then we process the next you sit up and that's what's happening. So the answer here is d  and this gives us a little bit of matching between some of the English in the description. It says at the end so that end means it's going to appear that the rightmost when we write these things out and it sort of the innermost messed it to pull that we have.  So the next thing I want to talk about is another function not a pain, but another function called contains over these linked list.  And the first thing I want to do is just talk about based on the definition of an English of contains. I've left part of it blank hear some definition in English and what are some examples for what we expect to happen when we use contain. What do we expect expected useful to test it out first for what we expect before we come up with the definition examples for  examples  examples  samples  What things?  where  You tell me.  Arguments no me talk about the result. Give me an example example in books.  Temptation to link less than a number in the result will be true or false. What's a specific linked list? We could number we can try.  We can try the 3791.  So we can try this one that we just talked about where we used.  3 seven  9  and what's that? What number what do you want to look for?  And we expect the results of this to be.  If we look for some number that was not there.  Like if we took this same list and we look for 11, we would then expect the results to be false.  And one of the things that helps us get to this and point is that if we look for an element on an empty list, we always expect to get false.  So the number 11 is definitely not in the emptiness we get false back.  What are some examples we could also just to give one more example to make something one case that will come up pretty clear. Is that if we look for a number that's not the first element littlest like if we looked for 9, we would also expect that to produce true. So it's important that we don't just look at the first element with all the elements in the list.  So there's some interesting cases we can think about and I'm in a copy these down 7 question on the next on the next slide that I want to ask.  So the question is based on this description and now we have some nice examples which of these filled in the definition of contains which of these Hills in the definition for actually it matches that answer for all of us.  5 4 3 2 1  discuss briefly  Okay freaking again.  5 4 3 2 1  So does a couple interesting ones here maybe a little more straightforward to rule out. He has this problem that a man is supposed to be the number we're looking for them and we don't work at all. We're going to keep looking for a different element every time so it doesn't really capture the idea here.  Bee has the same problem that it uses n as the argument that it passes on.  And also there's an and they're so even if this said m in the even if this one said him and if we imagined that instead this would be saying the first element of the list has to be equal to this number and all the rest of the elements in the list have to be equal to the number the first the first element of Sweden up with this big and of n equals m for every single and in the list which definitely can't be true. We would end up like with Anne and I would say 3 is equal to 3 + 7 is equal to 3 + 9 is equal to 3 now definitely evaluate the false so he doesn't work and if we switched  Seaworks works really well here there's a good question of it both C and A work so see either the first element is equal to the element we're looking for are we can find the element somewhere else in the list, but even if we don't find it now as long as there's more elements to look at we could find it somewhere in the rest of the list as well. So see we're not work.  Yeah, so we're all of the list is a more even if they're depending on how what order exactly there in maybe we're two of them next to each other or equal to M. But if it's something with duplicates can make that go wrong because if you have a list this one of those simple cases to show that it doesn't work very well is if you drive.  On just a single element.  I sorry sorry the same element just repeated ones.  Somewhere in here will end up getting a Truex or true because we found element twice and not the goal here. So a has trouble with duplicates because it will end up with duplicates don't work so well with a  so she's the only one I really works in all cases.  So that contains independent and here's an interesting an interesting property that we might want to talk about for listen to interesting properties on your sheet. We'll talk about this when we won't get to the other one today the one with remove at the bottom of the way encourage you to think about if you can prove or disprove the one at the bottom  pictures of statement the statement is that for all list, if we add 100 to the list, then it contains 100 then what we can do is say to make to make an English Max a little more if we 100 is in a list 102 then we expect that to be true. So there's two steps happening in the body here one one. Is that where first a pending 102 a list and then using the results of that the argument that contains  and so the idea here is we're going to use this new idea of proof by structural induction and so will end up with these two cases to talk about  and we have a basis step.  Where L is the empty list?  And in that case what we're trying to show is that contains.  Append and we can substitute in empty list for L 100 100.  And here we can just use the definitions and push this through. So just making sure they were careful to use the definition of a pens correctly and we get 100 empty list here.  and then we're checking for 100 here and this is  by the definition of pain  and this is the recursive case just to be really explicit about the definition. We get 100 equals 100 or contains on empty list 100.  I contain this evaluates the true this evaluates the fall switch all evaluates the truth.  So the basic steps and we just push that single value. There's only one value in the basest up here, which is being Fearless. We just push that all the way through and can see that it works.  Let me have this recursive step.  And the most important part of the recursive step in these induction proofs is to make sure that we get the assumptions all laid out carefully. Usually once we get the assumptions laid out carefully, then we can start to see the structure. We need to finish things off blue really need to lay out the structure carefully. So I'm in or just refer to the definition of linked lists here and make sure that I talked about each of these variables.  Now I'm going to say that L is equal to 2 some Tuple that is in and I usually use a prime for these so I'm going to call it in and help rhyme and we know that El Prime is a list.  nn  in some number  and we get this one more assumption. The property were trying to prove is true for this smaller element that we use to build this up. So the property that were trying to prove is  contains  upend  Alpine  100 100  and that is  everything we get to it soon.  So we broke down the value by using the recursive part of the set definition and then we use that smaller piece. In this case in the same properties. We substituted that the property and used it as an assumption.  And our goal here is to show that contains.  upend  L100 100 is true. That's the goal here.  So one of the nice things here is in this case in this proof looking at the definitions of a pens and contains. There's no like conditional case like there wasn't bass count. So it's a little more direct. We don't have to split into those two different cases for append. We know that of nnl prime. We can expand the definition of a pens here.  and we know we're in the recursive case and the definition of a pending a recursive case tells us they were going to take that out existing element in El which is  and then we will append to AL Prime 100.  And we're taking it 100 is contained there.  I was just using the way we broke down L into these two pieces and the definition of a pain to get there. Then we can use the definition of contains.  And contain says that either and is equal to 100.  or  Contains on the list that we had here and that list that we gave the rest of the list. Is this append L Prime 100.  I was just applying a pain and applying contain and just being really.  Can you see sandiego.edu? "
}