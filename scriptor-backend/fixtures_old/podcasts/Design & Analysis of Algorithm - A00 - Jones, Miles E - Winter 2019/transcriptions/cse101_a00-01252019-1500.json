{
  "Blurbs": {
    "And now update only the neighbors of G because those are the only ones that are going to change once you put that vertex in. So that's where we're going to get the better efficiency. Okay, and Saudi updates to 2. Okay, dendy, A or B is the lowest One Source go a d so put D in there. and now we get to update a and so on. Okay, ": [
      2477.1,
      2510.0,
      60
    ],
    "I thought it was all nice and works nicely, but it doesn't so. Okay, I'll fix it up in the slides and you guys can see it but you get the idea right questions. Alright, so then now it looks okay and then you just put the last vertex on and did I? Oh crap. Now, this is Ron still. Know what is it K12 Frank? Okay. Okay now just ": [
      755.3,
      796.7,
      19
    ],
    "I'll let you guys. I have your imagination to how this story ends. Okay, how do we Implement Prince while when do we update a Vertex? It's only when another vertex is put into X so you can start seeing the the similarities between this and dijkstra's algorithm. so let's think about it an in kind of use this cost to make our decisions now initialize all the cost put ": [
      2510.0,
      2544.0,
      61
    ],
    "Listen to a podcast. High class seems like I'm having some technical problems. So just give me a second. I'm going to turn it off and then turn it back on again. Tends to happen sometimes in this room. Anybody have any questions before we begin? It looks like it's working good. To do it like that. Okay, great. alright, so last time we we took the time to Talk ": [
      1.9,
      84.3,
      0
    ],
    "O of the x e That's a good first step. Anybody want to share their ideas on how to make it more efficient. From your ex the ones that are connected to the wants to know when you put something in X put all the edges and a priority queue. Cuz that's when you put moved from v2x whenever you do that for you to that birthday. Look at all ": [
      2181.7,
      2215.1,
      52
    ],
    "Okay, so why would you want to do this think about an example where you have like a bunch of computer networks or computers a network of computers that are linked pairwise and each link has some sort of operational maintenance cost. So you want all the computers to stay connected but you want to take get rid of the cost that some of the links so that you can ": [
      1253.7,
      1279.8,
      33
    ],
    "So we have DEA. Put that in there. So now we have three edges of wait to sweep pick any of them. Let's pick this one to see Sorry, I don't have an animation for this. AC and then we also have two edges that are weight to those are both going to be so let's pick. I don't know this one. Hey B. And now we can pick any ": [
      1786.4,
      1830.9,
      45
    ],
    "Wait, what happened to my other thing again? Well just write it. Okay. So this is contingent on the fact that this is equal to n x J equals one up to login Jay over to the Jay you can factor out that end and now this here. Is actually a convergent sum. so this is J equals one up to Infinity I or J over 2 to the J ": [
      1026.9,
      1063.1,
      27
    ],
    "What if we put them in the opposite order? Would that help out? Here is a beer say a way to make a heap. Let's fill in the bottom layer of the heat first. Okay, just randomly, then we'll fill in the next layer. And as we fill it in will update by letting those vertices trickle-down if they need to write and then build the next layer and build ": [
      558.5,
      588.4,
      13
    ],
    "a input and so all connected graphs have is Big Omega of V. Because that very worst you have a tree and you have V - 1 edges. So so that means that with a binary Heap instead of v+ elog V now. It's just you lock me. Okay, and that backslash didn't compile this fine? And then the array is also vsquare so you get the same sort of ": [
      2683.6,
      2723.5,
      66
    ],
    "a priority queue of edges Okay, so then you can use power to keep any other ideas. But we do a priority queue with edges. Let's say we do it use a keep right then every time you do every time you pick a minimum value. if to do log e many operations So how long would that run? And log E. I guess which is pretty good. Okay. Maybe ": [
      2254.8,
      2302.4,
      54
    ],
    "about dijkstra's algorithm in detail. Right? We proved its correctness sit and talk about how to implement. It talks about sort of a mid-level description where we could we could sort of put different implementations in there to get different run times. And and so today we're going to look a little bit more into the priority queue and what you can do with it and what type of features ": [
      84.3,
      114.0,
      1
    ],
    "at the idea. Next stage is to put the next two on there right and let those trickle-down. So change G with what? F and then trade G with what beer k Oh, I didn't do it yet. Shoot wait, I trade it with K. This is this is all messed up. All right. I'll just do it like this. Wait a minute. Ya B10 and G22. Sorry about that. ": [
      708.7,
      754.2,
      18
    ],
    "because the whole algorithm takes more than n log in time anyway, but I don't know. Maybe you need this in a different if a different for different purpose, right? It's a nice way to organize data. And it makes for finding you know, the the lowest value really easy. Okay, let's move on to another problem minimum spanning trees. Okay. What is a minimum spanning tree? Will first let's ": [
      1148.2,
      1179.1,
      30
    ],
    "connecting it to a vertex in X right find the minimum Edge this just translates to find the vertex outside of X that has the lowest cost. And then once you move the edge into X update all the cost again and keep on going, but let's look at see how that works. queso I don't have a nice animation, but you can sort of see how it's going to ": [
      2407.5,
      2437.0,
      58
    ],
    "cuz I'm sure some of you seen prims and maybe you have the idea of how to do it efficiently. But let's just think about how do I first do this? Well, my first instinct would say, okay. What I'm going to do is keep the Boolean array 4X right. So it's basically the visited array right? And so then I'm going to go through all my edges and check ": [
      2055.8,
      2089.5,
      49
    ],
    "define. What is a spanning tree spanning tree is a subgraph of a connected undirected graph. They so we're moving into kind of chapter 5 5.1. We talked about minimum spanning trees and whenever I say Graff I'm always thinking of an undirected. I should say connected. connected graph Okay, so I spanning tree is just a subgraph that's a tree and all of the vertices are in the graph ": [
      1179.1,
      1217.8,
      31
    ],
    "disc to cost and then the way that it updates and it's the same thing. Pretty cool. So let's look at the run time since since all we did was change in a few letters and things like that. We didn't really change the run time. So this shares the same run time as dijkstra's one big difference here is that prims only allows for connected graphs to ever be ": [
      2651.1,
      2683.6,
      65
    ],
    "edges. We can actually use a priority queue of vertices. Okay, and so instead of keeping track of the edges, let's keep track of the endpoints of those edges. Cuz those are the things that really matter right? Those are the things. I'm going to be putting into my ex. Okay. So now we're going to have this cost value for each vertex and we're going to pick the next ": [
      2346.8,
      2374.1,
      56
    ],
    "elements that are already in there. So really the number in the worst-case you're going to do one log. Well that doesn't really make sense that start with to log to 2 log 2 + 3 log 3 + 4 log 4 all the way up to Plus nowait Nazis All the way up to log in this is what it is, right? so it's the song from I equals ": [
      404.6,
      441.4,
      9
    ],
    "fine. We have something to make a heap in and login time. And and that's fine. Okay. Can we improve on this bound we improve on this run time? Okay. So what if we so in in this sense, we started kind of putting it put the first one at the root and then keep on putting them into the tree and building the tree one by one like that. ": [
      535.2,
      558.5,
      12
    ],
    "free this afternoon or this evening? But next week I was doing next week. Yeah, I would like some I would appreciate some! I still want to get it. Yeah. Sure. I don't know maybe even Monday you can come talk to me after class. example for the greedy did you like that? Alright, I'll do that. San Diego ": [
      2804.2,
      2842.2,
      69
    ],
    "how we can get 12? I think if we do these guys here and the three in the fourth, right. Org. Okay, good. I'll bring them you use you might have used why don't know a certain type of algorithm to do this or you might have just kind of figured it out or played around with it. So we're going to look at two main algorithms to solve this ": [
      1607.8,
      1630.5,
      39
    ],
    "if you already know what it is then read up on it, and if you don't then think about what does that mean the greedy approach try to keep on at the next Edge that will contribute the least amount to each thing. What's up? I'll post it today and I also post some practice problems for the quiz. Bank of America 4105 should come a different time. Are you ": [
      2764.6,
      2804.2,
      68
    ],
    "induction proof with it, or you can do it with an integral you could show that the integral is is a finite value something like that. Any other questions? Okay, good. So make you of an object's it takes us a text Big O of end time. There are four for our algorithm dijkstra's algorithm. It's going to doesn't really matter if it takes end timer and log in time ": [
      1100.3,
      1148.2,
      29
    ],
    "insert takes login in the number of levels? Kelley Blue Book actually, let me do something real fast. Even though it's like it's supposed to be less than 10 times at right now. Is that not working anymore? Crap, what do I do? Okay good. Okay. So what are you guys say? And login, how did you get that? Okay. Okay good. So it certainly will take Big O of ": [
      273.0,
      372.7,
      7
    ],
    "into the zero, right and so think about how far they fell in the first layer. They didn't follow it all the second layer. They fell one level the third layer they fell two levels or sorry. The Pearl are they felt nothing the second layer they fell won the first layer they fell to in the last layer. They the top layer they felt 3. Okay, so think about ": [
      827.5,
      852.0,
      21
    ],
    "is actually equal to 2. Okay, so it's like one of these songs that the each summation each next term is small enough that it will convert to some number there for this whole song is got to be less than 2 end, which is bigger event. Okay, so maybe you could do this as an exercise. Any questions about that? So you need to do it by there's an ": [
      1063.1,
      1100.3,
      28
    ],
    "it like this. Let's assume that and is equal to 2 to the K - 1 so it's just like this full tree, right and you can kind of think about it like that. So there are K - 1 levels. or actually K levels, but I wanted to say it like there are levels 02 K -1 you put in half of the vertices, right? or around half Paint ": [
      852.0,
      893.1,
      22
    ],
    "it's just I'm thinking about a different way to do it. But any other okay. Well, yeah, if you're if you're talking about anything that like you're going to the date is going to be more useful to you in sorted order then usually you need like an analog anything but Okay, so let's let's go to towards what prims algorithm does. So instead of putting a priority queue of ": [
      2302.4,
      2346.8,
      55
    ],
    "just a positive Edge weights and your output is a list of edges that describes the minimum spanning tree, right if I just give you the edges that's enough to reconstruct the tree. Okay, here's the idea and we're going to do it and sort of like a high-level with sets. So put all of the vertices in you. pick any random vertex and put it in x And then ": [
      1658.2,
      1684.5,
      41
    ],
    "my output and now you put GNX. Okay. So now I now you look at only the edges that are crossing over the boundary of X, which one is the lowest. There's two lowest you can pick either or so. Which one do you want to pick? stop d Big D and now this is ax and then we have DG. Okay, and then this one is the lowest right? ": [
      1746.1,
      1786.4,
      44
    ],
    "n log in right? Because maximum you're going to have to Bubble Up the entire length of the tree to get to the top in the worst-case really but this is just an upper bound, right cuz we're doing worst-case. What about a lower bound well, Let's think about what happens every time you put in a new element. It's going to be K log K with a number of ": [
      372.7,
      404.6,
      8
    ],
    "networks is actually like generating money is subsidized so you don't want to cut that one. Cuz then you're starting to lose my gut. So let's think I mean this problem actually. With or without negative edges we can we can still talk about the minimum spanning tree, right? So but let's think more of positive edges. I like that better or Cuz of zero edge of kind of like, ": [
      1385.7,
      1419.2,
      36
    ],
    "of this some are all bigger than login / 2. And so you have an over two of those? I'll just I'll just leave this as an exercise for you guys. Okay, and what are the exercise I really want you guys to do is this part? I want you to do the Omega part, right? Because the big old part is is easy. Let's move on from that. That's ": [
      490.7,
      535.2,
      11
    ],
    "of those edges cuz they're all the same weight. So let's pick this one. ETF Okay, any questions about that? Okay good is so straightforward. You understand how it works, right? I have that again. Okay, that's fine. All right, let's try to go from high-level to a mid-level. So This is the high-level algorithm that I just presented to you. What we need to do is figure out how ": [
      1830.9,
      1863.1,
      46
    ],
    "or all of the vertices are connected or the whole graph is connected. So for example, you can have something that looks like this this would be a spanning tree something like that the tree so So any output tree of DFS or BFS is a spanning tree also, right because it contains all the vertices and the output. Is this sort of DFS output tree or BFS output tree. ": [
      1217.8,
      1251.0,
      32
    ],
    "or give me an example of a minimum spanning tree take a few minutes to talk it over with your neighbor just figure out which edges do I need to make a minimum spanning tree? Let's go with this purse. What is the cost? of the minimum spanning tree All right. So, what did you guys get for the cost? 12 anybody can do better than that. Can I see ": [
      1511.8,
      1607.8,
      38
    ],
    "or let them trickle down to swap them see if it works out. Yeah. Okay great. So then you do that. Alright, which one else what other ones you want to swap? Can ask go with the lower child? Cuz if you traded B, then B would be over at night. And so then E-Trade with h. And then and then just leave it there. It's fine, right? This week ": [
      676.8,
      708.7,
      17
    ],
    "pretend those are right because rap, okay. Okay. Now if I put it like this than their right? Right. Okay, then you're right. Okay, so that a just had to go down one and now you have the binary Heap. Okay, so noticed that the first level I put in two to the three vertices then I put into the two then I put into the one that I put ": [
      796.7,
      827.5,
      20
    ],
    "problem. They're called prim's and kruskal's we're going to look at Prince first, okay. Crossroads kind of is more of the More obvious way to do it, but prim's algorithm. I wanted to present it now because you'll see it's a lot like what we've just been talking about. Okay, so prim's algorithm. What what do you want to do? You given a graph with positive Edge weights or it's ": [
      1630.5,
      1658.2,
      40
    ],
    "repeat this process until all vertices are in X in the process is look at all the edges that cross over the boundary of X meaning all the edges where one endpoint is in X, and the other endpoint is in you. And out of all of them pick the edge with the lowest weight and then put that put that endpoint in Acts and repeat. Let's look at how ": [
      1684.5,
      1709.8,
      42
    ],
    "save money on the cost. Thanks. So you're going to try to find the minimum spanning tree of that Network right? It's going to be the minimum total cost where you can keep everything connected. Okay. So the first kind of thing we should think about is does this necessarily have to be a tree? Is the minimum cost connected graph has to be a tree? Psy Okay, good. So ": [
      1279.8,
      1319.5,
      34
    ],
    "that case. You just put them in and you're done. The next step is to put is to fill in these for gaps right with these next four vertices. Now at this point you might have some vertices that are sort of in the wrong position. So let them trickle down into their right position. So notice how OMD are in the they're in the wrong. Position so swap them ": [
      644.0,
      676.8,
      16
    ],
    "that cost is what we're going to use to pick the next protect. So it's the same thing we did with dijkstra's. Okay, and the way that we update it is. If its cost is bigger than the weight of the edge that's coming out of the set X then update it to that way. Okay, and so then we can actually take dijkstra's algorithm and change only the name ": [
      2611.3,
      2651.1,
      64
    ],
    "that has and then we're going to look at another problem that you can use the priority queue to solve. Okay. So the first thing I want to revisit is the binary Heap And for this for dijkstra's algorithm, this is not super important because when we make the heat for dijkstra's algorithm, you can just put the starting vertex at the root and then you can put all other ": [
      114.0,
      143.4,
      2
    ],
    "the Okay. So every time you move a vertex in to act put all of its outgoing edges into a priority queue, okay, so that means that you can have this priority queue fill with edges and you can pick the lowest one each time. good song me just kind of to give another slide cuz actually wasn't thinking about doing it that way, but that's great. Okay, so keep. ": [
      2215.1,
      2253.6,
      53
    ],
    "the biggest think how would you do that? Okay, ready go. How do we find the minimum edge with one vertex in X and one vertex in you? Good night. birthday gif Okay. So before I have anybody shares their their idea, I want to present to you like a a first kind of. sort of not a Brute Force way, but kind of a direct way to do this ": [
      1888.8,
      2055.8,
      48
    ],
    "the bottom layer has around half of the vertices. Okay, and then the second pass you put in a quarter of the vertices, but you might have to do two operations pervert X you need to put it in and it might have to fall twice. Right and then the third pass you put in an eighth of the vertices, but you might have to do three operations you put ": [
      893.1,
      914.6,
      23
    ],
    "the job it's it's it's something that will the solve the problem but this is not super efficient, right? Because basically this means that every time you go through This Loop here. I need to Loop through all the edges and I'm going through this Loop V number of times right because I'm trying to put every vertex into acts. So with this implementation you get a runtime of Big ": [
      2154.7,
      2181.7,
      51
    ],
    "the list were ordered you can just put them in in order and we'll be fine. So and that would take end time. Of course if they're just in some scrambled order. So the first thing to do is fill in the bottom layer, right? Mystery has three layers. And so this is two to the three vertices. Can make sense to put them in and that's in the in ": [
      617.2,
      644.0,
      15
    ],
    "the next layer. Okay. We going to save any time by doing this. I think we should kind of see what happens, right? Okay, so let's suppose we have all these vertices and these are just objects with their keys and notice. They're not in any particular order right there just kind of scrambled and and this problem is to have a you know, an unordered list, right? Cuz if ": [
      588.4,
      617.2,
      14
    ],
    "the whatever vertex in X and then update the cost of all of its neighbors. then put the lowest cost in 2X and update all of its neighbors and then keep on doing that until everything is in x queso in Moore You can sort of see the similarities instead of using disc now. We're using cost and they're just they're both just a raise of numbers. You just update ": [
      2544.0,
      2571.8,
      62
    ],
    "them differently. Okay, so we can use the exact same algorithm structure. Okay, so let's just go through this quickly. pick any random vortex do all the initializations right? So the costs are infinity and all this stuff just like we did before. And this whole part here. Is just regular Graph Search like we did before except for we are picking vertices carefully and we're updating the cost and ": [
      2571.8,
      2611.3,
      63
    ],
    "them in and then each one may fall to levels, right? And so in general for the jpas you have to do J times and over to the jail operations. And in the top half you have to do pay times and over to the operations work a is the number of levels and another way to write K is it's a round log base 2 of n so really ": [
      914.6,
      944.9,
      24
    ],
    "then for each subsequent object. You keep on putting it into the next available position and let it bubble up. and so this is like a Recursive function to do it, right? You're just basically inserting the big Dino than the next element into the heat that you've already made myself. Take a minute to talk it over with your neighbor. How long do you expect this to take? Where ": [
      239.1,
      273.0,
      6
    ],
    "thing. Okay, any questions about that? Nobody's curious about the correctness. You just trust that it works since it's in the bucket has a fancy name. It'll work. Well luckily for you guys or maybe unluckily for you guys. You're going to have to wait till next week for the correctness proof. But before you guys go. Sorry. The next thing we're going to do is the greedy approach. So ": [
      2723.5,
      2764.6,
      67
    ],
    "this insertion over and over again. Let's look at it like more like a pseudocode or implementation level. function to do this Okay, how long do you expect this function to make two how long do you expect this function to run? If it takes to make a binary heat from an object each with a key-value. So you start with your first object put it in the Heap and ": [
      204.8,
      239.1,
      5
    ],
    "this is around log base 2 of n * 10/2 to the log base 2 of n which is log base 2 of N and that makes sense because when you add in that last vertex, it might have to fall the entire length of a tree. Okay, so The whole runtime of this algorithm is the sum of all of these things, right? We have this some right and ": [
      946.0,
      977.3,
      25
    ],
    "this is just what we what we said before. Okay, I cleaned it. This song is Big O of n Anybody believe me? Okay, so if it's all of n then you have a linear sorting algorithm. Okay, how would that work? Yeah, right just building the heat takes big event. But if you wanted to like sort them with the heat, then it would you know login. Okay, so ": [
      977.3,
      1021.8,
      26
    ],
    "this would work. Which Edge do you guys want to start from? How about you? That sound good. Doesn't matter. so that red that red circle that will be X. Okay. So look at all the edges that cross the boundary of xor that start in X and end in you so which one has the lowest weight? Is this one 1/2 G Wright? so Angie will be part of ": [
      1709.8,
      1746.1,
      43
    ],
    "to do these operations. I mean, I did it right before your eyes, but I was kind of implying or using common sense and intuition to kind of just figure it out. So with your neighbors discuss how you would Implement prim's algorithm. How would you do these things? And what are the things that I'm asking is well, How would you find this minimum Edge? I think that's big ": [
      1863.1,
      1888.8,
      47
    ],
    "to make a binary heat from n objects each with a key value? Well, we didn't really talk about this operation insert, but if you think about inserting inserting a note. You can kind of place it at the very last position and let it bubble up right and then that will be some way to put it in. So one idea for creating a a heap. is 2 Use ": [
      172.8,
      204.8,
      4
    ],
    "to see if one if each endpoint is in Acts and not an ax right then pick the minimum 1 and that'll be my next Edge right and then move the vertex in queso Loop through. all edges Check endpoints. and find minimum that looks a that crosses. boundary of x and then output the edge and then change Boolean of that important Facebook is great because this what does ": [
      2089.5,
      2154.7,
      50
    ],
    "to up to n of log I so is this an login is this big Theta of n login? It's certainly big out right because you can bound every one of these things above by login, but is it big betta? 1 1 + 2 + 2 + it still ends. Yeah, it's true. Sure. Yeah, one way you can look at it is that So the the last half ": [
      441.4,
      490.7,
      10
    ],
    "vertex to put an X based on its cost and what is its cost its cost is what is the lightest Edge that's coming from X to that vertex? Okay, so let's just I just kind of added a few remarks to the other description so you can see where I changed it. so basically for all the vertices update the cost to be the weight of the lightest Edge ": [
      2374.1,
      2407.5,
      57
    ],
    "vertices in the heat at random, right because they all start with infinity as their key value. Okay, but let's suppose you're using the heat for something else and you want to make a heat out of a bunch of objects that all have kind of random key values and they don't come come to you in any particular order Okay, so How long do you expect it to take ": [
      143.4,
      172.8,
      3
    ],
    "well, it's sort of like not even there. So it doesn't matter if it's like I says your age would be better than any other rash. a listing of positive edges Okay, wait, so why something happened here? I opened up the wrong thing. Did I? Hold on. Let me just see something here. syros 2 Okay good. Didn't have the most updated version. What's the minimum spanning tree here ": [
      1419.2,
      1511.8,
      37
    ],
    "when when is it connected graph not a tree is when? there Is a cycle? And then if you cut any of the cycle edges the grass stays connected. connected right suck just cut any of those cycle edges and your cost will go down. Is that assuming everything? resuming Edge weights are non negative What would that mean in that computer network? That would mean that one of those ": [
      1319.5,
      1385.7,
      35
    ],
    "work. Let's do the same starting place. Okay, so we start with Z 0 and all of these are Infinity, right? So you put me into X and you update all of its neighbors. So be now becomes 2D becomes 3. FB comes for Angie becomes one then you look at the minimum vertex, right? Cuz that's going to be corresponding to the minimum Edge coming out which is G. ": [
      2437.0,
      2475.0,
      59
    ]
  },
  "Class Name": "cse101",
  "Date": "01252019",
  "Full Transcript": "Listen to a podcast.  High class seems like I'm having some technical problems. So just give me a second. I'm going to turn it off and then turn it back on again.  Tends to happen sometimes in this room.  Anybody have any questions before we begin?  It looks like it's working good.  To do it like that.  Okay, great.  alright, so  last time we we took the time to  Talk about dijkstra's algorithm in detail. Right? We proved its correctness sit and talk about how to implement. It talks about sort of a mid-level description where we could we could sort of put different implementations in there to get different run times. And and so today we're going to look a little bit more into the priority queue and what you can do with it and what type of features that has and then we're going to look at another problem that you can use the priority queue to solve. Okay. So the first thing I want to revisit is the binary Heap  And for this for dijkstra's algorithm, this is not super important because when we make the heat for dijkstra's algorithm, you can just put the starting vertex at the root and then you can put all other vertices in the heat at random, right because they all start with infinity as their key value.  Okay, but let's suppose you're using the heat for something else and you want to make a heat out of a bunch of objects that all have kind of random key values and they don't come come to you in any particular order Okay, so  How long do you expect it to take to make a binary heat from n objects each with a key value? Well, we didn't really talk about this operation insert, but if you think about inserting inserting a note.  You can kind of place it at the very last position and let it bubble up right and then that will be some way to put it in.  So one idea for creating a a heap.  is 2  Use this insertion over and over again.  Let's look at it like more like a pseudocode or implementation level.  function to do this  Okay, how long do you expect this function to make two how long do you expect this function to run? If it takes to make a binary heat from an object each with a key-value. So you start with your first object put it in the Heap and then for each subsequent object. You keep on putting it into the next available position and let it bubble up.  and so this is like a  Recursive function to do it, right? You're just basically inserting the big Dino than the next element into the heat that you've already made myself. Take a minute to talk it over with your neighbor. How long do you expect this to take?  Where insert takes login in the number of levels?  Kelley Blue Book  actually, let me do something real fast.  Even though it's like it's supposed to be less than 10 times at right now.  Is that not working anymore?  Crap, what do I do?  Okay good.  Okay. So what are you guys say?  And login, how did you get that?  Okay.  Okay good. So it certainly will take Big O of n log in right?  Because maximum you're going to have to Bubble Up the entire length of the tree to get to the top in the worst-case really but this is just an upper bound, right cuz we're doing worst-case. What about a lower bound well,  Let's think about what happens every time you put in a new element. It's going to be K log K with a number of elements that are already in there. So really the number in the worst-case you're going to do one log.  Well that doesn't really make sense that start with to log to  2 log 2 + 3 log 3  + 4 log 4  all the way up to Plus  nowait Nazis  All the way up to log in this is what it is, right?  so it's the song from I equals to up to n of log I  so is this an login is this big Theta of n login?  It's certainly big out right because you can bound every one of these things above by login, but is it big betta?  1 1 + 2 + 2 + it still ends.  Yeah, it's true.  Sure. Yeah, one way you can look at it is that  So the the last half of this some are all bigger than login / 2.  And so you have an over two of those?  I'll just I'll just leave this as an exercise for you guys.  Okay, and what are the exercise I really want you guys to do is this part?  I want you to do the Omega part, right?  Because the big old part is is easy. Let's move on from that. That's fine. We have something to make a heap in and login time. And and that's fine. Okay.  Can we improve on this bound we improve on this run time? Okay. So what if we so in in this sense, we started kind of putting it put the first one at the root and then keep on putting them into the tree and building the tree one by one like that. What if we put them in the opposite order? Would that help out?  Here is a beer say a way to make a heap. Let's fill in the bottom layer of the heat first. Okay, just randomly, then we'll fill in the next layer. And as we fill it in will update by letting those vertices trickle-down if they need to write and then build the next layer and build the next layer. Okay. We going to save any time by doing this.  I think we should kind of see what happens, right?  Okay, so let's suppose we have all these vertices and these are just objects with their keys and notice. They're not in any particular order right there just kind of scrambled and and this problem is to have a you know, an unordered list, right? Cuz if the list were ordered you can just put them in in order and we'll be fine. So and that would take end time. Of course if they're just in some scrambled order. So the first thing to do is fill in the bottom layer, right?  Mystery has three layers. And so this is two to the three vertices.  Can make sense to put them in and that's in the in that case. You just put them in and you're done.  The next step is to put is to fill in these for gaps right with these next four vertices.  Now at this point you might have some vertices that are sort of in the wrong position. So let them trickle down into their right position. So notice how OMD are in the they're in the wrong.  Position so swap them or let them trickle down to swap them see if it works out. Yeah. Okay great. So then you do that. Alright, which one else what other ones you want to swap?  Can ask go with the lower child? Cuz if you traded B, then B would be over at night. And so then E-Trade with h.  And then and then just leave it there. It's fine, right?  This week at the idea.  Next stage is to put the next two on there right and let those trickle-down. So change G with what?  F and then trade G with what beer k  Oh, I didn't do it yet.  Shoot wait, I trade it with K. This is  this is all messed up.  All right. I'll just do it like this.  Wait a minute. Ya B10 and G22.  Sorry about that.  I thought it was all nice and works nicely, but it doesn't so.  Okay, I'll fix it up in the slides and you guys can see it but you get the idea right questions.  Alright, so then now it looks okay and then you just put the last vertex on and did I?  Oh crap.  Now, this is Ron still.  Know what is it K12 Frank?  Okay.  Okay now just pretend those are right because rap, okay.  Okay. Now if I put it like this than their right?  Right. Okay, then you're right. Okay, so that a just had to go down one and now you have the binary Heap. Okay, so noticed that the first level I put in two to the three vertices then I put into the two then I put into the one that I put into the zero, right and so think about how far they fell in the first layer. They didn't follow it all the second layer. They fell one level the third layer they fell two levels or sorry.  The Pearl are they felt nothing the second layer they fell won the first layer they fell to in the last layer. They the top layer they felt 3. Okay, so think about it like this.  Let's assume that and is equal to 2 to the K - 1 so it's just like this full tree, right and you can kind of think about it like that. So there are K - 1 levels.  or  actually K levels, but I wanted to say it like there are levels 02 K -1 you put in half of the vertices, right?  or around half  Paint the bottom layer has around half of the vertices. Okay, and then the second pass you put in a quarter of the vertices, but you might have to do two operations pervert X you need to put it in and it might have to fall twice. Right and then the third pass you put in an eighth of the vertices, but you might have to do three operations you put them in and then each one may fall to levels, right? And so in general for the jpas you have to do J times and over to the jail operations. And in the top half you have to do pay times and over to the operations work a is the number of levels and another way to write K is  it's a round log base 2 of n  so really  this is around log base 2 of n * 10/2 to the log base 2 of n  which is log base 2 of N and that makes sense because when you add in that last vertex, it might have to fall the entire length of a tree.  Okay, so  The whole runtime of this algorithm is the sum of all of these things, right?  We have this some right and this is just what we what we said before.  Okay, I cleaned it. This song is Big O of n  Anybody believe me?  Okay, so if it's all of n then you have a linear sorting algorithm. Okay, how would that work?  Yeah, right just building the heat takes big event. But if you wanted to like sort them with the heat, then it would you know login.  Okay, so  Wait, what happened to my other thing again? Well just write it. Okay. So this is contingent on the fact that this is equal to n x  J equals one up to login  Jay over to the Jay you can factor out that end and now this here.  Is actually a convergent sum.  so this is  J equals one up to Infinity I or J over 2 to the J is actually equal to 2.  Okay, so it's like one of these songs that the each summation each next term is small enough that it will convert to some number there for this whole song is got to be less than 2 end, which is bigger event.  Okay, so maybe you could do this as an exercise.  Any questions about that?  So you need to do it by there's an induction proof with it, or you can do it with an integral you could show that the integral is is a finite value something like that.  Any other questions?  Okay, good. So make you  of an object's  it takes us a  text Big O of end time.  There are four for our algorithm dijkstra's algorithm. It's going to  doesn't really matter if it takes end timer and log in time because the whole algorithm takes more than n log in time anyway, but  I don't know. Maybe you need this in a different if a different for different purpose, right? It's a nice way to organize data.  And it makes for finding you know, the the lowest value really easy.  Okay, let's move on to another problem minimum spanning trees. Okay. What is a minimum spanning tree? Will first let's define. What is a spanning tree spanning tree is a subgraph of a connected undirected graph. They so we're moving into kind of chapter 5 5.1. We talked about minimum spanning trees and whenever I say Graff I'm always thinking of an undirected.  I should say connected.  connected graph  Okay, so I spanning tree is just a subgraph that's a tree and all of the vertices are in the graph or all of the vertices are connected or the whole graph is connected. So for example, you can have something that looks like this this would be a  spanning tree  something like that the tree so  So any output tree of DFS or BFS is a spanning tree also, right because it contains all the vertices and the output. Is this sort of DFS output tree or BFS output tree.  Okay, so why would you want to do this think about an example where you have like a bunch of computer networks or computers a network of computers that are linked pairwise and each link has some sort of operational maintenance cost. So you want all the computers to stay connected but you want to take get rid of the cost that some of the links so that you can save money on the cost. Thanks. So you're going to try to find the minimum spanning tree of that Network right? It's going to be the minimum total cost where you can keep everything connected.  Okay. So the first kind of thing we should think about is does this necessarily have to be a tree?  Is the minimum cost connected graph has to be a tree?  Psy  Okay, good. So when when is it connected graph not a tree is when?  there  Is a cycle?  And then if you cut any of the cycle edges the grass stays connected.  connected  right suck just cut any of those cycle edges and your cost will go down.  Is that assuming everything?  resuming  Edge  weights  are non negative  What would that mean in that computer network? That would mean that one of those networks is actually like generating money is subsidized so you don't want to cut that one.  Cuz then you're starting to lose my gut. So let's think I mean this problem actually.  With or without negative edges we can we can still talk about the minimum spanning tree, right? So but let's think more of positive edges. I like that better or  Cuz of zero edge of kind of like, well, it's sort of like not even there. So it doesn't matter if it's like I says your age would be better than any other rash.  a listing of positive edges  Okay, wait, so why something happened here?  I opened up the wrong thing.  Did I?  Hold on. Let me just see something here.  syros  2  Okay good.  Didn't have the most updated version. What's the minimum spanning tree here or give me an example of a minimum spanning tree take a few minutes to talk it over with your neighbor just figure out which edges do I need to make a minimum spanning tree?  Let's go with this purse. What is the cost?  of the minimum spanning tree  All right. So, what did you guys get for the cost?  12  anybody can do better than that.  Can I see how we can get 12? I think if we do these guys here and the three in the fourth, right. Org. Okay, good. I'll bring them you use you might have used why don't know a certain type of algorithm to do this or you might have just kind of figured it out or played around with it. So we're going to look at two main algorithms to solve this problem. They're called prim's and kruskal's we're going to look at Prince first, okay.  Crossroads kind of is more of the  More obvious way to do it, but prim's algorithm. I wanted to present it now because you'll see it's a lot like what we've just been talking about.  Okay, so prim's algorithm. What what do you want to do? You given a graph with positive Edge weights or  it's just a positive Edge weights and your output is a list of edges that describes the minimum spanning tree, right if I just give you the edges that's enough to reconstruct the tree.  Okay, here's the idea and we're going to do it and sort of like a high-level with sets. So put all of the vertices in you.  pick any random vertex and put it in x  And then repeat this process until all vertices are in X in the process is look at all the edges that cross over the boundary of X meaning all the edges where one endpoint is in X, and the other endpoint is in you.  And out of all of them pick the edge with the lowest weight and then put that put that endpoint in Acts and repeat.  Let's look at how this would work.  Which Edge do you guys want to start from? How about you?  That sound good.  Doesn't matter.  so  that red that red circle that will be X. Okay. So look at all the edges that cross the boundary of xor that start in X and end in you so which one has the lowest weight? Is this one 1/2 G Wright?  so  Angie will be part of my output and now you put GNX.  Okay. So now I now you look at only the edges that are crossing over the boundary of X, which one is the lowest.  There's two lowest you can pick either or so. Which one do you want to pick?  stop  d  Big D  and now this is ax and then we have DG.  Okay, and then this one is the lowest right? So we have DEA.  Put that in there.  So now we have three edges of wait to sweep pick any of them. Let's pick this one to see  Sorry, I don't have an animation for this.  AC  and then we also have two edges that are weight to those are both going to be so let's pick. I don't know this one.  Hey B.  And now we can pick any of those edges cuz they're all the same weight. So let's pick this one.  ETF  Okay, any questions about that?  Okay good is so straightforward. You understand how it works, right?  I have that again. Okay, that's fine. All right, let's try to go from high-level to a mid-level. So  This is the high-level algorithm that I just presented to you. What we need to do is figure out how to do these operations. I mean, I did it right before your eyes, but I was kind of implying or using common sense and intuition to kind of just figure it out. So with your neighbors discuss how you would Implement prim's algorithm. How would you do these things? And what are the things that I'm asking is well,  How would you find this minimum Edge?  I think that's big the biggest think how would you do that? Okay, ready go.  How do we find the minimum edge with one vertex in X and one vertex in you?  Good night.  birthday gif  Okay. So before I have anybody shares their their idea, I want to present to you like a a first kind of.  sort of  not a Brute Force way, but kind of a direct way to do this cuz I'm sure some of you seen prims and maybe you have the idea of how to do it efficiently. But let's just think about how do I first do this? Well, my first instinct would say, okay. What I'm going to do is keep  the Boolean array  4X right. So it's basically the visited array right? And so then I'm going to go through all my edges and check to see if one if each endpoint is in Acts and not an ax right then pick the minimum 1 and that'll be my next Edge right and then move the vertex in queso Loop through.  all edges  Check endpoints.  and find minimum  that looks a that crosses.  boundary of x  and then  output  the edge  and then change  Boolean  of that important  Facebook is great because this what does the job it's it's it's something that will the solve the problem but this is not super efficient, right? Because basically this means that every time you go through  This Loop here. I need to Loop through all the edges and I'm going through this Loop V number of times right because I'm trying to put every vertex into acts. So with this implementation you get a runtime of Big O of the x e  That's a good first step. Anybody want to share their ideas on how to make it more efficient.  From your ex the ones that are connected to the wants to know when you put something in X put all the edges and a priority queue.  Cuz that's when you put moved from v2x whenever you do that for you to that birthday.  Look at all the  Okay. So every time you move a vertex in to act put all of its outgoing edges into a priority queue, okay, so that means that you can have this priority queue fill with edges and you can pick the lowest one each time.  good song  me just kind of  to give another slide cuz actually wasn't thinking about doing it that way, but that's great.  Okay, so keep.  a priority queue  of edges  Okay, so then you can use power to keep any other ideas.  But we do a priority queue with edges. Let's say we do it use a keep right then every time you do every time you pick a minimum value.  if to do log e many operations  So how long would that run?  And log E. I guess which is pretty good.  Okay. Maybe it's just  I'm thinking about a different way to do it. But any other  okay.  Well, yeah, if you're if you're talking about anything that like you're going to  the date is going to be more useful to you in sorted order then usually you need like an analog anything but  Okay, so let's let's go to towards what prims algorithm does. So instead of putting a priority queue of edges. We can actually use a priority queue of vertices.  Okay, and so instead of keeping track of the edges, let's keep track of the endpoints of those edges. Cuz those are the things that really matter right? Those are the things. I'm going to be putting into my ex.  Okay. So now we're going to have this cost value for each vertex and we're going to pick the next vertex to put an X based on its cost and what is its cost its cost is what is the lightest Edge that's coming from X to that vertex?  Okay, so let's just I just kind of added a few remarks to the other description so you can see where I changed it.  so basically  for all the vertices update the cost to be the weight of the lightest Edge connecting it to a vertex in X right find the minimum Edge this just translates to find the vertex outside of X that has the lowest cost.  And then once you move the edge into X update all the cost again and keep on going, but let's look at see how that works.  queso  I don't have a nice animation, but you can sort of see how it's going to work. Let's do the same starting place. Okay, so  we start with Z 0 and all of these are Infinity, right?  So you put me into X and you update all of its neighbors. So be now becomes 2D becomes 3.  FB comes for  Angie becomes one  then you look at the minimum vertex, right? Cuz that's going to be corresponding to the minimum Edge coming out which is G.  And now update only the neighbors of G because those are the only ones that are going to change once you put that vertex in. So that's where we're going to get the better efficiency.  Okay, and Saudi updates to 2.  Okay, dendy, A or B is the lowest One Source go a d so put D in there.  and now we get to update a  and so on.  Okay, I'll let you guys.  I have your imagination to how this story ends.  Okay, how do we Implement Prince while when do we update a Vertex? It's only when another vertex is put into X so you can start seeing the the similarities between this and dijkstra's algorithm.  so let's think about it an in kind of  use this cost to make our decisions now initialize all the cost put the whatever vertex in X and then update the cost of all of its neighbors.  then put the lowest cost in 2X and update all of its neighbors and then keep on doing that until everything is in x  queso in Moore  You can sort of see the similarities instead of using disc now. We're using cost and they're just they're both just a raise of numbers. You just update them differently.  Okay, so we can use the exact same algorithm structure.  Okay, so let's just go through this quickly.  pick any random vortex  do all the initializations right? So the costs are infinity and all this stuff just like we did before.  And this whole part here.  Is just regular Graph Search like we did before except for we are picking vertices carefully and we're updating the cost and that cost is what we're going to use to pick the next protect. So it's the same thing we did with dijkstra's. Okay, and the way that we update it is.  If its cost is bigger than the weight of the edge that's coming out of the set X then update it to that way.  Okay, and so then we can actually  take dijkstra's algorithm and change only the name disc to cost and then the way that it updates and it's the same thing.  Pretty cool. So let's look at the run time since since all we did was change in a few letters and things like that. We didn't really change the run time. So this shares the same run time as dijkstra's one big difference here is that prims only allows for connected graphs to ever be a input and so all connected graphs have is Big Omega of V.  Because that very worst you have a tree and you have V - 1 edges. So so that means that with a binary Heap instead of v+ elog V now. It's just you lock me.  Okay, and that backslash didn't compile this fine?  And then the array is also vsquare so you get the same sort of thing.  Okay, any questions about that?  Nobody's curious about the correctness.  You just trust that it works since it's in the bucket has a fancy name. It'll work. Well luckily for you guys or maybe unluckily for you guys. You're going to have to wait till next week for the correctness proof.  But before you guys go.  Sorry.  The next thing we're going to do is the greedy approach. So if you already know what it is then read up on it, and if you don't then think about what does that mean the greedy approach try to keep on at the next Edge that will contribute the least amount to each thing.  What's up?  I'll post it today and I also post some practice problems for the quiz.  Bank of America 4105 should come a different time. Are you free this afternoon or this evening? But next week I was doing next week. Yeah, I would like some I would appreciate some! I still want to get it. Yeah. Sure.  I don't know maybe even Monday you can come talk to me after class.  example for the greedy  did you like that? Alright, I'll do that.  San Diego ",
  "Section": "a00",
  "Time": "1500",
  "Video URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-01252019-1500.mp4",
  "Audio URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-01252019-1500.mp3",
  "File Name": "lecture_8.flac"
}