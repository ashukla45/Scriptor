{
  "Blurbs": {
    "01 really helped so much because then all possible. Write we care about the length of the path. But we're trying to reduce it to shortest path. negative are there any questions about that? We just solved that problem right just build this graph and run shortest path on it. How are we so sure that the path is going to be a dag. It's kind of like by the ": [
      1337.2,
      1374.7,
      32
    ],
    "Ford algorithm. and basically what it does is it returns negative cycle if it finds one and or else it turned returns all the shortest paths and here here's pseudocode when you can go over it later if you like, but you basically Runty from one up to n and do the the recursion. And then after that you basically just check to see if any of the is it ": [
      2510.5,
      2541.8,
      59
    ],
    "Got any questions about that? Okay. So this is basically the recursion is that distance X is equal to you take the minimum of all the incoming edges and you add their length plus the distance. Okay ordering. Well the trick here to order the vertices is in topological order. You can see why that helps because once you get to a Vertex, you know that there's no edges going ": [
      871.1,
      902.9,
      20
    ],
    "I have from before. Let's look at vertex J K if I want to compute the shortest distance from let's say s is equal to be. Okay, so I'm trying to compute the distance from B to Jay. Look locally around J. What is this J dependent on? Write the shortest of all the different distances, but I guess another way to say is what vertices do you need to ": [
      785.4,
      824.5,
      18
    ],
    "Listen to a podcast. What the heck? All right. Here we go. I'm having some technical difficulties. I'm having some technical difficulties with the computer. So it all. I think it'll be fine after I restart it. Okay, before we begin, does anybody have any questions? Put up a new homework homework 7 and if you noticed I put the first problem the last problem of the other homework kind ": [
      1.9,
      110.7,
      0
    ],
    "So be goes to hey with 4 he with eight. he was 5 and so on so you can just put it all the edges and If I did this correctly then all the edges will be going in One Direction and you can keep on kind of computing these distances as you got. linear topological sorting takes big O of the Plessy Remember cuz all you do is you ": [
      931.8,
      982.1,
      22
    ],
    "W Prime then he found a Arbitrage and if there's no negative cycle, then you can find the best exchange rate, which means basically maybe instead maybe I'm getting the best exchange rate from dollars to Euros. It's better if you exchange it into pounds and then Yen and then pesos and then into Euros, maybe there's like some sort of thing. So that's also what does algorithm can do ": [
      2845.0,
      2867.0,
      69
    ],
    "We're actually okay with the grass this this process is going to work with a graph with negative Cycles right because We're not letting it run free until it finds the best thing or just only letting it run with this budget. Okay. So what simple question can we ask to split up the possible paths from v02 VI right? We're trying to figure out what this recursion is going ": [
      1925.1,
      1950.1,
      46
    ],
    "What is the negative cycle? It's basically when you have a cycle in a graph and the sum of all the edges is a negative number. What is this graph have a negative cycle? Yes, what is it? so a b or a c EB Wright negative cycle and what about EBD is that a negative cycle? not negative cycle questions about that Okay, good. So The problem with having ": [
      1413.0,
      1474.1,
      34
    ],
    "What's the maximum increasing subsequence in this array? I think it's what 8 11 12 16 25. I think that's about right. Okay, so we can just forget about the graph stuff and solve this problem using dynamic programming kind of how we were doing it before but let's see how we can reduce it to shortest path. Okay, so what could the vertices be? any ideas Okay, each number ": [
      1232.2,
      1284.3,
      30
    ],
    "a dynamic programming problem. Let me just kind of state the problem now. the input is going to be a graph with vertices v-0 through the n Okay. And they may have Negative Edge weights will think about the negative Cycles as we go along and see kind of what role they play. But if we put a budget on the number of edges, we don't really have to worry ": [
      1680.8,
      1714.1,
      41
    ],
    "a negative cycle. Is that now? If you trying to find the shortest path, there are some pairs of vertices where the shortest path is unbounded from below for example. What is the shortest path from a to c? well If you go this way, you get -2, but if you go around like that then you get what? -4 right Thank you. Go negative to positive 2. -6 negative ": [
      1474.1,
      1527.0,
      35
    ],
    "a nice function that changes products into sums. Basically take the negative log because we still are trying to find shortest paths. Okay, so what would be really good as if there were a psycho whose product was bigger than one right? This is the Arbitrage change here here here here here once you get back you get more than what you paid for. I'm in the first place. Okay, ": [
      2716.5,
      2745.4,
      65
    ],
    "a path. So what is this path look like you have v0? And VI. What's this vert.x here? What could it be? Any of its neighbors write any of its incoming Neighbors? So let's just take the minimum out of all those incoming neighbors. How do you get to all the incoming neighbors with T minus one edges and then add that other Edge? okay, so basically I already know ": [
      2133.7,
      2195.9,
      49
    ],
    "about it because we're saying what's the long? What's the shortest path with this many edges or fewer? Casey also get a tea, which is our budget. Okay, so let's set up the sub problems. What do you guys think? Kind of like the same sorts of sub problems we've seen before this is going to have two parameters i&t. So we're going to say be of it is the ": [
      1714.1,
      1749.7,
      42
    ],
    "after s in topological ordering right. Those are the only bird of vertices that you're going to be able to reach. I guess maybe what we should do is also initialise distance of the eye to be Infinity. for all bi not equal to a string so you can keep on updating. Okay, and then for every one of those vertices just set set it to be this distance value ": [
      1025.5,
      1056.0,
      24
    ],
    "backwards. So, you know, you don't ever have to update anything before so in that sense whenever you have updated of her text it done. It's been updated and you never have to update it again, so you can really just move along in a linear fashion. Any questions about that? Okay good. So here's a here's the topological ordering and then you can just put in the edges right? ": [
      902.9,
      931.8,
      21
    ],
    "be like 10 true-false questions. Something like that. Then there's going to be one or two graph problems a greedy problem divide and conquer problem and one or two dynamic programming problems. I mean in what sense? Like you mean for the true false? It's onion is cumulative. It's it's kind of like what I said, I mean I guess if I put two dynamic programming problems on there than ": [
      231.3,
      275.6,
      4
    ],
    "changed. but yeah. I didn't use Bellman Ford to find it though. It was just I just saw that these two exchange houses kind of exchange that these different rates. I should have done something about it. I couldn't believe it in the first place, but it turned out that I was going to Brazil at the time and I was living in Chile and it turned out that like ": [
      2780.2,
      2813.8,
      67
    ],
    "construction right where we're only I guess I should say this and eyes less than Jay. We're only connecting from earlier position to a later position. So they're already in topological order so you can just plug it in that way. You don't even have to store it in topological order. sup Let's move on. negative Cycles Okay, so we can run into a problem when there's a negative cycle. ": [
      1374.7,
      1413.0,
      33
    ],
    "dependent on that one to sell. It depended on that one and so on right? I guess let's do it by cell. So this cell. Is dependent on those three right until you can you can kind of put these arrows in for every single cell now instead of making it a dynamic programming problem. We're filling in an array we can think about it more in terms of a ": [
      555.9,
      585.0,
      11
    ],
    "dynamic programming today. I imagine that they will be a little bit more to do on Friday Also. And that's mainly the material for the final exam. We're we're going to talk a little bit about linear programming mainly with like these maxflow type of things and show how you can solve certain problems with it. Then we'll talk about p and NP briefly and then hopefully we'll have some ": [
      143.6,
      175.9,
      2
    ],
    "example. We feel that we filled kind of part way through it using the recursion. But if you like instead of doing it the way we did it you can think about it as a graph problem. Okay, and the idea here is there's going to be a Edge from one cell to another if it depends on it. So. This this cell is dependent on that one the cells ": [
      523.7,
      555.9,
      10
    ],
    "fact that all edgeways for positive in order to get that efficiency in order to show that each vertex only enters the priority Queue at most one time. But if there are negative edges, then it could it could go in there more than one time. And in fact, you can found it. It could actually be a exponential time the vertex could go into the party Q in exponential ": [
      1593.0,
      1619.0,
      38
    ],
    "for you. Okay, so maybe let's I do want to look at this one more algorithm, but we might have to save it until Friday, but maybe you guys can look at it in the book is called the Floyd warshall algorithm and it's basically it's very useful for this Arbitrage also, because it finds the best the shortest path between every pair of nodes instead of just from a ": [
      2867.0,
      2903.6,
      70
    ],
    "from v02 VI using at most two edges be one is the second to last for a tax fee to is a second and last for a tax defeat all the way to VN. I mean, this is kind of maybe going a little overboard because we don't need to consider all possible vertices. We just need to consider the actual neighbors incoming Neighbors. But let's just assume that maybe ": [
      2225.0,
      2248.3,
      51
    ],
    "good. And what about when is there going to be an edge? Okay, when a little number comes before a bigger number, okay, good. So There is an edge. from AI to AJ if AI is less than a j and I is less than Jay Wright. Okay, and now what are we going to what are going to be the edge length the the length of each Edge? well ": [
      1284.3,
      1335.4,
      31
    ],
    "graph problem that has Cycles right into a dad that doesn't have Cycles. I can't sew in order to do this. We're going to give ourselves a budget and this is also going to prevent us from going down. Any infinite Loops. We're going to say, what is the shortest path that I can have by only using at most team any edges? Okay. So let's let's turn this into ": [
      1650.3,
      1680.8,
      40
    ],
    "has improved in that and it'll rayshun and otherwise you just return it. Okay, why is this algorithm important? flight tickets or has anybody heard of currency Arbitrage? Okay, so We usually deal with exchange rates right as being determined. So you always lose a bit when you buy right when you go to The Exchange house they give you kind of They put a little bit more of a ": [
      2541.8,
      2578.5,
      60
    ],
    "how to get to all of the neighbors of the incoming neighbors of VI with T minus one edges. If if I'm ordering the sub problems correctly, right? So I pretty much figure out what's the minimum of all those things plus those Edge weights. You can kind of think I think of it as cases right que sera would be that v-0 is the second-to-last vertex in the past ": [
      2195.9,
      2225.0,
      50
    ],
    "is called the Arbitrage and it's a people do it. They they find them they don't last for very long. But once they find them they they go around that that sequence. Okay, so how how could we use Bellman Ford to find a currency Arbitrage? You basically make a graph where each vertex is a currency and the edges are going to be the exchange rate, right? There's kind ": [
      2644.5,
      2679.8,
      63
    ],
    "it's a complete graph and then we have to consider them all. Okay, so basically This is going to be our recursion be of it. Is going to be well. Look at all the possible incoming neighbors of VI. vjv, I figure out what is be of JT -1, right? That's the shortest path to get to that vertex with T minus one or fewer edges and then plus the ": [
      2248.3,
      2285.4,
      52
    ],
    "it's damn it prevent it from having something called and negative cycle, which is problematic. We'll talk about that in a minute. but Because we're able to do the shortest path in the presence of negative weights. We can find longest path just by negating all of the edge weights and then finding the shortest path, right? So it's kind of like a trick to reduce the problem produce longest ": [
      1159.6,
      1188.7,
      28
    ],
    "itself is a length zero. No, because we're starting we're starting at V 0. P0 is always the starting point. Okay good. Next Step I guess this is 0 Actually, let's just keep let's keep this as your 00, I like that better because I guess if there wasn't a negative cycle, then you could start getting a better path to the that Vortex v02 itself. Okay, so we're okay. ": [
      1863.5,
      1925.1,
      45
    ],
    "negative Cycles. That's good. So if we know beforehand that it does it doesn't have any negative cycles and this will work great and it and we're done and we don't have to do any more iteration. If we don't know if there are negative Cycles or not. Is there a way to detect this? Can we use this kind of idea of simple pads in order to detect if ": [
      2386.3,
      2412.5,
      56
    ],
    "number of times if you have like a really weird example. Okay, so our next kind of goal is to figure out how to find shortest path efficiently. In a graph with Negative Edge weights without negative Cycles, right? If there's negative Cycles, then we're kind of we can't we can't get the shortest path. Okay. So basically what I want to do is change this graph or change this ": [
      1619.0,
      1650.3,
      39
    ],
    "of carried over to a homework 7 save a little bit more time to think about it. I'll be giving you guys some practice problems for the for the final probably tomorrow question. Yeah, yes. Yes, you can finish it this one if you like, but you can you can carry over to the next one more. Yeah, so today we're Bates. We're going to try to finish up with ": [
      110.7,
      143.6,
      1
    ],
    "of one weird problem is that bellman-ford works? Well with sums where this is going to be products, right if I exchange one and exchange another you're going to multiply those exchange rates. Let's just go to the next thing you're trying to find a path that maximizes the product. right We want to minimize this some okay, how come we met products into sums? Take the log log is ": [
      2679.8,
      2716.5,
      64
    ],
    "on the number of edges of a simple path in a graph with n vertices? And might as well good. write hamiltonian happy happy hamiltonian path Right. So this is the this is the upper bound. So the idea here is we're going to set our our budget to be and -1 and that will give us all the shortest simple pads if there are no Negative Edge has no ": [
      2353.2,
      2386.3,
      55
    ],
    "pass through before you get to Jay? G&G right. So this Jay is going to have to be the minimum of Well the distance to E. + 5 and the distance to G. + 2 If we knew the distance to G and a distance to eat, but kind of looking ahead if we do it in topological ordering we're guaranteed to have visited e&g before we got to J. ": [
      824.5,
      870.2,
      19
    ],
    "path in dag to shortest path in Jag. So let's look at a application of this. Longest increasing subsequence. So suppose you had some list of integers a 1 through a end and increasing subsequence is a sequence that is increasing subsequence. That's increasing. Subsequence means that the they have to be in order, but they don't necessarily have to be contiguous. so for example 51620 that's a increasing subsequence. ": [
      1188.7,
      1230.1,
      29
    ],
    "path? with like if there exists a path with more than T edges Okay, what are base cases? Okay, there's zero edges. Well be of i 0 is going to be 0. For all I not equal to 0, right? Oh, sorry. Infinity Bank Because there is no path from v02 VI that uses zero edges. Be of 00 is going to be what? Make the trivial path from v02 ": [
      1803.0,
      1863.5,
      44
    ],
    "recurrence makes sense and that's what I want you to do already. So that's kind of like took it out. Okay. So today the dynamic programming problems were going to look at today. I'll have to do with grass. So we're going to see kind of how grass come into dynamic programming and we can also see how you can think about all dynamic programming problems as graph problems. Okay, ": [
      429.0,
      459.2,
      7
    ],
    "run DFS on it. And then every time you pop off of her text you you put it into the Q. Oh, I didn't put a wait there. Let's just say it one. Okay, so here's a pseudocode. Dad DP you got a graph in his in his starting vertex. You said the distance of the starting bird text to zero. Latvia wants to vnb. The list of all vertices ": [
      982.1,
      1025.5,
      23
    ],
    "shortest path from a given for a text to all of its vertices right? So remember you can just use dijkstra's and it'll be fine and it'll work great, but we can shave off that log in term by basically by organizing the vertices in a certain way. What way is that? Well? the diag so topological ordering right and we're going to see why putting in topological ordering prevents ": [
      722.3,
      752.2,
      16
    ],
    "shortest path from s to VI. using at most T edges All right vs. 0. Thank you. Sseko to be zero. Okay question. That's why is that most? So if there's no path then the shortest path is infinity. I mean like what would you be able to put a budget? That's too low because there is all the Popeye's on for them. You mean like if there was a ": [
      1749.7,
      1803.0,
      43
    ],
    "shortest path problem where each one of these arrows has wait one unless Let me just change the color. Unless the letters are the same in which case the arrow has weight zero Frank then all you have to do is find the shortest path from the top vertex to the bottom right protects. So here is a filled in all of the edges. You can see those big dark ": [
      585.0,
      620.2,
      12
    ],
    "single Source node pain, so we'll talk about this and it'll kind of a nice ending to a dynamic programming. Okay. Well, let me know if you guys find any arbitrages. San Diego ": [
      2903.6,
      2924.2,
      71
    ],
    "so to start out. Notice that a dynamic programming problem is basically a dag. So, how does that work? It's a problem is a vertex. Read and write with dynamic programming problems. The sub problems are dependent on other sub problems. So the sub problem is dependent on another sub problem there The Edge from one to the other. So you see why this has to be a dad. Do ": [
      459.2,
      495.7,
      8
    ],
    "so you basically set you basically change all the weights to these W primes, which is the negative log. That means the smallest sum of w Prime's is the largest product of the W's and then we can just run Bellman Ford directly on this information. Okay, so I found I found a currency Arbitrage one time. But by the time I realized what it was it was already like ": [
      2745.4,
      2780.2,
      66
    ],
    "tax or whatever on it just it just said that they're making money right? For example, if I change $200 into Euros at an exchange house got whatever that was and then tried to change that same amount of Euros back into Dollars. I'll probably lose a little bit because they have like this fee. okay, but there's actually no Central currency exchange system. And so what that means is ": [
      2578.5,
      2611.3,
      61
    ],
    "that as Market change some exchange houses update faster than others and also depends on what time zone you're in and so one currency could plummet and another one could Skyrocket and one exchange house could could do one of the changes the other one could do the other one and you might be able to find a way to make money by doing a sequence of exchanges. so this ": [
      2611.3,
      2644.5,
      62
    ],
    "that for Loop takes degree of the many steps, right because you're taking the minimum here of the degree. Of the I enter the sum of all the degrees is the number of edges and stuff you get linear time. Does that mean solving the edit distance problem using this shortest path algorithm now, you can get it in big'o of NM time which is the same amount of time ": [
      1094.8,
      1122.6,
      26
    ],
    "that we talked about before and I guess this is algorithm doesn't really output anything it just kind of feels in this array any questions. I guess I I guess this is not really. Sorry, this instead of actually should probably be like VI, right? instead of actual BVI Okay good. So now the run time is Viggo of the Plessy right? Because every time you every every iteration in ": [
      1056.0,
      1094.8,
      25
    ],
    "that week the Chilean Peso Spike Rose a lot and the Brazilian. how plummeted a little bit and so there was like this kind of miscommunication between the the houses there were like two blocks away the two houses so I could have just got like ran back and forth as much as I wanted to. Okay, so This is basically the idea right if there's a negative cycle and ": [
      2813.8,
      2845.0,
      68
    ],
    "that will be like 2 out of 5 hope kind of yeah. Okay, it's working now. but now doesn't want to update. Oh, it's cuz it's not connected to the internet. I got to go into guest Internet. Okay. Still doesn't want to do it. Oh, here we go. I think it's working now. Okay. Okay, good. Sorry about that. My computer was being weird. question Yeah, we won't have ": [
      275.6,
      402.8,
      5
    ],
    "the algorithm is not going to Halt. Thanks. Just going to keep on going forever cuz you can keep on finding better and better paths without aunt. Okay, so that's a problem. Okay, if there are no negative Cycles, you can run dijkstra's on it and get all shortest paths. There is a problem with efficiency though. question So if you recall when we prove dijkstra's algorithm, we use the ": [
      1558.2,
      1593.0,
      37
    ],
    "the big bold black edges. Those are your 0 edges and all the red edges are one edges, right? And so now all I need to do is figure out what's the shortest path from this note to that note and that will give you the minimum. edit distance any questions Okay. So how would we do this? We could just build the graph and then the graph has NM ": [
      620.2,
      660.0,
      13
    ],
    "the cases or? Or just like the idea. No, because I could have negative edges. Right. So adding another Edge might decrease it. Well just means I have to consider it. So let's think about it like this there there is a there is a answer to the shortest path from v02 VI using at most two edges right? There is a pain that means that they're there does exist ": [
      2074.7,
      2133.7,
      48
    ],
    "there's negative Cycles? Okay good. If there's no negative Cycles, then then after + -1, you can't get any better write all those shortest pads are set you can keep on running over and over again and I'll always just be the same. So if there were negative cycle, then some of those pads will start to improve after and -1 so the idea. is 2 Okay. So this is ": [
      2412.5,
      2471.1,
      57
    ],
    "time on Friday to do a little bit of review. What's up? well As far as like design type questions, it won't be on the final but there might be some like true-false questions that might make it on there from week 10. What's up? I don't know now. I haven't made it yet. You want it want me to give you my plan? All right, so there's going to ": [
      175.9,
      231.3,
      3
    ],
    "to be be of it a few minutes to talk about in a group see if you could come up with a recursion for this ready go. Yes. They're they're not there conviction be any arbitrary order. The only thing that matters is the v-0. Hey, is anybody have like a away to kind of split this up in two cases so that we can take the minimum of all ": [
      1950.1,
      2074.7,
      47
    ],
    "to negative for rent around you get more more negative negative. So what is the shortest path from a to c was kind of like unbounded is like a negative infinity or something and that's not really useful for us. Okay. Also, if we trying to run anything like dijkstra's algorithm on it or any Graph Search algorithm that keeps on updating you're going to run into this problem where ": [
      1527.0,
      1558.2,
      36
    ],
    "to prove correctness on the dynamic programming problems kind of like in the homework. What this is the reason is because I'm hoping that the your description of your recursion is good enough that that basically is your proof of correctness in a sense. I mean If you try to write out a proof of correctness again, you're going to see that basically what you're doing is justifying why your ": [
      402.8,
      429.0,
      6
    ],
    "us from kind of going back and read and having to re update certain vertices. Okay, so let's kind of go through the process of the dynamic programming steps. So the sub problem is going to be dissed V is going to be the shortest distance from s2v K. The base case is this task is 0 What's the recursion? Well, let's just take a look at. the the graph ": [
      752.2,
      785.4,
      17
    ],
    "value? Right? Cuz we don't want it to go on for Infinity. That's kind of the worried. So let's the first assume that there are no negative cycles. That means that all the shortest pads are going to be simple paths, right because it's no it's not any used to go through a cycle a bunch of times if you're not gaining anything from it. So what's an upper bound ": [
      2327.7,
      2353.2,
      54
    ],
    "vertices. It's pretty easy to build right is going to be going to have a round three times NM edges right because basically For each vertex. There are three edges that come out of it or three edges that come into it maybe except for the the borders. So if we ran dijkstra's on it, then you will get a run time of Big O of NM login m Frank ": [
      660.0,
      688.0,
      14
    ],
    "we used from before. It's honestly, it's really the same algorithm in a sense. You just kind of framing it as a graph or you just framing it as like a filling up an array. questions about that Okay, so noticed that this algorithm. Symptoms of Jag this works for positive and negative weights. There's nowhere that we said that the weights had to be restricted. So the fact that ": [
      1122.6,
      1159.6,
      27
    ],
    "weight of Vijay te vi. Pick me questions about that. Okay, that's it. That will always be will at we will always be able to kind of reach that budget if we do it that way. Now, let's start thinking about what are the consequences of having negative Cycles or not negative Cycles? Okay, what should we set our budget to be should we set it to be a certain ": [
      2285.4,
      2327.7,
      53
    ],
    "what I was saying before if there's no negative Cycles. So the idea is to check to see if after one more iteration does anything improve if it does and you found a negative cycle and that's bad, right? Well, it kind of depends on your problem. It could be good if you found a negative cycle. What's that? free airline tickets Yeah. Okay, so this is called the Bellman ": [
      2471.1,
      2510.5,
      58
    ],
    "which is not bad, but we can actually improve this by using the fact that this graph is a dag. so what kind of things can we approve Upon A shortest path algorithm if we know it's a dag. Let's try to approach the shortest path in dag as a dynamic programming problem. Okay, so suppose we have some dag like this. With Edge weights, we want to find the ": [
      689.0,
      722.3,
      15
    ],
    "you see why there can't be any Cycles? If there were a cycle then, you know this problem would depend on that problem with depend on that problem and back around and there's no start to to wear to how to calculate them. Right? So Cycles are not really good for this type of optimization problem. So let's just go to this if you guys were call this edit distance ": [
      495.7,
      523.7,
      9
    ]
  },
  "Class Name": "cse101",
  "Date": "03062019",
  "Full Transcript": "Listen to a podcast.  What the heck?  All right. Here we go.  I'm having some technical difficulties.  I'm having some technical difficulties with the computer. So it all.  I think it'll be fine after I restart it. Okay, before we begin, does anybody have any questions?  Put up a new homework homework 7 and if you noticed I put the first problem the last problem of the other homework kind of carried over to a homework 7 save a little bit more time to think about it. I'll be giving you guys some practice problems for the for the final probably tomorrow question.  Yeah, yes. Yes, you can finish it this one if you like, but you can you can carry over to the next one more.  Yeah, so today we're Bates. We're going to try to finish up with dynamic programming today. I imagine that they will be a little bit more to do on Friday Also.  And that's mainly the material for the final exam. We're we're going to talk a little bit about linear programming mainly with like these maxflow type of things and show how you can solve certain problems with it. Then we'll talk about p and NP briefly and then hopefully we'll have some time on Friday to do a little bit of review.  What's up?  well  As far as like design type questions, it won't be on the final but there might be some like true-false questions that might make it on there from week 10.  What's up?  I don't know now.  I haven't made it yet. You want it want me to give you my plan?  All right, so there's going to be like 10 true-false questions.  Something like that. Then there's going to be one or two graph problems a greedy problem divide and conquer problem and one or two dynamic programming problems.  I mean in what sense?  Like you mean for the true false?  It's onion is cumulative. It's it's kind of like what I said, I mean  I guess if I put two dynamic programming problems on there than that will be like  2 out of  5  hope kind of yeah.  Okay, it's working now.  but now  doesn't want to update.  Oh, it's cuz it's not connected to the internet.  I got to go into guest Internet.  Okay.  Still doesn't want to do it.  Oh, here we go. I think it's working now.  Okay.  Okay, good. Sorry about that.  My computer was being weird.  question  Yeah, we won't have to prove correctness on the dynamic programming problems kind of like in the homework.  What this is the reason is because I'm hoping that the your description of your recursion is good enough that that basically is your proof of correctness in a sense. I mean  If you try to write out a proof of correctness again, you're going to see that basically what you're doing is justifying why your recurrence makes sense and that's what I want you to do already. So that's kind of like  took it out.  Okay. So today the dynamic programming problems were going to look at today. I'll have to do with grass. So we're going to see kind of how grass come into dynamic programming and we can also see how you can think about all dynamic programming problems as graph problems.  Okay, so to start out.  Notice that a dynamic programming problem is basically a dag. So, how does that work?  It's a problem is a vertex.  Read and write with dynamic programming problems. The sub problems are dependent on other sub problems. So the sub problem is dependent on another sub problem there The Edge from one to the other.  So you see why this has to be a dad. Do you see why there can't be any Cycles? If there were a cycle then, you know this problem would depend on that problem with depend on that problem and back around and there's no start to to wear to how to calculate them. Right? So Cycles are not really good for this type of optimization problem.  So let's just go to this if you guys were call this edit distance example.  We feel that we filled kind of part way through it using the recursion. But if you like instead of doing it the way we did it you can think about it as a graph problem.  Okay, and the idea here is there's going to be a Edge from one cell to another if it depends on it. So.  This this cell is dependent on that one the cells dependent on that one to sell. It depended on that one and so on right?  I guess let's do it by cell. So this cell.  Is dependent on those three right until you can you can kind of put these arrows in for every single cell now instead of making it a dynamic programming problem. We're filling in an array we can think about it more in terms of a shortest path problem where each one of these arrows has wait one unless  Let me just change the color.  Unless the letters are the same in which case the arrow has weight zero Frank then all you have to do is find the shortest path from the top vertex to the bottom right protects. So here is a  filled in all of the edges. You can see those big dark the big bold black edges. Those are your 0 edges and all the red edges are one edges, right? And so now all I need to do is figure out what's the shortest path from this note to that note and that will give you the minimum.  edit distance  any questions  Okay. So how would we do this? We could just build the graph and then the graph has NM vertices. It's pretty easy to build right is going to be going to have a round three times NM edges right because basically  For each vertex. There are three edges that come out of it or three edges that come into it maybe except for the the borders.  So if we ran dijkstra's on it, then you will get a run time of Big O of NM login m  Frank  which is not bad, but we can actually improve this by using the fact that this graph is a dag.  so  what kind of things can we approve Upon A shortest path algorithm if we know it's a dag. Let's try to approach the shortest path in dag as a dynamic programming problem.  Okay, so suppose we have some dag like this.  With Edge weights, we want to find the shortest path from a given for a text to all of its vertices right? So remember you can just use dijkstra's and it'll be fine and it'll work great, but we can shave off that log in term by basically by organizing the vertices in a certain way.  What way is that? Well?  the diag so  topological ordering right and we're going to see why putting in topological ordering prevents us from kind of going back and read and having to re update certain vertices.  Okay, so let's kind of go through the process of the dynamic programming steps. So the sub problem is going to be dissed V is going to be the shortest distance from s2v K. The base case is this task is 0  What's the recursion?  Well, let's just take a look at.  the  the graph I have from before.  Let's look at vertex J K if I want to compute the shortest distance from let's say s is equal to be. Okay, so I'm trying to compute the distance from B to Jay.  Look locally around J. What is this J dependent on?  Write the shortest of all the different distances, but I guess another way to say is what vertices do you need to pass through before you get to Jay?  G&G right.  So this Jay is going to have to be the minimum of  Well the distance to E.  + 5 and the distance to G.  + 2  If we knew the distance to G and a distance to eat, but kind of looking ahead if we do it in topological ordering we're guaranteed to have visited e&g before we got to J.  Got any questions about that?  Okay. So this is basically the recursion is that distance X is equal to you take the minimum of all the incoming edges and you add their length plus the distance.  Okay ordering. Well the trick here to order the vertices is in topological order. You can see why that helps because once you get to a Vertex, you know that there's no edges going backwards. So, you know, you don't ever have to update anything before so in that sense whenever you have updated of her text it done. It's been updated and you never have to update it again, so you can really just move along in a linear fashion.  Any questions about that?  Okay good. So here's a here's the topological ordering and then you can just put in the edges right? So be goes to  hey with 4  he with eight.  he was 5 and so on so you can just put it all the edges and  If I did this correctly then all the edges will be going in One Direction and you can keep on kind of computing these distances as you got.  linear  topological  sorting  takes  big O of the Plessy  Remember cuz all you do is you run DFS on it. And then every time you pop off of her text you you put it into the Q.  Oh, I didn't put a wait there.  Let's just say it one.  Okay, so here's a pseudocode.  Dad DP you got a graph in his in his starting vertex. You said the distance of the starting bird text to zero.  Latvia wants to vnb. The list of all vertices after s in topological ordering right. Those are the only bird of vertices that you're going to be able to reach. I guess maybe what we should do is also initialise distance of the eye to be Infinity.  for all  bi not equal to a string so you can keep on updating.  Okay, and then for every one of those vertices just set set it to be this distance value that we talked about before and I guess this is algorithm doesn't really output anything it just kind of feels in this array any questions.  I guess I I guess this is not really.  Sorry, this instead of actually should probably be like VI, right?  instead of actual BVI  Okay good. So now the run time is Viggo of the Plessy right? Because every time you every every iteration in that for Loop takes degree of the many steps, right because you're taking the minimum here of the degree.  Of the I enter the sum of all the degrees is the number of edges and stuff you get linear time. Does that mean solving the edit distance problem using this shortest path algorithm now, you can get it in big'o of NM time which is the same amount of time we used from before. It's honestly, it's really the same algorithm in a sense. You just kind of framing it as a graph or you just framing it as like a filling up an array.  questions about that  Okay, so noticed that this algorithm.  Symptoms of Jag this works for positive and negative weights. There's nowhere that we said that the weights had to be restricted.  So the fact that it's damn it prevent it from having something called and negative cycle, which is problematic. We'll talk about that in a minute.  but  Because we're able to do the shortest path in the presence of negative weights. We can find longest path just by negating all of the edge weights and then finding the shortest path, right? So it's kind of like a trick to reduce the problem produce longest path in dag to shortest path in Jag.  So let's look at a application of this.  Longest increasing subsequence. So suppose you had some list of integers a 1 through a end and increasing subsequence is a sequence that is increasing subsequence. That's increasing.  Subsequence means that the they have to be in order, but they don't necessarily have to be contiguous.  so for example  51620 that's a increasing subsequence.  What's the maximum increasing subsequence in this array?  I think it's what 8 11 12 16 25.  I think that's about right.  Okay, so  we can just  forget about the graph stuff and solve this problem using dynamic programming kind of how we were doing it before but let's see how we can reduce it to shortest path.  Okay, so what could the vertices be?  any ideas  Okay, each number good.  And what about when is there going to be an edge?  Okay, when a little number comes before a bigger number, okay, good. So  There is an edge.  from AI to AJ  if  AI is less than a j  and I is less than Jay Wright.  Okay, and now what are we going to what are going to be the edge length the the length of each Edge?  well  01 really helped so much because then all possible.  Write we care about the length of the path.  But we're trying to reduce it to shortest path.  negative  are there any questions about that?  We just solved that problem right just build this graph and run shortest path on it. How are we so sure that the path is going to be a dag. It's kind of like by the construction right where we're only  I guess I should say this and eyes less than Jay. We're only connecting from earlier position to a later position. So they're already in topological order so you can just plug it in that way. You don't even have to store it in topological order.  sup  Let's move on.  negative Cycles  Okay, so we can run into a problem when there's a negative cycle. What is the negative cycle? It's basically when  you have a cycle in a graph and the sum of all the edges is a negative number.  What is this graph have a negative cycle?  Yes, what is it?  so  a b or a c  EB Wright  negative cycle  and what about  EBD  is that a negative cycle?  not negative cycle  questions about that  Okay, good. So  The problem with having a negative cycle. Is that now? If you trying to find the shortest path, there are some pairs of vertices where the shortest path is unbounded from below for example.  What is the shortest path from a to c?  well  If you go this way, you get -2, but if you go around like that then you get what?  -4 right  Thank you. Go negative to positive 2.  -6 negative to negative for rent around you get more more negative negative. So what is the shortest path from a to c was kind of like unbounded is like a negative infinity or something and that's not really useful for us.  Okay.  Also, if we trying to run anything like dijkstra's algorithm on it or any Graph Search algorithm that keeps on updating you're going to run into this problem where the algorithm is not going to Halt. Thanks. Just going to keep on going forever cuz you can keep on finding better and better paths without aunt.  Okay, so that's a problem.  Okay, if there are no negative Cycles, you can run dijkstra's on it and get all shortest paths. There is a problem with efficiency though.  question  So if you recall when we prove dijkstra's algorithm, we use the fact that all edgeways for positive in order to get that efficiency in order to show that each vertex only enters the priority Queue at most one time. But if there are negative edges, then it could it could go in there more than one time. And in fact, you can found it. It could actually be a exponential time the vertex could go into the party Q in exponential number of times if you have like a really weird example.  Okay, so our next kind of goal is to figure out how to find shortest path efficiently.  In a graph with Negative Edge weights without negative Cycles, right? If there's negative Cycles, then we're kind of we can't we can't get the shortest path.  Okay. So basically what I want to do is change this graph or change this graph problem that has Cycles right into a dad that doesn't have Cycles.  I can't sew in order to do this. We're going to give ourselves a budget and this is also going to prevent us from going down. Any infinite Loops. We're going to say, what is the shortest path that I can have by only using at most team any edges?  Okay.  So let's let's turn this into a dynamic programming problem. Let me just kind of state the problem now.  the input is going to be a graph with vertices v-0 through the n  Okay.  And they may have Negative Edge weights will think about the negative Cycles as we go along and see kind of what role they play. But if we put a budget on the number of edges, we don't really have to worry about it because we're saying what's the long? What's the shortest path with this many edges or fewer?  Casey also get a tea, which is our budget.  Okay, so let's set up the sub problems. What do you guys think?  Kind of like the same sorts of sub problems we've seen before this is going to have two parameters i&t. So we're going to say be of it is the shortest path from s to VI.  using at most T edges  All right vs. 0. Thank you.  Sseko to be zero.  Okay question.  That's why is that most?  So if there's no path then the shortest path is infinity.  I mean like what would you be able to put a budget? That's too low because there is all the Popeye's on for them.  You mean like if there was a path?  with like  if there exists a path with more than T edges  Okay, what are base cases?  Okay, there's zero edges.  Well be of i 0 is going to be 0.  For all I not equal to 0, right?  Oh, sorry.  Infinity  Bank  Because there is no path from v02 VI that uses zero edges.  Be of 00 is going to be what?  Make the trivial path from v02 itself is a length zero.  No, because we're starting we're starting at V 0.  P0 is always the starting point.  Okay good.  Next Step  I guess this is  0  Actually, let's just keep let's keep this as your 00, I like that better because I guess if there wasn't a negative cycle, then you could start getting a better path to the that Vortex v02 itself.  Okay, so we're okay. We're actually okay with the grass this this process is going to work with a graph with negative Cycles right because  We're not letting it run free until it finds the best thing or just only letting it run with this budget.  Okay. So what simple question can we ask to split up the possible paths from v02 VI right? We're trying to figure out what this recursion is going to be be of it a few minutes to talk about in a group see if you could come up with a recursion for this ready go.  Yes.  They're they're not there conviction be any arbitrary order.  The only thing that matters is the v-0.  Hey, is anybody have like a away to kind of split this up in two cases so that we can take the minimum of all the cases or?  Or just like the idea.  No, because I could have negative edges.  Right. So adding another Edge might decrease it.  Well just means I have to consider it.  So let's think about it like this there there is a there is a answer to the shortest path from v02 VI using at most two edges right? There is a pain that means that they're there does exist a path.  So what is this path look like you have v0?  And VI.  What's this vert.x here?  What could it be?  Any of its neighbors write any of its incoming Neighbors?  So let's just take the minimum out of all those incoming neighbors. How do you get to all the incoming neighbors with T minus one edges and then add that other Edge?  okay, so basically  I already know how to get to all of the neighbors of the incoming neighbors of VI with T minus one edges. If if I'm ordering the sub problems correctly, right? So I pretty much figure out what's the minimum of all those things plus those Edge weights.  You can kind of think I think of it as cases right que sera would be that v-0 is the second-to-last vertex in the past from v02 VI using at most two edges be one is the second to last for a tax fee to is a second and last for a tax defeat all the way to VN. I mean, this is kind of maybe going a little overboard because we don't need to consider all possible vertices. We just need to consider the actual neighbors incoming Neighbors.  But let's just assume that maybe it's a complete graph and then we have to consider them all.  Okay, so basically  This is going to be our recursion be of it.  Is going to be well.  Look at all the possible incoming neighbors of VI.  vjv, I  figure out what is be of JT -1, right? That's the shortest path to get to that vertex with T minus one or fewer edges and then plus the weight of Vijay te vi.  Pick me questions about that.  Okay, that's it.  That will always be will at we will always be able to kind of reach that budget if we do it that way.  Now, let's start thinking about what are the consequences of having negative Cycles or not negative Cycles?  Okay, what should we set our budget to be should we set it to be a certain value? Right? Cuz we don't want it to go on for Infinity. That's kind of the worried.  So let's the first assume that there are no negative cycles. That means that all the shortest pads are going to be simple paths, right because it's no it's not any used to go through a cycle a bunch of times if you're not gaining anything from it. So what's an upper bound on the number of edges of a simple path in a graph with n vertices?  And might as well good.  write hamiltonian  happy happy hamiltonian path  Right. So this is the this is the upper bound. So the idea here is we're going to set our our budget to be and -1 and that will give us all the shortest simple pads if there are no Negative Edge has no negative Cycles.  That's good. So if we know beforehand that it does it doesn't have any negative cycles and this will work great and it and we're done and we don't have to do any more iteration. If we don't know if there are negative Cycles or not. Is there a way to detect this?  Can we use this kind of idea of simple pads in order to detect if there's negative Cycles?  Okay good.  If there's no negative Cycles, then then after + -1, you can't get any better write all those shortest pads are set you can keep on running over and over again and I'll always just be the same. So if there were negative cycle, then some of those pads will start to improve after and -1 so the idea.  is 2  Okay. So this is what I was saying before if there's no negative Cycles. So the idea is to check to see if after one more iteration does anything improve if it does and you found a negative cycle and that's bad, right?  Well, it kind of depends on your problem. It could be good if you found a negative cycle.  What's that?  free airline tickets  Yeah.  Okay, so this is called the Bellman Ford algorithm.  and basically what it does is it returns negative cycle if it finds one and or else it turned returns all the shortest paths and here here's pseudocode when you can go over it later if you like, but you basically  Runty from one up to n and do the the recursion.  And then after that you basically just check to see if any of the is it has improved in that and it'll rayshun and otherwise you just return it.  Okay, why is this algorithm important?  flight tickets  or  has anybody heard of currency Arbitrage?  Okay, so  We usually deal with exchange rates right as being determined. So you always lose a bit when you buy right when you go to The Exchange house they give you kind of  They put a little bit more of a tax or whatever on it just it just said that they're making money right? For example, if I change $200 into Euros at an exchange house got whatever that was and then tried to change that same amount of Euros back into Dollars. I'll probably lose a little bit because they have like this fee.  okay, but  there's actually no Central currency exchange system. And so what that means is that as Market change some exchange houses update faster than others and also depends on what time zone you're in and so one currency could plummet and another one could Skyrocket and one exchange house could could do one of the changes the other one could do the other one and you might be able to find a way to make money by doing a sequence of exchanges.  so  this is called the Arbitrage and it's a people do it. They they find them they don't last for very long. But once they find them they they go around that that sequence.  Okay, so how how could we use Bellman Ford to find a currency Arbitrage?  You basically make a graph where each vertex is a currency and the edges are going to be the exchange rate, right?  There's kind of one weird problem is that bellman-ford works? Well with sums where this is going to be products, right if I exchange one and exchange another you're going to multiply those exchange rates.  Let's just go to the next thing you're trying to find a path that maximizes the product.  right  We want to minimize this some okay, how come we met products into sums?  Take the log log is a nice function that changes products into sums.  Basically take the negative log because we still are trying to find shortest paths.  Okay, so what would be really good as if there were a psycho whose product was bigger than one right? This is the Arbitrage change here here here here here once you get back you get more than what you paid for.  I'm in the first place.  Okay, so you basically set you basically change all the weights to these W primes, which is the negative log. That means the smallest sum of w Prime's is the largest product of the W's  and then we can just run Bellman Ford directly on this information.  Okay, so  I found I found a currency Arbitrage one time.  But by the time I realized what it was it was already like changed.  but  yeah.  I didn't use Bellman Ford to find it though. It was just  I just saw that these two exchange houses kind of exchange that these different rates. I should have done something about it.  I couldn't believe it in the first place, but it turned out that I was going to Brazil at the time and I was living in Chile and it turned out that like that week the Chilean Peso Spike Rose a lot and the Brazilian.  how  plummeted a little bit and so there was like this kind of miscommunication between the the houses there were like two blocks away the two houses so I could have just got like ran back and forth as much as I wanted to.  Okay, so  This is basically the idea right if there's a negative cycle and W Prime then he found a Arbitrage and if there's no negative cycle, then you can find the best exchange rate, which means basically maybe instead maybe I'm getting the best exchange rate from dollars to Euros. It's better if you exchange it into pounds and then Yen and then pesos and then into Euros, maybe there's like some sort of thing. So that's also what does algorithm can do for you.  Okay, so  maybe let's  I do want to look at this one more algorithm, but we might have to save it until Friday, but maybe you guys can look at it in the book is called the Floyd warshall algorithm and it's basically it's very useful for this Arbitrage also, because it finds the best the shortest path between every pair of nodes instead of just from a single Source node pain, so we'll talk about this and it'll kind of a nice ending to a dynamic programming.  Okay. Well, let me know if you guys find any arbitrages.  San Diego ",
  "Section": "a00",
  "Time": "1500",
  "Video URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-03062019-1500.mp4",
  "Audio URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-03062019-1500.mp3",
  "File Name": "lecture_24.flac"
}