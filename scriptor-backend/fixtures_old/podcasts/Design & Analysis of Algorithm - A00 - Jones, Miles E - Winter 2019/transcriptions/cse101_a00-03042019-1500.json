{
  "Blurbs": {
    "2. That'll be insertion. I'm saying like yeah. You're starting from the top word and you're trying to get to the bottom word. So. I'm trying to delete that last one. Okay. Let me just do something real fast. Okay. I think I have let's just I'll do them together and that's better. I have some slides that have them on that about all the answers on them, but Let's ": [
      1013.7,
      1076.5,
      26
    ],
    "I can't take anything of value. EFC is 0 then return 0. I'm actually going to put less than or equal to 0. Because you're going to see that in my recursive call. I might kind of cross that boundary. No, so that's why I said a store cuz you can think about like a store is well-stocked A well-stocked Store where the it's like an unlimited amount of everything. ": [
      2149.4,
      2189.7,
      56
    ],
    "I could be one of three things at least in the first and call him. So there is at least three to the end different combinations and really probably many many more than that, right because there's more sort of thinking about doing nothing in substitution is sort of the same thing. Because you can't always just do nothing because a letter in the top word might not always exist ": [
      443.5,
      479.7,
      13
    ],
    "I get the value of N. I definitely get it plus. How much can I get? I'm thinking of something year. How much can I get where? all these guys 1 2 and 1/2 end and now my capacity goes down by the weight of the N Salomon. And that's why I wanted to do. I guess this should be zero, right? And what do we want to do if ": [
      2233.5,
      2279.6,
      58
    ],
    "I kind of counted as the run time and I kind of missed it up in my head. Anyhow, I also gave you a kind of a guideline on how I want the problems to be presented. I really do want you to go through those steps for your benefit and for our benefit just so that we can were able to kind of read through your reasoning is the ": [
      42.2,
      65.0,
      1
    ],
    "I mean I know I'm being kind of silly here. But you know, you have to just pick one of the items at random and say do I include this item or not, then you can rehearse but maybe it's better to let's use and so that the problem actually kind of looks uniform. None of backtracking it work fine with backtracking. Yeah, but with with dynamic programming we are ": [
      2042.6,
      2075.5,
      53
    ],
    "I still listen to three four five. Okay, so you guys can finish this off at the other any questions? at the end once you get to the four, then you can just follow the pointers backwards and that'll give you a path back to the the empty set empty set cell and and basically every time you go up that that means that there was a insertion And every ": [
      1721.3,
      1759.9,
      45
    ],
    "Listen to a podcast. Okay, let's get started. Let's begin. So does anybody have any questions before we start? There were some typos in the homework mainly on number two, so I re-uploaded it and gave a post on Piazza. So I hope you guys saw that mainly with the runtime. My original thought was I wanted to give you a found on the space and then I forgot and ": [
      1.9,
      42.2,
      0
    ],
    "Matrix so that you can just kind of run the recursion. So we get all of those now the recursion I know we already did it with the backtracking but let's do it again so we can kind of just have a a nice presentation of the dynamic programming. Okay, so case one is that item J? is included in the max value subset, let's say Whatever. However you call ": [
      2458.8,
      2496.7,
      63
    ],
    "Okay, so let's do the out one first if I don't pick up item and then I been then what's the maximum I can get? Backtracking KS of what? 1 2 N -1 write the weights of 1 2 N -1 the values 1 2 N -1 I still have the same capacity in my backpack knapsack. Sorry. Okay, what if I what if I included if I included then ": [
      2192.1,
      2233.5,
      57
    ],
    "Okay. So what's nice to do is to what I like is to think about it as a matrix. And they're numbered as matrices are numbered so. The eyes are going this way, right and the Jays are going this way. So you start like the top left corner will be zero zero and then you start counting this way coming to the right and counting down. So figure out ": [
      1327.4,
      1358.0,
      34
    ],
    "So like row by row. Okay. So one way to do this is left to right through Rose going from top to bottom right kind of. It's really easy to implement to write you. Just do a double for Loop. Because as I as I go through the array, I'm going to go to the top row the next row the next row and then I'm going to hit this ": [
      1411.2,
      1443.7,
      36
    ],
    "and how many indices we need for our right? Okay. So we can we can think about it like this. The input is going to be a list of items. The names of the items maybe a 1 through a n for each item has a value VI in a way wi maybe the input is just the weights in the values given that you cannot have more weight than ": [
      1944.2,
      1970.4,
      50
    ],
    "are we breaking into? 7-Eleven 7-Eleven, okay. Okay, what weighs 2 lb and is worth $4? A what? Donuts, okay. What's what weighs 4 pounds and is worth $9. big Donuts big pack right big pack of donuts Okay, what's worth what's 5 lb and is worth $12? a small dog small dog you can get that at 7-Eleven now. Okay. How about we weighing 7 lb in worth $15? ": [
      1828.5,
      1887.8,
      48
    ],
    "at this thing real fast. Okay. Now how do we go from backtracking to dynamic programming? Basically, what you do is you replace these recursive calls with setting setting values for the array, right and so are our Ray is going to have these two parameters the the the end parameter and the the C parameter write how many items are left and how much weight do I have in ": [
      2361.0,
      2391.0,
      60
    ],
    "back. Right? What's another kind of limiting factor? Right. You don't have any room? Okay. So you're the base cases if there is no items to choose from or if my knapsack can't fit anything in it. Okay, and those would be so let's fill in this backtracking knapsack problem. The base cases are going to be if an is 0 return 0 right? I can't if there's nothing there. ": [
      2116.5,
      2149.4,
      55
    ],
    "be kind of the question you would ask? Write the kind of yes or no or like simple question that you could ask that would split the problem up into two two or more recursive calls. Yes for now. Yes. Which one? Right, but like in order to get like a a very specific like recursive like a break. Which one do you want to? Which item? High-dividend. Okay good. ": [
      1997.2,
      2042.6,
      52
    ],
    "be ordered. really in any way Okay, so that's what we okay. Good I put Max here. Okay. So now ordering of the subproblems remember this is going to be a two-dimensional array because the dimensions are The The J and the bee write the number of items in the wait. So what does your your standard JB cell depend on right? Let's say that Jay is going in this ": [
      2603.1,
      2638.5,
      66
    ],
    "before we go is I wanted to address your question a different problem is the 0-1 knapsack problem. This is like if instead of at 7-Eleven you're breaking into somebody's house so they only have like one of each item. So I have the answer to how you do this on the next slide, but maybe as an exercise you can think about how does this change the problem? It ": [
      2908.2,
      2934.3,
      74
    ],
    "bounds, so Same check that we had before if WJ. Is let's say if it's greater than b then return. MKS of J - 1B else do this thing. You get the idea. So how long does it take? What's the runtime? I think we'll just look right 1/2 and 1/2 C Big O of n x c. With the recursive that if she said we shouldn't do it. If ": [
      2748.7,
      2810.6,
      70
    ],
    "can think about it like this. Well, I got this 0 from this guy. I got this one from adding one to the zero and so on right so we have two three four five six. right, and these are all from all these guys. Let's just do a few more rows. What's the value of this one? one right from the cell above And this one? it can't be ": [
      1603.1,
      1650.6,
      42
    ],
    "characters total. number of characters in the string number of different operations raised to the power of the number of characters. There's three different operations. Right. So definitely more than three to the end right because for those and letters or the 1st and Columns of this type of thing, right? You can do three different things. You can either do an insertion or deletion or substitution or matching. So ": [
      408.5,
      443.5,
      12
    ],
    "cost this actually cost 5 instead of 7. Wait a minute sex, right this cost 6 instead of 7. So that is a Improvement. Is this the best that we can do? I think so. Picture of the best we can do is the distance. Okay, so here I did it in a different way, but I still got six. Okay, so what about with Pelican and penguin if I ": [
      285.4,
      318.9,
      8
    ],
    "direction and B is going in this direction. Then you're taking the max of those two things. Right? One of those things is Jay - 1B is right above. The other one is Jay, B- W J. So however big. WJ. It's going to be like several cells to the left. I put in the same row. Okay. So how do we order it? What's a nice way to order ": [
      2638.5,
      2672.1,
      67
    ],
    "does the last column of that to to buy whatever? to buy k-array look like Is the last call I'm going to be an insert a delete or a substitution / do nothing. Showcase one is going to be. a deletion last column is a deletion Okay, so that what that means is that. When I line up the two words. I don't I don't really care so much of ": [
      885.5,
      934.8,
      23
    ],
    "eye deletion which will be a d and substitution will which will be a s so I'll substitute p400e 4S and so on right so I have six substitutions. So this has a cost. of 6 okay, or you can think about it more as like a distance like those two strings have our distant 6 apart and if that distance is if that number is smaller than we have ": [
      161.7,
      194.4,
      5
    ],
    "from 00 case? Why are you putting that into the bank account? That's like your question. Yeah, you're going to see that our recursive call will depend on like I - 1 + J - 1 so that kind of like gets goes out of the range of the array. So I think it's better to just do them all up front because you know that that that's what they're ": [
      820.5,
      849.9,
      21
    ],
    "get a 4 here and its grapes USA Oak Pelican Inn. Politician can one can be change it to the other with only four operations. But what are those four operations? In order to figure out what those are while you're going through the process you can keep the previous pointer to how did you get to that sell which one of the neighbors brought you there? Okay, so you ": [
      1576.4,
      1603.1,
      41
    ],
    "given two words or strings. How can we Define a notion of closeness for example, is Pelican closer to penguin or two politician? What do you guys think? Penguin cuz they're both Birds, right? No, so we have to find some sort of metric. What do I mean by closeness? I didn't Define it for you. So what I'm they might mean by it is basically how many letters do ": [
      97.7,
      132.2,
      3
    ],
    "going to be. It doesn't depend on the word at all. Any other questions? Okay good. So those are the bass cases. Okay. So now the step 3, how do we express this recursively? Okay, so I want to express e Ave i j recursively. Okay, and so I'm going to split this up into three cases. Okay, so case one I'm in the cases are going to be what ": [
      849.9,
      885.5,
      22
    ],
    "going to want to kind of do it in a particular order. Okay, do I choose item and or not? Okay, what are the base cases here? I have one item and I have room for it take it if I Okay good. What about it? There's no items. Then nothing that could be your base case to it kind of just depends on how far you want to go ": [
      2075.5,
      2116.5,
      54
    ],
    "guys were wondering there's no difference. So I always like to think about this problem as if you were liking somebody trying to steal stuff. So you're a burglar who breaks into a store and you want to leave with the maximum value of items. Your knapsack Can Only Hold 13 pounds and the items of the store have the certain values and weights. Okay. So what kind of store ": [
      1801.9,
      1828.5,
      47
    ],
    "how many operations do you need to transfer to transition from a word of length? I to the m p word? I deletions right? How about Kiev? 0j? Any questions about that? Better have them. How would you compute them? Dynamically? OIC you could probably put in like some conditional statements to to get that but if you do it, if you if you initialize them all like this then ": [
      731.6,
      781.4,
      19
    ],
    "in the bottom word. So I'm thinking about it more as like substituting Imports South exactly. It's going to be like this like this. Or like this whether or not they are the same. Okay, so we got to beat 3 to the end. You think we can do it? Yes me to okay, so let's look at my steps and in trying to build this up so though. I ": [
      479.7,
      517.6,
      14
    ],
    "in this case we of i j is equal to Y 1 + y -1 Okay, any questions about that? So when you're when you're writing these things out and when you're designing them yourselves, I like I like for you to do these kind of cases often times are going to just take the maximum or the minimum overall cases, but it's nice to split it up like that ": [
      1156.5,
      1189.7,
      29
    ],
    "insert a bunch at the end and I have to substitute a bunch. It's 7 the cheapest cost. Well, you can maybe see that like some of you can kind of line them up and get some more. insertions and matches are Okay, so we're going to look at this example in a in a little bit. Okay. So the edit distance is going to be the the actual smallest ": [
      339.0,
      371.0,
      10
    ],
    "is just going to be the men of OnePlus this guy, right? This is case one case 2 and then case 3. I used this Delta function. I don't know. It's from math. But you could just hard coded in or is there like a computer science easy way to do this? Yeah, okay. So you can you can implement it, right? You got you get the idea, right if ": [
      1249.4,
      1296.9,
      32
    ],
    "it then k s j b. Is going to be what definitely got the value of that J's item. So let's put that in. Plus Okay, then it's however, you can fill up your backpack with the remaining capacity. All J items are still available because we're in A well-stocked store, right? And the capacity now is see or sorry not see B. minus the weight of Jay Got any ": [
      2496.7,
      2542.4,
      64
    ],
    "it's less than zero? Return infinity or something. Because bendy and the item can't fit in there, right? Okay, let's just add a check. If weight of n is less than or equal to C then do this, right? else can't even spell today. else return out Okay, that's good. So give me just Make a change of that in the things. Okay now. Okay, so let me just look ": [
      2279.6,
      2361.0,
      59
    ],
    "just do them together. Okay, let's do k-stew now. Kh2. Is that the last column? looks like Why and nothing, I guess let's let's just draw the draw it out again. Write a y down here and nothing up here. Now he of i j is equal to what? 1 + years of i - 100 sorry i j - 1 babe, and then case 3 the last column looks ": [
      1076.5,
      1123.6,
      27
    ],
    "just put one on top of the other then a few of the letters lineup automatically, and my question is is for the cheapest. Is there a way to get better than 4 we're going to talk about that in a minute. And then Pelican and politician if I just put one on top of the other now, they don't have the same amount of letters. So I have to ": [
      318.9,
      339.0,
      9
    ],
    "key to a t substitution. Change a the L to an are ranked substitution. And then the III and the CC these don't cost anything, right? And then you change a the a to an H. Which is a substitution and then you change the and then you add in it and sorry. This is going to be an insertion insertion in this will be a deletion. Okay. So this ": [
      248.2,
      285.4,
      7
    ],
    "like this. XY, right And now we have to split this up into two cases, right? What are the two cases? If x equals y or not, right so we'll do case through case 3 a is X is equal to Y in that case he of i j is equal to what? if I - 1 J - 1 in case 3B will be X not equal to Y ": [
      1123.6,
      1156.5,
      28
    ],
    "like to restate the problem in terms of the inputs. That's a good way to kind of figure out where you are. Okay, so the problem is going to be fine the minimum cost. Edit distance. I should say the minimum cost. edit distance up two words x that has an letters. So like the string from 1 to end of Acts in the string of 1/2 Ammo Boy. Okay, ": [
      517.6,
      549.0,
      15
    ],
    "main idea. Okay, Shall We Begin. Okay. So today we're going to do some more dynamic programming mainly with more than one dimension. So like a two dimensional array of the we're going to look at an example. That's also in the book so you can you can kind of follow along with that or look at that if you want a different sort of angle. Okay. Here's the problem ": [
      65.0,
      97.7,
      2
    ],
    "means that there does not exist a polynomial time algorithm to update doesn't exist. There is not known of any polynomial time algorithm to solve it. This run time is not polynomial because it actually depends on the the number and we'll talk about a little bit more about this when we talk about np-complete. But if you think about a number how many how many pieces of information do ": [
      2852.0,
      2881.9,
      72
    ],
    "medium dog Okay, how about 8 lb and worth $19? Arch. Okay. Okay, what about 9 pounds and $21? a 30-pack Okay. 30 pack of dogs Okay now. So, how do I do this? Okay. So let's think about how to set up the problem and a way to do it is to kind of rephrase the problem so we can think about how many degrees of freedom we have ": [
      1889.3,
      1944.2,
      49
    ],
    "minimum of those threes is okay here. I'm going to take the minimum of 0 + 101 + 1 + 2 + 1. Which is why? And as you go through this cell the cells. at the very end, we're going to get down here and we're going to we're going to get some value. I think the I think the best you can do is like 4, so you ": [
      1535.5,
      1576.4,
      40
    ],
    "more of a sense that the words are closer together. Now, oh sorry, this is hard. This is 7 can't even count today. Okay, so is 7 the cheapest cost. Is there another way that we can do it? That uses fewer operations. Okay. So the first thing you're going to do is delete the low right? Then change the P to an S. That's a substitution, right? Change the ": [
      194.4,
      248.2,
      6
    ],
    "my backpack? I'm just going to kind of skip over these ones real fast. Okay, so am I step one to to find my sub problem? So now we're doing a dynamic programming approach. I'm going to let KS of JB. It's going to be the maximum value you can fit in a b capacity knapsack. Using only the items one through J. Okay. So what are the base cases ": [
      2391.0,
      2419.2,
      61
    ],
    "now? KS of what? j0 that means that my backpack can't fit anything into it. So I can't take any of the items so that zero and what else? 0 B that means there's no items to take it so I can't put anything in there so I give zero there. I took this one is also going to have a bunch of bass cases that kind of line The ": [
      2419.2,
      2458.8,
      62
    ],
    "one J. Good any questions. exit Life Care So he go from X to I to Jay and then why from what k2l now you now you have four parameters? right I'm sure you could figure it out. But that way but this way will will use less memory space and also probably a lot less run time, I think. Nope, we were able to do it this way. You'll ": [
      598.4,
      649.6,
      17
    ],
    "one. Plus that one meaning that last column is going to be a operation for sure. right Right because the entire bottom word is still going to be in there all J letters of the bottom. Where is going to be in there? And then the first i - 1 letters are going to be in the top row because the last letter has been given there. That'll be case ": [
      973.6,
      1013.7,
      25
    ],
    "questions about that? KK stew Item Jay is not included. Well, that means KS of JB is well. I didn't include it. So that means that I have only the first J -1 items to look through. And I have the rest of my I have the full capacity be of my backpack. accident take the take minimum of cases. Omak sorry. Actually, it doesn't matter the order. They can ": [
      2542.4,
      2603.1,
      65
    ],
    "really changes it in one place in the recursion. So maybe think about where that would change it and we can kind of start from here on Friday Wednesday, okay. San Diego forecast ": [
      2934.3,
      2952.4,
      75
    ],
    "row. I'm going to calculate this guy and this guy. And then I'm going to come here and calculate this guy before I get to myself so I calculated all those three cell before I get there. Okay good. So here's the here's the pseudocode. And I guess I didn't say this explicitly but the return value is going to be e of NM right? Because that's going to be ": [
      1443.7,
      1471.8,
      37
    ],
    "see in the we start doing the recursive call. Okay, what are the base cases? What's up? Is matching what? Okay, so you're saying e00? That's definitely zero operations. Good. Are there any other bass cases that we can consider? how about ye of i, 0 will the distance is the number the minimum number of trance trance? What is it? Operations to transition from one to the other. So ": [
      649.6,
      731.6,
      18
    ],
    "see the capacity of the backpack. Okay. So for this particular problem, I want a kind of approach it using backtracking and then we'll kind of approach it using dynamic programming. The reason I want to do that is because just to give you guys more ideas of how to start these problems if it's easier for you to do backtracking first then how would you do that? What would ": [
      1970.4,
      1997.2,
      51
    ],
    "so now to find the subproblems noticed that your input has two parameters now. Okay, but that should give you a clue that you might want to use an array that has two Dimensions two-dimensional array. Okay, so what I would do is say something like Kia of IGA is going to equal to what anybody have any ideas. Of the words x from 1 to i and y from ": [
      549.0,
      598.4,
      16
    ],
    "that you can possibly do. So that's what we're trying to get to. Okay, so brute force is to just try all possible. Combinations of putting the words on top of each other. What's a lower bound on the number of possible combinations if the size of the words are and an M or n is less than or equal to m. Special Operations group give me the number of ": [
      371.0,
      408.5,
      11
    ],
    "the edit distance of the whole word ax in the whole word. Why? Okay. So let's take a look at how this how this runs are not going to go through the whole example, but maybe you guys can fill it out if you want to a little bit later. Okay. So let's use Pelican and politician again. I'm going to give a call in to the empty word and ": [
      1471.8,
      1495.5,
      38
    ],
    "the empty word on both sides. And how do I fill these these first columns and he's our base case has 0 1 2 3 4 5 6 7 and 0 1 2 3 4 5 6 7 8 9 10 so the first sell this one. I'm going to take the minimum of 1 1 and 0 0 + 1 because those letters are actually the same. so the ": [
      1495.5,
      1535.5,
      39
    ],
    "the same answer. So let's just pick one say went from this one. 3 4 5 6 Okay, how about this guy? There's going to be a to write from the top. and then here I get a Two, I guess let's go from the top. What about here? You got a one right? Because the Allen the LR the same so you get the diagonal + 0. And then ": [
      1680.7,
      1721.3,
      44
    ],
    "the things that we We've just done. I guess let's go. Let's start from here. So if the last call him looks like this then we get you by -1 J. The last call him looks like this then we get IJ - 1 + 1 in at the last call and looks like this then we get two cases. We looked at this already. okay, so the actual Recursion ": [
      1216.6,
      1249.4,
      31
    ],
    "there are equal then you get 0 if they're the same you get one. Okay, any questions about that? Okay. So now the next part two step four is to figure out the ordering of the subproblems now before it was just a one-dimensional array. You can just kind of go through the array now. We have a two dimensional array how we going to go through the sub problems? ": [
      1296.9,
      1325.8,
      33
    ],
    "this? Just do row by row again or call him by Colin will still work. Right so you can just kind of say like for Jay from 1 to n a double Loop for J from 1 to n 414 B from want to see and this is like enough. For the for that part in your homework if you have a two dimensional array. Good questions about that. Okay, ": [
      2672.1,
      2705.0,
      68
    ],
    "time you go to the left, that means there was a deletion and every time you go diagonal that means that there was either like a substitution or do nothing. any questions Okay, good. How long is this algorithm going to take run time? A lot better than 3 to the end. Okay, let's move on to another example. the knapsack problem Caso a knapsack is a backpack if you ": [
      1759.9,
      1801.9,
      46
    ],
    "way in order to to communicate why you built your recursion that way. Okay. So we have these three cases. We don't know which one actually gives us the minimum. So we calculate all three and take the minimum of all three Okay, so we've done the sub problems down the bass case we've expressed it recursively I'll finish that up here I just have this these are just all ": [
      1189.7,
      1216.6,
      30
    ],
    "what's going on to the left? All I care about is the last column if it's a deletion then that means I have a letter here and nothing here. So, what do I recover saint? The last column I guess the last column in the minimum cost. arrangement Is it a lesion then? That means that he of IJ is going to be equal to what? One definitely one right ": [
      934.8,
      973.6,
      24
    ],
    "what's the final output look like? Well, it's just KS of NC because this is going to be items one through and capacity C Okay, so let's look at what the pseudocode looks like. He basically just do your base cases, right? Then you have your double Loop. I guess I should put a check in here though. because you might run into a problem with this going out of ": [
      2705.0,
      2748.7,
      69
    ],
    "you don't have to put in any extra checking. Yeah, that's kind of the idea. the number of like how long will it last night? So this would be like for I equals one up to n in this is for all Jay from one of the m. Are we going to get those based candies for free based on the rules were going to add for calculating stuff just ": [
      781.4,
      820.5,
      20
    ],
    "you have to change to get from one to the other or add or delete? Okay. So these are going to be our three operations exchange add or delete. Okay. So let's do like another pair of words Pelican an ostrich. I can put one right on top of the other and I guess I guess these are my my three operations will be insertion which will be just an ": [
      132.2,
      161.7,
      4
    ],
    "you need to represent a number the number of bits? Right and so really and is really to to the number of bits so that's where you get that from. okay, so let's just I was just want to kind of have you guys can look at this as a exercise and fill it out if you if you like if you think that is helpful. But one more thing ": [
      2881.9,
      2908.2,
      73
    ],
    "you were to do that, then it would just make the call. You were fine. Even if we had non-integer way because it would only reach the fell that it actually needs to butt. right Is there some way to get around that? You can multiply all your floating points by a million or whatever. However many decimals. No, actually the this knapsack problem is an NP complete problem, which ": [
      2810.6,
      2852.0,
      71
    ],
    "your kind of General cell IGA. What does this cell depend on depends on its its neighbors to the upper left right all three of them? Okay. So whatever order I do this I have to ensure that all three of these values have been computed before I compute this value here. Okay to give me like a way to do an ordering to do this. How does that work? ": [
      1358.0,
      1395.4,
      35
    ],
    "zero because those Those letters o and E are not the same. So it's got to be one and it came from this cell. Frank What else what's this one? To Now you kind of have a choice. Did you come from diagonal or did you come from? The side and those choices kind of give both give you different ways of doing it different ways of both getting at ": [
      1650.6,
      1680.7,
      43
    ]
  },
  "Class Name": "cse101",
  "Date": "03042019",
  "Full Transcript": "Listen to a podcast.  Okay, let's get started. Let's begin.  So does anybody have any questions before we start?  There were some typos in the homework mainly on number two, so I re-uploaded it and gave a post on Piazza. So I hope you guys saw that mainly with the runtime.  My original thought was I wanted to give you a found on the space and then I forgot and I kind of counted as the run time and I kind of missed it up in my head. Anyhow, I also gave you a kind of a guideline on how I want the problems to be presented. I really do want you to go through those steps for your benefit and for our benefit just so that we can were able to kind of read through your reasoning is the main idea.  Okay, Shall We Begin.  Okay. So today we're going to do some more dynamic programming mainly with more than one dimension. So like a two dimensional array of the we're going to look at an example. That's also in the book so you can you can kind of follow along with that or look at that if you want a different sort of angle.  Okay. Here's the problem given two words or strings. How can we Define a notion of closeness for example, is Pelican closer to penguin or two politician?  What do you guys think?  Penguin cuz they're both Birds, right?  No, so we have to find some sort of metric. What do I mean by closeness? I didn't Define it for you. So what I'm they might mean by it is basically how many letters do you have to change to get from one to the other or add or delete? Okay. So these are going to be our three operations exchange add or delete.  Okay. So let's do like another pair of words Pelican an ostrich. I can put one right on top of the other and  I guess I guess these are my my three operations will be insertion which will be just an eye deletion which will be a d and substitution will which will be a s so I'll substitute p400e 4S and so on right so I have six substitutions.  So this has a cost.  of 6  okay, or you can think about it more as like a distance like those two strings have our distant 6 apart and if that distance is if that number is smaller than we have more of a sense that the words are closer together.  Now, oh sorry, this is hard. This is 7 can't even count today. Okay, so is 7 the cheapest cost. Is there another way that we can do it?  That uses fewer operations.  Okay. So the first thing you're going to do is delete the low right?  Then change the P to an S. That's a substitution, right?  Change the key to a t substitution.  Change a the L to an are ranked substitution. And then the III and the CC these don't cost anything, right?  And then you change a the a to an H.  Which is a substitution and then you change the and then you add in it and sorry.  This is going to be an insertion insertion in this will be a deletion.  Okay. So this cost this actually cost 5 instead of 7.  Wait a minute sex, right this cost 6 instead of 7. So that is a Improvement. Is this the best that we can do?  I think so.  Picture of the best we can do is the distance.  Okay, so here I did it in a different way, but I still got six.  Okay, so what about with Pelican and penguin if I just put one on top of the other then a few of the letters lineup automatically, and my question is is for the cheapest. Is there a way to get better than 4 we're going to talk about that in a minute.  And then Pelican and politician if I just put one on top of the other now, they don't have the same amount of letters. So I have to insert a bunch at the end and I have to substitute a bunch. It's 7 the cheapest cost. Well, you can maybe see that like some of you can kind of line them up and  get some more.  insertions and matches are  Okay, so we're going to look at this example in a in a little bit.  Okay. So the edit distance is going to be the the actual smallest that you can possibly do. So that's what we're trying to get to. Okay, so brute force is to just try all possible.  Combinations of putting the words on top of each other. What's a lower bound on the number of possible combinations if the size of the words are and an M or n is less than or equal to m.  Special Operations group  give me the number of characters total.  number of characters in the string  number of different operations raised to the power of the number of characters. There's three different operations.  Right. So definitely more than three to the end right because for those and letters or the 1st and Columns of this type of thing, right? You can do three different things. You can either do an insertion or deletion or substitution or matching.  So I could be one of three things at least in the first and call him. So there is at least three to the end different combinations and really probably many many more than that, right because there's more  sort of thinking about doing nothing in substitution is sort of the same thing.  Because you can't always just do nothing because a letter in the top word might not always exist in the bottom word.  So I'm thinking about it more as like  substituting Imports South exactly. It's going to be like this like this.  Or like this whether or not they are the same.  Okay, so we got to beat 3 to the end. You think we can do it?  Yes me to okay, so let's look at my steps and in trying to build this up so though.  I like to restate the problem in terms of the inputs. That's a good way to kind of figure out where you are. Okay, so the problem is going to be fine the minimum cost.  Edit distance. I should say the minimum cost.  edit distance  up two words x that has an letters. So like the string from 1 to end of Acts in the string of 1/2 Ammo Boy.  Okay, so now to find the subproblems noticed that your input has two parameters now.  Okay, but that should give you a clue that you might want to use an array that has two Dimensions two-dimensional array. Okay, so what I would do  is say something like  Kia of IGA  is going to equal to what anybody have any ideas.  Of the words x from 1 to i and y from one J. Good any questions.  exit Life Care  So he go from X to I to Jay and then why from what k2l now you now you have four parameters?  right  I'm sure you could figure it out. But that way but this way will will use less memory space and also probably a lot less run time, I think.  Nope, we were able to do it this way.  You'll see in the  we start doing the recursive call.  Okay, what are the base cases?  What's up?  Is matching what?  Okay, so you're saying e00?  That's definitely zero operations. Good. Are there any other bass cases that we can consider?  how about ye of  i, 0  will the distance is the number the minimum number of trance trance? What is it?  Operations to transition from one to the other. So how many operations do you need to transfer to transition from a word of length? I to the m p word?  I deletions right?  How about Kiev? 0j?  Any questions about that?  Better have them. How would you compute them? Dynamically?  OIC  you could probably put in like some conditional statements to to get that but if you do it, if you if you initialize them all like this then you don't have to put in any extra checking.  Yeah, that's kind of the idea.  the number of  like how long will it last night? So this would be like for I equals one up to n in this is for all Jay from one of the m.  Are we going to get those based candies for free based on the rules were going to add for calculating stuff just from 00 case?  Why are you putting that into the bank account? That's like your question. Yeah, you're going to see that our recursive call will depend on like I - 1 + J - 1 so that kind of like gets goes out of the range of the array.  So  I think it's better to just do them all up front because you know that that that's what they're going to be. It doesn't depend on the word at all.  Any other questions?  Okay good. So those are the bass cases. Okay. So now the step 3, how do we express this recursively?  Okay, so I want to express e Ave i j recursively. Okay, and so I'm going to split this up into three cases. Okay, so case one  I'm in the cases are going to be what does the last column of that to to buy whatever?  to buy k-array look like  Is the last call I'm going to be an insert a delete or a substitution / do nothing.  Showcase one is going to be.  a deletion  last column  is a deletion  Okay, so that what that means is that.  When I line up the two words.  I don't I don't really care so much of what's going on to the left? All I care about is the last column if it's a deletion then that means I have a letter here and nothing here.  So, what do I recover saint?  The last column I guess the last column in the minimum cost.  arrangement  Is it a lesion then? That means that he of IJ is going to be equal to what?  One definitely one right one. Plus that one meaning that last column is going to be a operation for sure.  right  Right because the entire bottom word is still going to be in there all J letters of the bottom. Where is going to be in there? And then the first i - 1 letters are going to be in the top row because the last letter has been given there.  That'll be case 2.  That'll be insertion. I'm saying like yeah.  You're starting from the top word and you're trying to get to the bottom word. So.  I'm trying to delete that last one.  Okay.  Let me just do something real fast.  Okay.  I think I have let's just I'll do them together and that's better. I have some slides that have them on that about all the answers on them, but  Let's just do them together. Okay, let's do k-stew now.  Kh2. Is that the last column?  looks like  Why and nothing, I guess let's let's just draw the draw it out again.  Write a y down here and nothing up here. Now he of i j is equal to what?  1 + years of i - 100 sorry i j - 1  babe, and then case 3  the last column looks like this.  XY, right  And now we have to split this up into two cases, right? What are the two cases?  If x equals y or not, right so we'll do case through case 3 a is X is equal to Y in that case he of i j is equal to what?  if I - 1 J - 1  in case 3B will be X not equal to Y in this case we of i j is equal to Y 1 + y -1  Okay, any questions about that?  So when you're when you're writing these things out and when you're designing them yourselves, I like I like for you to do these kind of cases often times are going to just take the maximum or the minimum overall cases, but it's nice to split it up like that way in order to to communicate why you built your recursion that way. Okay. So we have these three cases. We don't know which one actually gives us the minimum. So we calculate all three and take the minimum of all three  Okay, so we've done the sub problems down the bass case we've expressed it recursively I'll finish that up here I just have this these are just all the things that we  We've just done.  I guess let's go. Let's start from here. So if the last call him looks like this then we get you by -1 J. The last call him looks like this then we get IJ - 1 + 1 in at the last call and looks like this then we get two cases. We looked at this already.  okay, so the actual  Recursion is just going to be the men of OnePlus this guy, right? This is case one case 2 and then case 3.  I used this Delta function.  I don't know. It's from math.  But you could just hard coded in or is there like a computer science easy way to do this?  Yeah, okay.  So you can you can implement it, right?  You got you get the idea, right if there are equal then you get 0 if they're the same you get one.  Okay, any questions about that?  Okay. So now the next part two step four is to figure out the ordering of the subproblems now before it was just a one-dimensional array. You can just kind of go through the array now. We have a two dimensional array how we going to go through the sub problems?  Okay. So what's nice to do is to what I like is to think about it as a matrix.  And they're numbered as matrices are numbered so.  The eyes are going this way, right and the Jays are going this way.  So you start like the top left corner will be zero zero and then you start counting this way coming to the right and counting down. So figure out your kind of General cell IGA. What does this cell depend on depends on its its neighbors to the upper left right all three of them?  Okay. So whatever order I do this I have to ensure that all three of these values have been computed before I compute this value here. Okay to give me like a way to do an ordering to do this.  How does that work?  So like row by row.  Okay. So one way to do this is left to right through Rose going from top to bottom right kind of.  It's really easy to implement to write you. Just do a double for Loop.  Because as I as I go through the array, I'm going to go to the top row the next row the next row and then I'm going to hit this row. I'm going to calculate this guy and this guy.  And then I'm going to come here and calculate this guy before I get to myself so I calculated all those three cell before I get there. Okay good.  So here's the here's the pseudocode.  And I guess I didn't say this explicitly but the return value is going to be e of NM right? Because that's going to be the edit distance of the whole word ax in the whole word. Why?  Okay. So let's take a look at how this how this runs are not going to go through the whole example, but maybe you guys can fill it out if you want to a little bit later.  Okay. So let's use Pelican and politician again. I'm going to give a call in to the empty word and the empty word on both sides. And how do I fill these these first columns and he's our base case has 0 1 2 3 4 5 6 7 and 0 1 2 3 4 5 6 7 8 9 10  so  the first  sell this one.  I'm going to take the minimum of 1 1 and 0 0 + 1 because those letters are actually the same.  so the minimum of those threes is  okay here.  I'm going to take the minimum of 0 + 101 + 1 + 2 + 1.  Which is why?  And as you go through this cell the cells.  at the very end, we're going to get down here and we're going to  we're going to get some value. I think the I think the best you can do is like 4, so you get a 4 here and its grapes USA Oak Pelican Inn.  Politician can one can be change it to the other with only four operations. But what are those four operations?  In order to figure out what those are while you're going through the process you can keep the previous pointer to how did you get to that sell which one of the neighbors brought you there? Okay, so you can think about it like this. Well, I got this 0 from this guy. I got this one from adding one to the zero and so on right so we have two three four five six.  right, and these are all  from all these guys. Let's just do a few more rows.  What's the value of this one?  one right from the cell above  And this one?  it can't be zero because those  Those letters o and E are not the same. So it's got to be one and it came from this cell.  Frank  What else what's this one?  To Now you kind of have a choice. Did you come from diagonal or did you come from?  The side and those choices kind of give both give you different ways of doing it different ways of both getting at the same answer. So let's just pick one say went from this one.  3 4 5 6  Okay, how about this guy?  There's going to be a to write from the top.  and then here I get a  Two, I guess let's go from the top.  What about here?  You got a one right? Because the Allen the LR the same so you get the diagonal + 0.  And then I still listen to three four five.  Okay, so you guys can finish this off at the other any questions?  at the end once you get to the four, then you can just follow the pointers backwards and that'll give you a path back to the the empty set empty set cell and and basically every time you go up that that means that there was a  insertion  And every time you go to the left, that means there was a deletion and every time you go diagonal that means that there was either like a substitution or do nothing.  any questions  Okay, good. How long is this algorithm going to take run time?  A lot better than 3 to the end.  Okay, let's move on to another example.  the knapsack problem  Caso a knapsack is a backpack if you guys were wondering there's no difference.  So I always like to think about this problem as if you were liking somebody trying to steal stuff. So you're a burglar who breaks into a store and you want to leave with the maximum value of items. Your knapsack Can Only Hold 13 pounds and the items of the store have the certain values and weights. Okay. So what kind of store are we breaking into?  7-Eleven 7-Eleven, okay.  Okay, what weighs 2 lb and is worth $4?  A what?  Donuts, okay. What's what weighs 4 pounds and is worth $9.  big Donuts big pack right big pack of donuts  Okay, what's worth what's 5 lb and is worth $12?  a small dog  small dog you can get that at 7-Eleven now.  Okay.  How about we weighing 7 lb in worth $15?  medium dog  Okay, how about 8 lb and worth $19?  Arch. Okay.  Okay, what about 9 pounds and $21?  a 30-pack  Okay.  30 pack of dogs  Okay now.  So, how do I do this? Okay.  So let's think about how to set up the problem and a way to do it is to kind of rephrase the problem so we can think about how many degrees of freedom we have and how many indices we need for our right? Okay.  So we can we can think about it like this. The input is going to be a list of items.  The names of the items maybe a 1 through a n for each item has a value VI in a way wi maybe the input is just the weights in the values given that you cannot have more weight than see the capacity of the backpack. Okay.  So for this particular problem, I want a kind of approach it using backtracking and then we'll kind of approach it using dynamic programming. The reason I want to do that is because just to give you guys more ideas of how to start these problems if it's easier for you to do backtracking first then how would you do that? What would be kind of the question you would ask?  Write the kind of yes or no or like simple question that you could ask that would split the problem up into two two or more recursive calls.  Yes for now. Yes.  Which one?  Right, but like in order to get like a a very specific like recursive like a break. Which one do you want to?  Which item?  High-dividend. Okay good. I mean I know I'm being kind of  silly here. But you know, you have to just pick one of the items at random and say do I include this item or not, then you can rehearse but maybe it's better to let's use and so that the problem actually kind of looks uniform.  None of backtracking it work fine with backtracking.  Yeah, but with with dynamic programming we are going to want to kind of do it in a particular order.  Okay, do I choose item and or not?  Okay, what are the base cases here?  I have one item and I have room for it take it if I  Okay good.  What about it? There's no items.  Then nothing that could be your base case to it kind of just depends on how far you want to go back. Right? What's another kind of limiting factor?  Right. You don't have any room? Okay. So you're the base cases if there is no items to choose from or if my knapsack can't fit anything in it. Okay, and those would be so let's fill in this backtracking knapsack problem.  The base cases are going to be if an is 0 return 0 right? I can't if there's nothing there. I can't take anything of value.  EFC is 0 then return 0. I'm actually going to put less than or equal to 0.  Because you're going to see that in my recursive call. I might kind of cross that boundary.  No, so that's why I said a store cuz you can think about like a store is well-stocked A well-stocked Store where the it's like an unlimited amount of everything.  Okay, so let's do the out one first if I don't pick up item and then I been then what's the maximum I can get?  Backtracking KS of what?  1 2 N -1 write the weights of 1 2 N -1 the values 1 2 N -1  I still have the same capacity in my backpack knapsack. Sorry.  Okay, what if I what if I included if I included then I get the value of N. I definitely get it plus.  How much can I get?  I'm thinking of something year. How much can I get where?  all these guys  1 2 and 1/2 end and now my capacity goes down by the weight of the N Salomon.  And that's why I wanted to do.  I guess this should be zero, right?  And what do we want to do if it's less than zero?  Return infinity or something.  Because bendy and the item can't fit in there, right?  Okay, let's just add a check.  If weight of n is less than or equal to C then do this, right?  else  can't even spell today.  else return out  Okay, that's good.  So give me just  Make a change of that in the things.  Okay now.  Okay, so let me just look at this thing real fast. Okay. Now how do we go from backtracking to dynamic programming? Basically, what you do is you replace these recursive calls with setting setting values for the array, right and so are our Ray is going to have these two parameters the the the end parameter and the the C parameter write how many items are left and how much weight do I have in my backpack?  I'm just going to kind of skip over these ones real fast.  Okay, so am I step one to to find my sub problem? So now we're doing a dynamic programming approach. I'm going to let KS of JB.  It's going to be the maximum value you can fit in a b capacity knapsack.  Using only the items one through J.  Okay. So what are the base cases now?  KS of what?  j0  that means that my backpack can't fit anything into it. So I can't take any of the items so that zero and what else?  0 B that means there's no items to take it so I can't put anything in there so I give zero there.  I took this one is also going to have a bunch of bass cases that kind of line The Matrix so that you can just kind of run the recursion.  So we get all of those now the recursion I know we already did it with the backtracking but let's do it again so we can kind of just have a a nice presentation of the dynamic programming. Okay, so case one  is that item J?  is included  in the max value  subset, let's say  Whatever. However you call it then k s j b.  Is going to be what definitely got the value of that J's item. So let's put that in.  Plus  Okay, then it's however, you can fill up your backpack with the remaining capacity.  All J items are still available because we're in A well-stocked store, right?  And the capacity now is see or sorry not see B.  minus the weight of Jay  Got any questions about that?  KK stew  Item Jay is not included.  Well, that means KS of JB is well. I didn't include it. So that means that I have only the first J -1 items to look through.  And I have the rest of my I have the full capacity be of my backpack.  accident take the  take minimum of cases.  Omak sorry.  Actually, it doesn't matter the order.  They can be ordered.  really in any way  Okay, so that's what we okay. Good I put Max here. Okay. So now ordering of the subproblems remember this is going to be a two-dimensional array because the dimensions are The The J and the bee write the number of items in the wait. So what does your your standard JB cell depend on right? Let's say that Jay is going in this direction and B is going in this direction.  Then you're taking the max of those two things. Right? One of those things is Jay - 1B is right above.  The other one is Jay, B- W J. So however big. WJ. It's going to be like several cells to the left.  I put in the same row.  Okay. So how do we order it? What's a nice way to order this?  Just do row by row again or call him by Colin will still work. Right so you can just kind of say like for Jay from 1 to n a double Loop for J from 1 to n 414 B from want to see and this is like enough.  For the for that part in your homework if you have a two dimensional array.  Good questions about that.  Okay, what's the final output look like? Well, it's just KS of NC because this is going to be  items one through and capacity C  Okay, so let's look at what the pseudocode looks like.  He basically just do your base cases, right?  Then you have your double Loop.  I guess I should put a check in here though.  because you might run into a problem with this going out of bounds, so  Same check that we had before if WJ.  Is let's say if it's greater than b then return.  MKS of J - 1B  else do this thing.  You get the idea.  So how long does it take?  What's the runtime?  I think we'll just look right 1/2 and 1/2 C Big O of n x c.  With the recursive that if she said we shouldn't do it. If you were to do that, then it would just make the call. You were fine. Even if we had non-integer way because it would only reach the fell that it actually needs to butt.  right  Is there some way to get around that?  You can multiply all your floating points by a million or whatever. However many decimals.  No, actually the this knapsack problem is an NP complete problem, which means that there does not exist a polynomial time algorithm to update doesn't exist. There is not known of any polynomial time algorithm to solve it. This run time is not polynomial because it actually depends on the the number and we'll talk about a little bit more about this when we talk about np-complete. But if you think about a number how many how many pieces of information do you need to represent a number the number of bits? Right and so really and is really to to the number of bits so that's where you get that from.  okay, so let's just I was just want to kind of  have you guys can look at this as a exercise and fill it out if you if you like if you think that is helpful.  But one more thing before we go is I wanted to address your question a different problem is the 0-1 knapsack problem. This is like if instead of at 7-Eleven you're breaking into somebody's house so they only have like one of each item.  So I have the answer to how you do this on the next slide, but maybe as an exercise you can think about how does this change the problem? It really changes it in one place in the recursion. So maybe think about where that would change it and we can kind of start from here on Friday Wednesday, okay.  San Diego forecast ",
  "Section": "a00",
  "Time": "1500",
  "Video URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-03042019-1500.mp4",
  "Audio URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-03042019-1500.mp3",
  "File Name": "lecture_23.flac"
}