{
  "Blurbs": {
    "2 1 2 2 3 Infinity I didn't give myself enough space. there's h 3/4 and then H gets taken off and you're done. Okay. so all those red all those red lines that I drew. Those are the bets the output tree of BFS valpa tree is also the shortest path tree and I think I don't know if it was in the book or I saw it somewhere ": [
      937.8,
      978.4,
      24
    ],
    "And now I'm going to modify it so that I can do shortest distances. I still really want. To be able to reach all the vertices that are reachable, right? So I'm going to keep the main structure of graph search. The thing I'm going to change is just in what order do I pick the vertices from f So we seen this before if you if you choose app ": [
      385.3,
      416.7,
      9
    ],
    "DS. Because we know that they're both of 0. Right, and we're claiming that dissed V is greater than TV. So at some point along this path, you have to kind of break that that sequence right? So let's say that Z is the is the last vertex to have that equality and W is the first for a text to have the inequality. Okay, just like before questions about ": [
      1379.5,
      1413.9,
      35
    ],
    "I do finding sinks and sources? Yeah, basically what we said. Okay. What is DFS not good for good finding shortest paths finding shortest distances between vertices. So that's kind of the topic of chapter 4 is we're going to go into that. All right. So distance in in graph Theory distance between two vertices distance actually just mean shortest distance and you don't have to have two vertices you ": [
      308.7,
      356.0,
      7
    ],
    "I just wanted you to see what it is every step. Okay, so this will be my cue. case it starts off with a I guess we'll start with a right. everything starts as Infinity now, so the first thing you do is you deeqa right and then you look at all of its neighbors and for each one you check to see if their distance is infinity which they ": [
      759.8,
      798.3,
      20
    ],
    "Just a graph. What if we add edge weight or Edge lengths peso we have this Map of the United States with I think their flights for JetBlue. Okay, and so each one of these edges is is like a a flight path, right? Now what kind of different Edge weights could you think of labeling these edges with? Okay, so you can do the distance, right? And that sense ": [
      1722.7,
      1767.2,
      45
    ],
    "Listen to a podcast. Let's make this let's turn out down the light so we can have a more intimate setting. Okay, so I have some good news, and I have some. What's good news? If you look at it one way and its other kind of news if you look at it another way. So the good news is that we're going at a good pace and we're kind ": [
      1.9,
      48.1,
      0
    ],
    "Okay. So the next one is D width D I get a few set f2b to And you get CEF? And then the next one is see nothing happens. The next one is d No, sorry, nothing happens. the next one is f so F you go to G and you said g to be three? That's down here and sorry. G I'm losing it here. hear Wright 0 1 ": [
      876.2,
      937.8,
      23
    ],
    "So remember it keeps on like updating. It keeps on going until you go through all the vertices even if they're not connected. Where is BFS only gives you info information related to a given vertex. So it's very vertex specific like cuz you're getting all the shortest paths from ass. I don't know the shortest path between any other pair of vertices. I only know what they are in ": [
      1663.6,
      1688.4,
      43
    ],
    "a like a another value? And then just know they're not really. That's my location. Update my all of these numbers don't have a common divisor. Special moments like have without you. Oh, but then you just doing. Then you're just going to do dijkstra's anyway, right? Okay, so I want to kind of give you a sense of this high-level to low-level thing and it's in this is good ": [
      2533.6,
      2583.7,
      62
    ],
    "about figuring out how it's going to do it when you get down to like the mid-level or to the low low. Okay, so then we fill in those details. We make a low-level or implementation level algorithms from a high level one using data structures in place of those mathematical structures. Why is this useful for one Clarity and I asked that everybody whenever you hand in any algorithm ": [
      2632.6,
      2662.6,
      65
    ],
    "actual length of the shortest path among all pass from esta video V is the actual length remember that diss to be Is the is the value that the algorithm gives it we haven't shown that those are going to be equal yet, right? That's that's kind of what we're trying to prove now. Okay, so we have this path from s2v. We know that dissed s is equal to ": [
      1353.5,
      1379.5,
      34
    ],
    "add in all the ones then you found the path in your algorithm terminates, but there's actually a better path. Maybe yeah. Well, this one is not the most efficient either. And we're going to look at that in a minute. toe reduction means you take the algorithm like BFS and you use it as a subroutine and instead of instead of modifying the algorithm for a to solve the ": [
      2369.4,
      2417.1,
      58
    ],
    "adjacent to ask and then it keeps on going like that and it will just basically as you build that output tree, it sets distance V to be the distance of the parent plus one. Okay, so that is a empty slide forgot why I put that there. Okay, nevermind and the book uses some kind of weird terminology or maybe it's familiar. So for Q they have these words. ": [
      579.1,
      622.9,
      15
    ],
    "an idea of how this works with dijkstra's algorithm. Okay. What is dijkstra's algorithm do? The input is a graph with Edge lengths and a starting Vortex. The output is going to be for all the vertices that are reachable. It will give you dissed you. Will be set to the distance from s to you using those Edge weight basically the shortest path. I guess I should highlight that ": [
      2747.9,
      2775.6,
      69
    ],
    "and discuss. How would you use BFS as a reduction to solve this problem? Okay, ready go. How's the weather? I need to find what OU. Now we're going to the next thing we're going to talk about is dijkstra's algorithm, which is a good way to do this. But that is not a reduction is it that's a modification so I kind of want to first thing about it ": [
      2185.1,
      2268.9,
      56
    ],
    "are and then you set their distances to be one plus the distance of a Hey, so we're going to put in B & D. We're going to set B&D to be one and these all stay Infinity. So then the next thing you do is you pop off bee or not pop, but eject. And you look at its neighbors Saudi or has a has a distance of 1 ": [
      798.3,
      833.2,
      21
    ],
    "at all of its neighbors. When you're signing to all of its neighbors one plus the distance to that vertex and the path is just the path to that protects pay stub pic. you from f If V is a neighbor of you. then set the distance be to be equal to 1 plus distance you and that corresponds to the path from s to you to the right because ": [
      1191.8,
      1246.6,
      30
    ],
    "be zero because lives the shortest path from s to itself is zero. You start the Q. Would just ask in it and then you keep on repeating until the queue is empty, right? What is this Q really? What what place does it what set does it take its place in our original kind of high mid-level Graph Search right to is the F set. So while he was ": [
      674.1,
      704.2,
      17
    ],
    "by induction hypothesis just into you corresponds to a path from s to you. And so then you just get that picture. I noticed how similar this is. That's just the initialization. Yeah, you start off not knowing anything, right? You start off thinking that everything is far away. And then as you go you kind of update them. Okay, so let's go the other direction. Now we want to ": [
      1246.6,
      1285.4,
      31
    ],
    "c and e and do you have f G and H right and then all the other edges that don't make it into the output tree or just kind of like loose, right? FTE Okay now for your favorite part. correctness Okay, so we have to do correct this again because BFS I'm claiming it to do something different than what Graph Search does. I'm claiming it to Output these ": [
      1011.9,
      1060.1,
      26
    ],
    "can have the distance from a Vertex to itself is 0 cuz remember there's always a path from a Vertex to itself with with without any edges. Okay, if there is no path between two vertices, then we say that the distance is infinite, right? You can't get there. It's bigger than anything that you could. bigger than any other distance Okay, let's go back to the graph search thing. ": [
      356.0,
      385.3,
      8
    ],
    "can you answer? Drinkabilitea. Okay good. Reach ability. Anybody else? Okay, good topological sort. of Dags Okay anybody else? connectivity So that would be like connected components. Or strongly connected components, right? Maybe even you would put in there like cycles and stuff right finding Cycles. It can also be used as a reduction for Max bandwidth, right? helpful with Max bandwidth Okay, so Those are the ones what did ": [
      226.3,
      308.7,
      6
    ],
    "consider exploring any distance to vertex. Right? And so you can kind of think about these vertices entering the Q in the order of their distance from s Okay, just kind of a nice fact here. That might be helpful when you're thinking about how this works for every possible distance at some point. The stack will only hold vertices of that distance. And this kind of gives you a ": [
      516.3,
      548.9,
      13
    ],
    "description, please include a high-level description with it as you all know reading just threw code can be maddening right? If you have to kind of keep track of all the indices and then you know, how many times have the loop go and then you have to go into the other loop. So if you have kind of like a high-level description saying basically what this algorithm is doing ": [
      2662.6,
      2688.4,
      66
    ],
    "distance means shortest path. Break the minimum over all pass from s to you. Of the sum of the edge length and for all vertices that are unreachable. It will be set to Infinity just like we said before. Okay. So how we going to do this? Well, you're going to see that this is a lot like what we did for the max bandwidth the path instead of checking ": [
      2775.6,
      2808.0,
      70
    ],
    "distance values correctly. So just like before all these graphs archetype algorithms. We have to do two directions. The first thing I want to do is show that every time I assign a distance value, it's actually it actually corresponds to a path. Okay, and you do that by induction. K2 BFS is done distance B is the length of the shortest path from s to be so One Direction ": [
      1060.1,
      1087.7,
      27
    ],
    "done with all the neighbors throw V from attacks. Okay, so let's say let's stop there. So you guys can maybe read up on chapter 4 you can you can get ahead a little bit and we'll start off with an animation. of dijkstra's algorithm I just wanted to bring some. ": [
      2906.7,
      2934.6,
      74
    ],
    "eject And inject have you guys heard that before? No. And cue in DQ. That's just what it is. an injectable B&Q I don't know just want to put that up there so that when you read it in the book, you know what they're doing. Okay, so let's go through this real fast. You set all of the distances to Infinity. Then you set the distance of s to ": [
      625.4,
      674.1,
      16
    ],
    "else but I like this idea of to get the output tree think about all of these vertices as like balls and the edges are our strings, right? So what you can think about is grab a grab your starting for a text and let all the other things hang and what does it look like? you have a and you have B&D here. and then from b u have ": [
      978.4,
      1011.9,
      25
    ],
    "falling behind then we will provide one-on-one sessions with the Tas and tutors so that you can ask questions about previous lectures previous homeworks. It's mainly so that during office hours. We can kind of move forward. Whereas on these in these 101 sessions. You can kind of move backward and then catch up. Okay, so I try to get that set up so that we can do that next ": [
      110.6,
      143.3,
      3
    ],
    "for some of her text that there's a pack P from s2v such that the length of P. The length of the path is actually shorter than whatever BFS set the distance to. Okay, so just like we did before we're going to suppose that this path exists and we're going to find a contradiction. So let me just introduce another notation. Let's say that D of V. is the ": [
      1319.7,
      1353.5,
      33
    ],
    "for what we're looking for. And then once you get your grades back, of course compare them to the solution. Got any questions about that? Okay, so the last class. Basically for the whole time, I guess the last two weeks, but mainly this past week we've been doing DFS. What is DFS good for? Anybody have any comments about DFS? What do we use it for? But what questions ": [
      172.5,
      226.3,
      5
    ],
    "for you to to see for your homework for whenever year presenting algorithms and also for me when I'm presenting algorithms to you. The reason that we do it this way. This is kind of the idea guy. So the end goal really what you want is something that you can Implement into a computer, right? You really want like the end goal to be a pseudocode or machine code ": [
      2583.7,
      2607.3,
      63
    ],
    "from s2v, actually, I think in my base case I need to do one more thing distance V is infinity is the what would you call that path that empty path? So after Tia durations you always there's always going to be a path that gives you that distant. Okay inductive step. Well during the next iteration. All you're doing is exploring one of the vertices, right? So you're looking ": [
      1152.4,
      1191.8,
      29
    ],
    "have this high level or mid-level description. Now, you can modulate what different data structures you can put in weave already kind of sort of seeing this when we talked about Graph Search and we put in a stack and a queue just by putting in different data structures you get different results and you make a different run times. song case study dijkstra's algorithm. I'll give you kind of ": [
      2719.9,
      2747.9,
      68
    ],
    "in the queue B & E. Right, so then we look at be so we get C and F. and then we look at eat and we get d You guys can you guys even read those letters? I barely that's fine cfd. And then we're done right after me and then F and then T. Okay, but these have numbers on them. You guys can read those the actual ": [
      2114.2,
      2148.7,
      54
    ],
    "is after every iteration distance via the length of some path. Daiso just going to kind of do sort of an abbreviated version of this proof because it's it's basically like all the proofs that we've done already so bass case. Is that distance? Of s is equal to 0 that corresponds to the trivial path. inductive hypothesis assume after t iterations distance V is the length of some Pat ": [
      1087.7,
      1151.0,
      28
    ],
    "is is there a way to do this using reduction? any any ideas Okay good. I guess. Anybody else? Oh like we did the Mac Band with going to work. She keep on adding the smallest edges. Yeah, but that still might not work really. Well, right because you could have like where's my drink? What if you had a bunch of ones? and then a 2 I told you ": [
      2268.9,
      2369.4,
      57
    ],
    "it is such and such that gives the reader more kind of foresight into how to how to parse the code. So Clarity correctness proofs are usually a lot easier when we're talking about math objects because proofs are usually like a mathematical type of statement and inflexibility. And this is what we're going to see with dijkstra's algorithm. That's why I'm presenting it now is now we're going to ": [
      2688.4,
      2719.9,
      67
    ],
    "it so I have thee here. And you was one of its neighbors. And here's ask. so there's a path from s22 V that's going to be the distance of v and maybe there's a path. From s to you and that'll be the distance from to you. But if going through V is better than going on that red line then update you come the idea. Then when you're ": [
      2872.8,
      2906.7,
      73
    ],
    "know does it actually achieve the shortest path. Are there any pads that are better peso after VFS is done distance V is the length of the shortest path from a to be for all vertices. Okay, so just like we did before let's prove this by contradiction by. By supposing that there's this other path out there that shorter than the path that corresponds to distance B. A surprise ": [
      1285.4,
      1319.7,
      32
    ],
    "least to get between two points anybody any others? time good. Probably also want to minimize time anything else. Okay fuel consumption. Maybe you're the airline right and you are worried about fuel consumption? Anybody else? Comfort comfort level okay, I'm going to put this one kind of differently because Comfort level is not really these other ones. These are going to work a lot these going to work well ": [
      1799.1,
      1862.4,
      47
    ],
    "new graph. That kind of makes sense. Okay, so This this is great because it's easy to do right? It's really easy to implement, but you could run into some problems. What if you're trying to do this graph? This graph originally has 10 edges and then if you do it this way you're going to end up with 1783 new vertices made it starts off with 10 and then ": [
      2455.4,
      2491.2,
      60
    ],
    "not empty. You eject or dq2 which means take off the the top element and then for all the neighbors you check to see if it's visited. You don't have to check to see if it's in some sort of visited or whatever. All I have to do is just check if it's distance is infinity or not. Cuz if it's Infinity than it hasn't been explored yet. Hey, if ": [
      704.2,
      730.1,
      18
    ],
    "of ahead of schedule. But if you look at another way, maybe that means that we're going too fast. So we finished basically all of chapter 3, and I wanted to just kind of Open it up for you guys to ask it questions about it. Just so that I know it's okay to move on to chapter 4 stuff today. So anybody have any questions about the things that ": [
      48.1,
      79.2,
      1
    ],
    "or something like that. But it's first useful to come up with a high-level version the high-level version specifies what the algorithm wants to do at every step in terms of abstractions in terms of math objects such as sets relations graphs and so on but not all the details of how it's going to actually accomplish those things. You just going to say that it does those and worry ": [
      2607.3,
      2632.6,
      64
    ],
    "pick the v in a very special way and that's going to give us a good run time efficiency. If we just leave it to be picking any value of the willy nilly the algorithm will still work, but it won't be as efficient. Queso for each neighborhood V each neighbor U of V if the distance of you is set already, but it's bigger than going through V10 reset ": [
      2844.3,
      2872.8,
      72
    ],
    "problem you modify the input instead. It's just it's just means that you're using a given algorithm as a subroutine. So in this case, you take your original graph, which is the one on the left and you change it to be this new graph. The one on the right now, I can run BFS without any without any changes without any modifications. I just run regular BFS on this ": [
      2417.1,
      2455.4,
      59
    ],
    "put in the queue before w. So Wednesday is ejected W is injected with this. distance but that's what we assumed DW was so then we get dissed W is equal to DW if that's the contradiction. K-stew is that DW is actually less than DC plus one. The only way that that's possible is if there's some other path that goes like that. rank Because we we are assuming ": [
      1455.9,
      1495.4,
      37
    ],
    "queso Let's let's think about the differences between stacks and queues peso. The queue actually gives you more information in the Stacked us right cuz the Q starts with just the node ass. It's the only one that has distance 0 right. What are the next nodes to be put into the Q? Okay, so the neighbors of s right so all the neighbors of s will have distance one, ": [
      452.0,
      489.3,
      11
    ],
    "reason is because This vertex here. Maybe this is the wrong distance to so then you can't really can't really anchor it on anyting right. We're anchoring it on the fact that distance Z is actually the shortest path. This is part of the Assumption and so I guess you can make this proof and say assume that V is the first time that that switches so that the the ": [
      1571.8,
      1598.7,
      40
    ],
    "right? So those all get put into the queue, right? Then since we're doing the first in first out, all of the nodes of distance one will be explored. And as you explore each one of those you're finding all the distance to vertices and those are going to be going into the end of the queue, right and all the distance one vertices will be explored before you even ": [
      489.3,
      516.3,
      12
    ],
    "see what different Edge Edge weights do to the graph. Anybody else any other questions or comments? What is it? Oh, yeah, so popularity and then how would that? Would you want to go on a popular flight? Right. Yeah. Yeah. But that might also be a good one for Max bandwidth, right? Yeah, what is that anyway? Yeah, but for what? Is like a biological thing and what are ": [
      1910.5,
      1970.5,
      49
    ],
    "sense that they're going in order. Okay, so Rexburg search why is that still? So given a graph in the starting for a text BFS compute distances from s to every other node. It keeps this information in an array called dist to do this BFS compute distances layer-by-layer kind of what I was saying. It sets distance s to be 0 and the next layer is all the vertices ": [
      548.9,
      579.1,
      14
    ],
    "shortest distance on grass where each Edge has equal weight, right doesn't matter what it is, but they all have to be the equal weight because BFS gives you the number of edges. So what happens if we perform DFS BFS on this graph? Let's look. Okay. So I start off as a right So let's just keep track of our Q. So I have a and then we put ": [
      2085.1,
      2114.2,
      53
    ],
    "shortest path graph if you are looking at the numbers. I know right? What because instead of going directly from B to F. You could have gone. Through C. And that would have been a path of length 3 we're going to rectally from B to F is a path of length 4. So how we going to get around this? I want you guys to get within your groups ": [
      2148.7,
      2185.1,
      55
    ],
    "so you ignore it, but CND have distance of infinity. So you put those in And what do you set them to? to write so what is your cue look like we'll be has been ejected D moves to the front and then you have c and e like that. questions about that You guys probably are I've all seen this already before. Okay, so let's just finish it up. ": [
      833.2,
      876.2,
      22
    ],
    "terms of ass OK and components because it doesn't make any sense to it. Really what we want is shortest path from ass. Then all I really want to know is if it's connected. What's the shortest path if it's disconnected then is disconnected and that's it. Okay, so let's move on to a different problem. It's very similar, but Let's think about graphs and instead of finding shortest paths. ": [
      1688.4,
      1722.7,
      44
    ],
    "that distant Z is actually actual shortest path right? We're assuming that this path. Is the actual shortest path from s to Z. So if we if there if DW is a shorter path and that means you have to kind of circumvent it but that means that new pack with that little huh that's going to be a shorter path to V. So that's a contradiction because we assume ": [
      1495.4,
      1522.7,
      38
    ],
    "that this was the shortest man. Banksouthern the path p is actually not the shortest that we found a short of that which is a contraction. questions is the shortest path in anything but to get there a mystery shop, go straight edge. Are you are you questioning why we have to do what why we have to use z&w instead of just going right to V. Yeah, so the ": [
      1522.7,
      1571.8,
      39
    ],
    "that. Okay. So let's let's divided into two cases on. What is DW? Okay. So DW could be actually DZ plus one. Maybe the shortest path is actually this black line. Maybe that's the short span. If it is then when you been when you discover Z. W will be one of its neighbors and so you'll set it to be just Z Plus One. Write an algorithm Z is ": [
      1413.9,
      1455.9,
      36
    ],
    "the distance is infinity then update the distance value and put it into the Q. and update it to be the distance to its parent plus one. Okay, so let's look at this. Look at this inaction. Okay. So these are going to be my distance values. I'm going to keep them in here in this array and I put a bunch of levels because they're just going to change. ": [
      730.1,
      759.8,
      19
    ],
    "the same. Idea that we use for all those other proofs that were like then. Don't worry. We'll see another one for dykstra's. little bit more complicated but now it's actually a lot like this one. Okay, so let's think a little bit more about how these things differ DFS uses information about the whole graph write the connectivity the SCC the topological sort. Does the graph have Cycles? Right? ": [
      1627.8,
      1663.6,
      42
    ],
    "those Edge weights? energy Yeah, I just put that up there because it has Edge weights. It's another example of a graph with Edge weights. I don't know what kind of algorithm you would need to do. Any I don't even know what it is, but I know what this is though. This is New England or part of New England part of New York and those numbers there are ": [
      1970.5,
      2009.7,
      50
    ],
    "to be a stack. We saw that earlier this week. Then you're talkin about DFS we're going to look at now is if f is a q so the first found is the first explored. right Isn't that how it is? Yeah. And then there and then if we have time we might get to F being a priority queue, but that's probably more likely to be next week's lesson. ": [
      416.7,
      450.0,
      10
    ],
    "to see if the vertex is in X or F you update it with this value depending on its neighbors. So same same idea. We're going to initialize v&s for all those. Well, f is not empty. Let's pick some v&f and we're going to see that for now. We'll just pick any V. But we're going to see that the power of dijkstra's algorithm is that we're going to ": [
      2808.0,
      2844.3,
      71
    ],
    "vertex right before it has any quality just trying to find that Gap where you go from equality to not equality because that's going to be with the point where you can get your contradiction. Right because honestly what's going to happen at the end is you're going to have equality through all the pads. Yeah, if it messes up there then it messes up everywhere. And I sort of ": [
      1598.7,
      1627.8,
      41
    ],
    "we did in chapter 3? Cat follow the book pretty closely for any of those for any of you who have read the book at least for the chapter 3 stuff. So if you do have questions, you can look through the book or come to office hours. Okay, I have another piece of news that is in the works right now. If you do feel like you're kind of ": [
      79.2,
      110.6,
      2
    ],
    "we're going to denote them in a bunch of different ways. You'll see it in different textbooks. Right? It's basically a l of whatever Edge and it might be the weight if it's the weight then sometimes I just say w of whatever Edge I saw something like that. It's just a value that you're assigning to each Edge. Okay. So BFS only really works. Well, if you're finding the ": [
      2059.2,
      2085.1,
      52
    ],
    "week. I'm pretty much done riding the solutions for the homework. So those should be out this evening. So you can look at how your answers compared to the solutions. I highly recommend doing that. Even if you are confident of your answer just because I may have done it in a different way or Ford in a different style and just so that you kind of get a feeling ": [
      143.3,
      172.5,
      4
    ],
    "what? kilometers You know personally I much prefer if they were miles. I think they are. Anybody know how far it is from Philly to New York. I think it's 92 miles. It's all the same thing. You want maybe a shortest path to go distances through cities. Okay, so I just can and I'll be giving a bunch of different values and then we're going to be looking at ": [
      2009.7,
      2059.2,
      51
    ],
    "with shortest path algorithm Comfort level might not because if you take like 10 really uncomfortable flights. Does that add up to a comfortable one? But but what what graph algorithm would work well for Comfort level. Max bandwidth, right cuz you kind of want to find the sequence of flights that has like the the minimum Comfort level that you want. I think so. So good so you can ": [
      1862.4,
      1910.5,
      48
    ],
    "you got you basically multiply it by. 170 rights of this can't be efficient, especially if you have really really detailed Edge lengths like what if your Edge lengths were measuring distance in centimeters from between the different planets? It was just you know, it's really not efficient. There must be a better way, okay? I got any comments on that. Phone number Vision you could you could / like ": [
      2491.2,
      2533.6,
      61
    ],
    "you might say Okay. I want to I want to find the sequence of flights that I travel that give me the the shortest distance, right? Anybody have any other I think so cost. Good, so maybe instead of instead of trying to minimize distance. You don't care about the distance. You just want it to cost the film the least and so Mike what sequence of flights cost the ": [
      1767.2,
      1799.1,
      46
    ]
  },
  "Class Name": "cse101",
  "Date": "01182019",
  "Full Transcript": "Listen to a podcast.  Let's make this let's turn out down the light so we can have a more intimate setting.  Okay, so  I have some good news, and I have some.  What's good news? If you look at it one way and its other kind of news if you look at it another way.  So the good news is that we're going at a good pace and we're kind of ahead of schedule. But if you look at another way, maybe that means that we're going too fast. So we finished basically all of chapter 3, and I wanted to just kind of  Open it up for you guys to ask it questions about it. Just so that I know it's okay to move on to chapter 4 stuff today. So anybody have any questions about the things that we did in chapter 3?  Cat follow the book pretty closely for any of those for any of you who have read the book at least for the chapter 3 stuff. So if you do have questions, you can look through the book or come to office hours. Okay, I have another piece of news that is in the works right now. If you do feel like you're kind of falling behind then we will provide one-on-one sessions with the Tas and tutors so that you can ask questions about previous lectures previous homeworks.  It's mainly so that during office hours. We can kind of move forward. Whereas on these in these 101 sessions. You can kind of move backward and then catch up. Okay, so I try to get that set up so that we can do that next week.  I'm pretty much done riding the solutions for the homework. So those should be out this evening. So you can look at how your answers compared to the solutions. I highly recommend doing that. Even if you are confident of your answer just because I may have done it in a different way or Ford in a different style and just so that you kind of get a feeling for what we're looking for. And then once you get your grades back, of course compare them to the solution.  Got any questions about that?  Okay, so the last class.  Basically for the whole time, I guess the last two weeks, but mainly this past week we've been doing DFS. What is DFS good for?  Anybody have any comments about DFS? What do we use it for?  But what questions can you answer?  Drinkabilitea. Okay good.  Reach ability.  Anybody else?  Okay, good topological sort.  of Dags  Okay anybody else?  connectivity  So that would be like connected components.  Or strongly connected components, right?  Maybe even you would put in there like cycles and stuff right finding Cycles.  It can also be used as a reduction for Max bandwidth, right?  helpful with Max bandwidth  Okay, so  Those are the ones what did I do finding sinks and sources? Yeah, basically what we said. Okay. What is DFS not good for  good finding shortest paths finding shortest distances between vertices. So that's kind of the topic of chapter 4 is we're going to go into that.  All right. So distance in in graph Theory distance between two vertices distance actually just mean shortest distance and you don't have to have two vertices you can have the distance from a Vertex to itself is 0 cuz remember there's always a path from a Vertex to itself with with without any edges.  Okay, if there is no path between two vertices, then we say that the distance is infinite, right? You can't get there. It's bigger than anything that you could.  bigger than any other distance  Okay, let's go back to the graph search thing. And now I'm going to modify it so that I can do shortest distances. I still really want.  To be able to reach all the vertices that are reachable, right? So I'm going to keep the main structure of graph search. The thing I'm going to change is just in what order do I pick the vertices from f  So we seen this before if you if you choose app to be a stack. We saw that earlier this week. Then you're talkin about DFS we're going to look at now is if f is a q so the first found is the first explored.  right  Isn't that how it is? Yeah.  And then there and then if we have time we might get to F being a priority queue, but that's probably more likely to be next week's lesson.  queso  Let's let's think about the differences between stacks and queues peso.  The queue actually gives you more information in the Stacked us right cuz the Q starts with just the node ass.  It's the only one that has distance 0 right.  What are the next nodes to be put into the Q?  Okay, so the neighbors of s right so all the neighbors of s will have distance one, right? So those all get put into the queue, right?  Then since we're doing the first in first out, all of the nodes of distance one will be explored. And as you explore each one of those you're finding all the distance to vertices and those are going to be going into the end of the queue, right and all the distance one vertices will be explored before you even consider exploring any distance to vertex. Right? And so you can kind of think about these vertices entering the Q in the order of their distance from s  Okay, just kind of a nice fact here. That might be helpful when you're thinking about how this works for every possible distance at some point. The stack will only hold vertices of that distance.  And this kind of gives you a sense that they're going in order.  Okay, so  Rexburg search  why is that still?  So given a graph in the starting for a text BFS compute distances from s to every other node. It keeps this information in an array called dist to do this BFS compute distances layer-by-layer kind of what I was saying. It sets distance s to be 0 and the next layer is all the vertices adjacent to ask and then it keeps on going like that and it will just basically as you build that output tree, it sets distance V to be the distance of the parent plus one.  Okay, so that is a empty slide forgot why I put that there. Okay, nevermind and the book uses some kind of weird terminology or maybe it's familiar. So for Q they have these words.  eject  And inject have you guys heard that before?  No.  And cue in DQ. That's just what it is.  an injectable B&Q  I don't know just want to put that up there so that when you read it in the book, you know what they're doing.  Okay, so  let's go through this real fast.  You set all of the distances to Infinity. Then you set the distance of s to be zero because lives the shortest path from s to itself is zero.  You start the Q.  Would just ask in it and then you keep on repeating until the queue is empty, right? What is this Q really? What what place does it what set does it take its place in our original kind of high mid-level Graph Search right to is the F set.  So while he was not empty.  You eject or dq2 which means take off the the top element and then for all the neighbors you check to see if it's visited. You don't have to check to see if it's in some sort of visited or whatever. All I have to do is just check if it's distance is infinity or not. Cuz if it's Infinity than it hasn't been explored yet.  Hey, if the distance is infinity then update the distance value and put it into the Q.  and update it to be  the distance to its parent plus one.  Okay, so let's look at this. Look at this inaction.  Okay. So these are going to be my distance values. I'm going to keep them in here in this array and I put a bunch of levels because they're just going to change. I just wanted you to see what it is every step. Okay, so this will be my cue.  case it starts off with a  I guess we'll start with a right.  everything starts as Infinity  now, so the first thing you do is you deeqa right and then you look at all of its neighbors and for each one you check to see if their distance is infinity which they are and then you set their distances to be one plus the distance of a  Hey, so we're going to put in B & D.  We're going to set B&D to be one and these all stay Infinity.  So then the next thing you do is you pop off bee or not pop, but eject.  And you look at its neighbors Saudi or has a has a distance of 1 so you ignore it, but CND have distance of infinity. So you put those in  And what do you set them to?  to write  so what is your cue look like we'll be has been ejected D moves to the front and then you have c and e like that.  questions about that  You guys probably are I've all seen this already before.  Okay, so let's just finish it up. Okay. So the next one is D width D I get a few set f2b to  And you get CEF?  And then the next one is see nothing happens.  The next one is d  No, sorry, nothing happens.  the next one is f  so F you go to G and you said g to be three?  That's down here and sorry.  G  I'm losing it here.  hear Wright 0 1 2 1 2 2 3 Infinity  I didn't give myself enough space.  there's h  3/4 and then H gets taken off and you're done.  Okay.  so all those red  all those red lines that I drew. Those are the bets the output tree of BFS valpa tree is also the shortest path tree and I think I don't know if it was in the book or I saw it somewhere else but I like this idea of to get the output tree think about all of these vertices as like balls and the edges are our strings, right? So what you can think about is grab a grab your starting for a text and let all the other things hang and what does it look like?  you have a  and you have B&D here.  and then from b u have c and e  and do you have f  G  and H right and then all the other edges that don't make it into the output tree or just kind of like loose, right?  FTE  Okay now for your favorite part.  correctness  Okay, so we have to do correct this again because BFS I'm claiming it to do something different than what Graph Search does. I'm claiming it to Output these distance values correctly. So just like before all these graphs archetype algorithms. We have to do two directions. The first thing I want to do is show that every time I assign a distance value, it's actually it actually corresponds to a path. Okay, and you do that by induction.  K2 BFS is done distance B is the length of the shortest path from s to be so One Direction is after every iteration distance via the length of some path.  Daiso just going to kind of do sort of an abbreviated version of this proof because it's it's basically like all the proofs that we've done already so bass case.  Is that distance?  Of s is equal to 0 that corresponds to the trivial path.  inductive hypothesis  assume  after  t iterations  distance V  is  the length  of some Pat  from s2v, actually, I think in my base case I need to do one more thing distance V is infinity is the  what would you call that path that empty path?  So after Tia durations you always there's always going to be a path that gives you that distant. Okay inductive step. Well during the next iteration. All you're doing is exploring one of the vertices, right? So you're looking at all of its neighbors.  When you're signing to all of its neighbors one plus the distance to that vertex and the path is just the path to that protects pay stub pic.  you from f  If V is a neighbor of you.  then set  the distance be  to be equal to 1 plus distance you  and that corresponds  to the path  from s to you to the right because by induction hypothesis just into you corresponds to a path from s to you. And so then you just get that picture. I noticed how similar this is.  That's just the initialization.  Yeah, you start off not knowing anything, right? You start off thinking that everything is far away. And then as you go you kind of update them.  Okay, so let's go the other direction.  Now we want to know does it actually achieve the shortest path. Are there any pads that are better peso after VFS is done distance V is the length of the shortest path from a to be for all vertices.  Okay, so just like we did before let's prove this by contradiction by.  By supposing that there's this other path out there that shorter than the path that corresponds to distance B.  A surprise for some of her text that there's a pack P from s2v such that the length of P. The length of the path is actually shorter than whatever BFS set the distance to.  Okay, so just like we did before we're going to suppose that this path exists and we're going to find a contradiction.  So let me just introduce another notation. Let's say that D of V.  is the actual length of the shortest path among all pass from esta video V is the actual length remember that diss to be  Is the is the value that the algorithm gives it we haven't shown that those are going to be equal yet, right? That's that's kind of what we're trying to prove now.  Okay, so we have this path from s2v. We know that dissed s is equal to DS.  Because we know that they're both of 0.  Right, and we're claiming that dissed V is greater than TV.  So at some point along this path, you have to kind of break that that sequence right? So let's say that Z is the is the last vertex to have that equality and W is the first for a text to have the inequality.  Okay, just like before questions about that.  Okay.  So let's let's divided into two cases on. What is DW? Okay. So DW could be actually DZ plus one.  Maybe the shortest path is actually this black line. Maybe that's the short span. If it is then when you been when you discover Z.  W will be one of its neighbors and so you'll set it to be just Z Plus One.  Write an algorithm Z is put in the queue before w.  So Wednesday is ejected W is injected with this.  distance  but that's what we assumed DW was so then we get dissed W is equal to DW if that's the contradiction.  K-stew is that DW is actually less than DC plus one.  The only way that that's possible is if there's some other path that goes like that.  rank  Because we we are assuming that distant Z is actually actual shortest path right? We're assuming that this path.  Is the actual shortest path from s to Z. So if we if there if DW is a shorter path and that means you have to kind of circumvent it but that means that new pack with that little huh that's going to be a shorter path to V. So that's a contradiction because we assume that this was the shortest man.  Banksouthern the path p is actually not the shortest that we found a short of that which is a contraction.  questions  is the shortest path in anything but  to get there a mystery shop, go straight edge.  Are you are you questioning why we have to do what why we have to use z&w instead of just going right to V.  Yeah, so the reason is because  This vertex here. Maybe this is the wrong distance to  so then you can't really can't really anchor it on anyting right. We're anchoring it on the fact that distance Z is actually the shortest path. This is part of the Assumption and so  I guess you can make this proof and say assume that V is the first time that that switches so that the the vertex right before it has any quality just trying to find that Gap where you go from equality to not equality because that's going to be with the point where you can get your contradiction.  Right because honestly what's going to happen at the end is you're going to have equality through all the pads.  Yeah, if it messes up there then it messes up everywhere.  And I sort of the same.  Idea that we use for all those other proofs that were like then.  Don't worry. We'll see another one for dykstra's.  little bit more complicated but  now it's actually a lot like this one.  Okay, so  let's think a little bit more about how these things differ DFS uses information about the whole graph write the connectivity the SCC the topological sort. Does the graph have Cycles? Right? So remember it keeps on like updating. It keeps on going until you go through all the vertices even if they're not connected. Where is BFS only gives you info information related to a given vertex. So it's very vertex specific like cuz you're getting all the shortest paths from ass. I don't know the shortest path between any other pair of vertices. I only know what they are in terms of ass OK and components because it doesn't make any sense to it. Really what we want is shortest path from ass.  Then all I really want to know is if it's connected. What's the shortest path if it's disconnected then is disconnected and that's it.  Okay, so let's move on to a different problem. It's very similar, but  Let's think about graphs and instead of finding shortest paths. Just a graph. What if we add edge weight or Edge lengths peso we have this  Map of the United States with I think their flights for JetBlue. Okay, and so each one of these edges is is like a a flight path, right?  Now what kind of different Edge weights could you think of labeling these edges with?  Okay, so you can do the distance, right?  And that sense you might say Okay. I want to I want to find the sequence of flights that I travel that give me the the shortest distance, right? Anybody have any other  I think so cost.  Good, so maybe instead of instead of trying to minimize distance. You don't care about the distance. You just want it to cost the film the least and so  Mike what sequence of flights cost the least to get between two points anybody any others?  time  good.  Probably also want to minimize time anything else.  Okay fuel consumption. Maybe you're the airline right and you are worried about fuel consumption?  Anybody else?  Comfort comfort  level  okay, I'm going to put this one kind of differently because  Comfort level is not really these other ones. These are going to work a lot these going to work well with shortest path algorithm Comfort level might not because  if you take like  10 really uncomfortable flights. Does that add up to a comfortable one?  But but what what graph algorithm would work well for Comfort level.  Max bandwidth, right cuz you kind of want to find the sequence of flights that has like the the minimum Comfort level that you want. I think so.  So good so you can see what different Edge Edge weights do to the graph.  Anybody else any other questions or comments?  What is it?  Oh, yeah, so popularity and then how would that?  Would you want to go on a popular flight?  Right. Yeah. Yeah.  But that might also be a good one for Max bandwidth, right?  Yeah, what is that anyway?  Yeah, but for what?  Is like a biological thing and what are those Edge weights?  energy  Yeah, I just put that up there because it has Edge weights. It's another example of a graph with Edge weights.  I don't know what kind of algorithm you would need to do. Any I don't even know what it is, but  I know what this is though. This is New England or part of New England part of New York and those numbers there are what?  kilometers  You know personally I much prefer if they were miles.  I think they are.  Anybody know how far it is from Philly to New York. I think it's 92 miles.  It's all the same thing. You want maybe a shortest path to go distances through cities.  Okay, so I just can and I'll be giving a bunch of different values and then we're going to be looking at we're going to denote them in a bunch of different ways. You'll see it in different textbooks. Right? It's basically a l of whatever Edge and it might be the weight if it's the weight then sometimes I just say w of whatever Edge I saw something like that. It's just a value that you're assigning to each Edge.  Okay. So BFS only really works. Well, if you're finding the shortest distance on grass where each Edge has equal weight, right doesn't matter what it is, but they all have to be the equal weight because BFS gives you the number of edges.  So what happens if we perform DFS BFS on this graph? Let's look. Okay. So I start off as a  right  So let's just keep track of our Q. So I have a and then we put in the queue B & E.  Right, so then we look at be so we get C and F.  and then we look at eat and we get d  You guys can you guys even read those letters?  I barely that's fine cfd.  And then we're done right after me and then F and then T. Okay, but these have numbers on them. You guys can read those the actual shortest path graph if you are looking at the numbers.  I know right? What because instead of going directly from B to F. You could have gone.  Through C. And that would have been a path of length 3 we're going to rectally from B to F is a path of length 4.  So how we going to get around this? I want you guys to get within your groups and discuss. How would you use BFS as a reduction to solve this problem? Okay, ready go.  How's the weather?  I need to find what OU.  Now we're going to the next thing we're going to talk about is dijkstra's algorithm, which is a good way to do this. But that is not a reduction is it that's a modification so I kind of want to first thing about it is is there a way to do this using reduction?  any any ideas  Okay good.  I guess.  Anybody else?  Oh like we did the Mac Band with going to work.  She keep on adding the smallest edges.  Yeah, but that still might not work really. Well, right because you could have like  where's my drink?  What if you had a bunch of ones?  and then a 2  I told you add in all the ones then you found the path in your algorithm terminates, but there's actually a better path.  Maybe yeah.  Well, this one is not the most efficient either.  And we're going to look at that in a minute.  toe reduction means you take the algorithm like BFS and you use it as a subroutine and instead of instead of modifying the algorithm for a  to solve the problem you modify the input instead.  It's just it's just means that you're using a given algorithm as a subroutine.  So in this case, you take your original graph, which is the one on the left and you change it to be this new graph. The one on the right now, I can run BFS without any without any changes without any modifications. I just run regular BFS on this new graph.  That kind of makes sense.  Okay, so  This this is great because it's easy to do right? It's really easy to implement, but you could run into some problems. What if you're trying to do this graph?  This graph originally has 10 edges and then if you do it this way you're going to end up with 1783 new vertices made it starts off with 10 and then you got you basically multiply it by.  170 rights of this can't be efficient, especially if you have really really detailed Edge lengths like what if your Edge lengths were measuring distance in centimeters from between the different planets?  It was just you know, it's really not efficient. There must be a better way, okay?  I got any comments on that.  Phone number Vision you could you could / like a like a another value?  And then just know they're not really.  That's my location.  Update my all of these numbers don't have a common divisor.  Special moments like have without you.  Oh, but then you just doing.  Then you're just going to do dijkstra's anyway, right?  Okay, so  I want to kind of give you a sense of this high-level to low-level thing and it's in this is good for you to to see for your homework for whenever year presenting algorithms and also for me when I'm presenting algorithms to you. The reason that we do it this way. This is kind of the idea guy. So the end goal really what you want is something that you can Implement into a computer, right? You really want like the end goal to be a pseudocode or machine code or something like that.  But it's first useful to come up with a high-level version the high-level version specifies what the algorithm wants to do at every step in terms of abstractions in terms of math objects such as sets relations graphs and so on but not all the details of how it's going to actually accomplish those things. You just going to say that it does those and worry about figuring out how it's going to do it when you get down to like the mid-level or to the low low.  Okay, so then we fill in those details. We make a low-level or implementation level algorithms from a high level one using data structures in place of those mathematical structures.  Why is this useful for one Clarity and I asked that everybody whenever you hand in any algorithm description, please include a high-level description with it as you all know reading just threw code can be maddening right? If you have to kind of keep track of all the indices and then you know, how many times have the loop go and then you have to go into the other loop. So if you have kind of like a high-level description saying basically what this algorithm is doing it is such and such that gives the reader more kind of foresight into how to how to parse the code.  So Clarity correctness proofs are usually a lot easier when we're talking about math objects because proofs are usually like a mathematical type of statement and inflexibility. And this is what we're going to see with dijkstra's algorithm. That's why I'm presenting it now is now we're going to have this high level or mid-level description. Now, you can modulate what different data structures you can put in weave already kind of sort of seeing this when we talked about Graph Search and we put in a stack and a queue just by putting in different data structures you get different results and you make a different run times.  song  case study dijkstra's algorithm. I'll give you kind of an idea of how this works with dijkstra's algorithm.  Okay. What is dijkstra's algorithm do?  The input is a graph with Edge lengths and a starting Vortex. The output is going to be for all the vertices that are reachable. It will give you dissed you.  Will be set to the distance from s to you using those Edge weight basically the shortest path. I guess I should highlight that distance means shortest path.  Break the minimum over all pass from s to you.  Of the sum of the edge length and for all vertices that are unreachable. It will be set to Infinity just like we said before.  Okay. So how we going to do this? Well, you're going to see that this is a lot like what we did for the max bandwidth the path instead of checking to see if the vertex is in X or F you update it with this value depending on its neighbors.  So same same idea. We're going to initialize v&s for all those.  Well, f is not empty. Let's pick some v&f and we're going to see that for now. We'll just pick any V. But we're going to see that the power of dijkstra's algorithm is that we're going to pick the v in a very special way and that's going to give us a good run time efficiency. If we just leave it to be picking any value of the willy nilly the algorithm will still work, but it won't be as efficient.  Queso for each neighborhood V each neighbor U of V if the distance of you is set already, but it's bigger than going through V10 reset it so I have thee here.  And you was one of its neighbors.  And here's ask.  so  there's a path from s22 V that's going to be the distance of v and maybe there's a path.  From s to you and that'll be the distance from to you. But if going through V is better than going on that red line then update you come the idea. Then when you're done with all the neighbors throw V from attacks.  Okay, so let's say let's stop there. So you guys can maybe read up on chapter 4 you can you can get ahead a little bit and we'll start off with an animation.  of dijkstra's algorithm  I just wanted to bring some. ",
  "Section": "a00",
  "Time": "1500",
  "Video URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-01182019-1500.mp4",
  "Audio URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-01182019-1500.mp3",
  "File Name": "lecture_6.flac"
}