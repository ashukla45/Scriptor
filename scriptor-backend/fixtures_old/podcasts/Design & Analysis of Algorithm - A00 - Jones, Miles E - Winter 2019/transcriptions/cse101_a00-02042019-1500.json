{
  "Blurbs": {
    "And does anybody have any questions or comments? Yeah, so this next Quiz I can already tell you it's going to be a some true-false questions that are mostly going to be do have to do with minimum spanning trees and things like that. And then the design question is going to be a greedy algorithm that I'll actually give you the algorithm, but you have to prove its correctness. ": [
      113.2,
      150.1,
      2
    ],
    "Define OS Prime and then show three things. Has no overlaps it includes G1 and it's better or just as good as OS. Okay, so anybody have any ideas on how to define OS Prime from OS? And then what do you do with J-1? Okay, so you exchange G14 J1? Okay good. That's that's why it's called an exchange argument because most most of the time when you build ": [
      1933.6,
      1985.5,
      49
    ],
    "G1 in there. Because if they don't intersect, then it won't hurt by adding a new interval. Any questions about that? Okay good. So now let's prove that now let's prove the things right? Well, we don't really have to prove that g one is in OS Prime because it's just is by construction. But we do have to prove first that OS Prime is valid and to that OS ": [
      2022.6,
      2056.9,
      51
    ],
    "How about by the fewest conflicts? So let's just take a vote here who thinks that this will work? And who thinks that this will not work? Okay, so kind of half-and-half. This one's kind of tricky actually doesn't work but the to get a counterexample sort of tricky and so I came up with this one. and let's let's just share it so you can see sort of why ": [
      757.0,
      799.6,
      17
    ],
    "I'm sure you could come up with an easier one, but I was just feeling creative so, okay. So how many conflicts does this one have? 1 2 3 4 5 6 7 this one also has seven. This one also has seven. All of these ones have eight, right? And this one only has one two, three, four, five six, seven eight. This one also has eight. These ones ": [
      799.6,
      835.7,
      18
    ],
    "It doesn't seem at first glance that this is going to be any help for the for proving the correctness of the algorithm. We're not even talking about the greedy solution at all own. We're only talking about the first greedy choice, but I claimed that if I can show you the first greedy choice is necessary that's enough to do an induction to show that every subsequent greedy choice ": [
      1843.2,
      1867.1,
      46
    ],
    "Listen to a podcast. Okay, let's get started. So the quiz grades have been released. So I guess about the quiz you can drop one quiz. And another thing is that if you didn't do so well on this quiz, I wouldn't I wouldn't let that get you down so much because you can drop a quiz and also the this class if you haven't already kind of figure it ": [
      1.9,
      83.7,
      0
    ],
    "OS The Green Solution GS is better or just as good as Hey, we're going to do it by strong induction on N. Okay, which is the number of events? Bass cases simple if there's only one event the greedy choice will choose that event and that has to be the optimal schedule, right? Induction hypothesis just assumed that for any of nek events and he said okay events. The ": [
      2539.0,
      2573.3,
      63
    ],
    "Okay, how long would this take in the worst-case? Right Big O of N squared because basically you could have you could have whatever you pick the earliest end time. You may not have eliminated anything else. So then in your next Loop you have and -1 events to look at and then in -2 and then and -3 so you get kind of a big O of N squared ": [
      1293.5,
      1323.8,
      28
    ],
    "Okay. So good. We know that. SI Prime has got to be less than or equal to GS of I Prime. Where GS is the greedy solution. All right good. So basically we get in this is what I just showed you by definition the greedy Solution on the whole set. I is the first greedy choice plus The Green Solution on I Prime Exactly. What you do you pick ": [
      2804.8,
      2845.1,
      69
    ],
    "Prime is bigger or equal to than OS. Okay, so this case is Trivial, right? Because if there's no conflicts, then it will if it won't conflict with jwonn and won't conflict with anything else so you can just add it in. but for this one the claim is that of prime is valid or another way to say that it does not contain any overlapping events, but we're sort ": [
      2056.9,
      2097.3,
      52
    ],
    "So in that sense, it'll be a lot more straightforward and not as Creative as this other quiz, so I don't know if that if you like that better or not or however that works with you. So I'll give you more information on the quiz. Next week, but today's lecture is really kind of the heart of what's going to be on that next Quiz. It's the heart of ": [
      150.1,
      180.6,
      3
    ],
    "That kind of makes sense. 10th right and we just yeah. Family Family Feud Meghan Markle in February Okay, just let anybody have a justification. Did they want to share? About pollution and time of Jay 184 or I guess people at work counting the best settings. Start time of day to okay. This is from the validity, right? of OS Therefore we know that g12 not overlapping. Okay, good. ": [
      2183.7,
      2325.4,
      55
    ],
    "The Exchange argument comes in two parts or the the proof of correctness comes in two parts parts 1 through 3 or the exchange argument. And then part for is induction. Okay, and it's basically the exchange argument is a helper Lema in order to prove the induction and kind of keeps the induction going. Okay, so, let's see it in action cuz I think that's the best way to ": [
      1748.8,
      1779.7,
      43
    ],
    "This is by the choice of the greedy choice, right? Or the by the nature of the greedy Choice could thank you. Okay. So this is a really good clear argument because we have We have Justified each one of those inequalities, right and so it's always the case that the finish time of G1 is going to be at or before the start time of J2. question Oh, yes, ": [
      2325.4,
      2365.9,
      56
    ],
    "algorithm is correct, but if you want to finish the proof, you still have to go through the motions of induction, okay? So let's take a look. So what are we established? This is the exchange argument claim in general. So whenever you do an exchange argument, this is will visit will be what you have. Let G be the first greedy Choice let OSB any solution that does not ": [
      2482.2,
      2506.9,
      61
    ],
    "as many as 2 to the N Optimal Solutions. Is that right? No, that's not right. Don't know. I don't know. Trying to think if there are exponentially many but maybe not because there's only really one ordering that it could be. I guess it kind of could be in like this weird way where a bunch of the events are the same. Or if every pair every event was ": [
      1066.4,
      1128.4,
      25
    ],
    "at the end of take the maximum size. But that's going to be exponential time. I think we can do better. Okay, so, okay. So here's just an example and we'll come back to this in a minute if you guys want to like look at see if you can figure out what is the What is a maximal solution what is an optimal solution for this? So what did ": [
      387.4,
      415.2,
      10
    ],
    "better than that because I really think that the Sorting part is necessary whether it be in a priority queue or outside. one for all the end of x + 1,000 * X then every event is in a certain time, and tomorrow we should have stopped and then she wants you to find the next load and time you can just search for the the next Louis start time ": [
      1442.6,
      1484.6,
      33
    ],
    "contains G1 the first greedy choice and what else do we know about OS Prime? in relation to iOS good and his at least as good SOS or in other words OS Prime is greater than or equal to OS. Tech questions about that No, this is this is what the exchange argument gives us. This has nothing to do with the induction hypothesis yet. This is going to allow ": [
      2673.7,
      2724.6,
      66
    ],
    "decision, right? That's the first thing that you choose. Okay, and now we're going to have OSB any legal schedule that does not include G1. When I claim is that there exists some other schedule that does include G1 that is just as good or even better than OS will call that OS Pro case of this is the exchange argument. This is what we're going to try to prove. ": [
      1812.9,
      1843.2,
      45
    ],
    "do on the quiz next Friday. So we'll do more examples in just the one today but there is a step-by-step way that I want you two to go about doing it. Then there's the greedy stays ahead. It's more intuitive. It kind of makes more sense. As you go. The exchange argument one at start of this backwards way of proving it. Where is a greedy stays ahead. I ": [
      1665.1,
      1689.3,
      40
    ],
    "doubled right then you'd have to the end over to right. So, I mean you could probably figure out a way to do it, but it might run too long because there are so many events in the worst-case. Yeah. All of these problems were only going to want to know the existence of one and that's going to be good enough. Costco Yeah, let's say that there are an ": [
      1128.4,
      1244.5,
      26
    ],
    "events for is the optimal choice. Take questions about that. Okay, so So how we going to implement this? Kate we're going to we want to design an algorithm that uses the greedy choice of picking the next available event with the earliest finish time. So I want you guys to get into groups talk about how would you implement this so that it runs efficiently. Well, there could be ": [
      1025.8,
      1066.4,
      24
    ],
    "events in the subset can conflict right? No conflicts. Or no conflicting events and the objective here all we want to we want to maximize the number of events right so maximized. Let's say let's call the solution format subset s-so maximize s the size of the subset. Okay, so this is going to be helpful when we start making the algorithm and proving the algorithm and everything. Okay, so ": [
      324.3,
      364.0,
      8
    ],
    "events, right? Okay, so let's let's take a let's kind of brainstorm a little bit about how to do this one way would be to go through find the earliest Endtime pick that one and then go through each event to see if it conflicts and if it does then remove it from the set and repeat right so find earliest. end time Go through. and delete conflicting events repeat ": [
      1244.5,
      1291.9,
      27
    ],
    "feel like it's a more kind of direct way. It only works in certain cases, though. Then there's a greedy achieved the band which is really the the most elegant way, but it it doesn't always work. It's not always applicable. Okay. So which one do you is which one do you use is up to you and I'll say unless I say otherwise unless I State otherwise turn on ": [
      1689.3,
      1720.7,
      41
    ],
    "greedy solution will always be optimal whenever K is in between. This should be one. I guess maybe we could we could do another base case at 0 that that might be better and equal zero greedy works. Free also works cuz it just doesn't pick anything which is sort of its trivially the optimal. Okay. Another way to say that is that if the if the input is less ": [
      2573.3,
      2608.7,
      64
    ],
    "include G, then we can conclude that there exists some solution OS Prime that does that does include G and is better or just as good as like I said, this alone does not prove that the album is correct, but we will use an induction argument to use it in and induction argument. induction the greedy solution is optimal or another way to say that is for any solution ": [
      2506.9,
      2539.0,
      62
    ],
    "it as a value cuz we're trying to maximize the number of events. Okay, so we need to show that for every instance for every input. The greedy solution will always be optimal. Okay. So the tricky part here is that the OS solution that were trying to compare the greedy solution to is an arbitrary solution. And so we don't really know much about it. All we know is ": [
      1613.1,
      1638.2,
      38
    ],
    "like this and you will always be able to kind of use the same argument. question The Green Solution for a 2 month anniversary gift that's like what we did here. Yeah. Why would you do a greedy algorithm for hamiltonian path? It would depend on what is your greedy Choice. What is your greedy choice? Yeah, what you come up with a greedy Choice, then we can show you ": [
      2907.2,
      2976.5,
      72
    ],
    "me an answer of only one event where the actual optimal solution has two events that questions about that. Okay. How about earliest start time? I just give you one more minute to think about this one. Well at work, or give me a counterexample. You got you got a counterexample already. Starting at 2 so you owe me this. Let's get the point across. Thank you for that. Okay. ": [
      697.2,
      755.9,
      16
    ],
    "of borrowing events from OS right from the other original solution. And so we already know that since it's valid. None of the JV intervals will ever intersect with each other. So the only thing I really need to show you is that that new interval G will not intersect with anything and it it's sufficient to just prove that g one does not overlap with J2. Okay, so I ": [
      2097.3,
      2124.7,
      53
    ],
    "one of these guys right pick this guy. Pick this guy and then pick this guy. Right she can get for but if I pick the fours then I've kind of like destroyed this optimal schedule. questions about that Okay, so that one doesn't work. Okay. How about earliest finish time? Who says this one doesn't work? Okay, who says it works good, it works. I mean, I mean if ": [
      887.6,
      933.6,
      20
    ],
    "only have three a piece. right 4 right 4 piece this one has one two, three, four, five six, seven eight. Each one of these has one two, three, four, five six, seven eight. and each one of these has 1 2 3 4 5 6 7 You guys see what's going to happen here. Right before we go any further. Let's figure out what is the optimal? Schedule pick ": [
      835.7,
      887.6,
      19
    ],
    "out all of the conflicting events that remain and this one. Okay, and then the one that ends the earliest now is just this one here. And then after that, I don't think you have anything other other conflicts. So then this is the last one remaining and so you choose it there so you can get you could packing for I claim that you can't pack in any more ": [
      998.7,
      1025.8,
      23
    ],
    "out is going to be sort of like we're going to be changing topics for Better or For Worse, right? Maybe that means that the next topic will really click with you and you can figure it out really well, so yeah, maybe the next Quiz will be more kind of your type of problems. I don't know. Just keep on moving forward with what we have to do here. ": [
      83.7,
      113.2,
      1
    ],
    "part. I know it's going to seem like it's a lot but it's really systemic and you just have to follow the same format every time okay, we're going to go through it. But I just want you to know that to me. This is the most most important part of the proof. You need to prove this first and once you prove it you can be confident that your ": [
      2462.5,
      2482.2,
      60
    ],
    "plus one, right? Which means that I guess I should do. This OS Prime is equal to OS. And Os Prime is great strictly greater than OS. And that's what we needed to show that it all cases OS Prime is better than or equal to questions about that. Okay, so that is the exchange argument. That's the kind of the the the main part of the proof the induction ": [
      2427.1,
      2462.5,
      59
    ],
    "put it into a q i mean or you could do it your way where you just don't sort it at all and you start with a priority queue. It's going to be the same run time. The same complexity but I just kind of think that this might be a little bit easier to kind of think about so you sort it and then you put the first event ": [
      1363.7,
      1383.8,
      30
    ],
    "put one way that was kind of director straightforward that I thought. Any other questions? Okay, let's move forward. So let some let's go back to this event scheduling the cookie conference. We want to schedule the most events possible without two events. Overlapping cuz think about the only have one room to schedule everything. So let's fill in these specifications again. So the instance is going to be a ": [
      249.2,
      283.8,
      6
    ],
    "really kind of weird edge cases. You can get like a N squared run time if you have like a bunch of collisions. Okay, so let some. Run time we already did that. Okay, let's move on. Okay, so proving optimality where we at we have time for this good. Okay. So what does it mean that when I say that the greedy algorithm solves and optimization problem? Okay. So ": [
      1528.6,
      1558.4,
      35
    ],
    "remember that we have an instance which is like the information given let's say that GS is the greedy solution and that oasses any other solution to the instance for The Green Solution to be called optimal that means that the value of any solution is less than or equal to the value value of the greedy solution. And it kind of depends on are you maximizing or minimizing if ": [
      1558.4,
      1589.9,
      36
    ],
    "right Yes. because I imagine you have a bunch of events that have the same start and end time always Point your hash-table wouldn't really get you anything because if your hashing based off starting at times, but you used to Yeah, it's okay. It's definitely a way that you could do it though. It would work. But you might or might not get better than this. For some light ": [
      1490.3,
      1528.6,
      34
    ],
    "set. events and what a kind of information does an event hold is just basically the start time and finish time they so we're going to have like anyone event one up to event. write a set of events where EI is going to just be an ordered pair Sif I start and finish time the solution format is going to be a subset. And the constraints are no two ": [
      283.8,
      324.3,
      7
    ],
    "so does anybody have a counterexample or does anyone want to try to convince me that it works all the time? Okay. Okay 9 to 12. I guess the rest of them. Okay good. So what is the spell is because if I choose the smallest one, which is the 9 to 12, then I can't choose any of the other ones cuz they're all conflicting and that would give ": [
      654.4,
      697.2,
      15
    ],
    "than n then the greedy solution is better than any other solution. The goal is to show that The Green Solution is optimal for any input of size exactly end. Let's get started. Let OSB any solution of the set of events. I equals e 1 through e n what can we conclude using the exchange argument? Okay, so we can conclude that there. exist a solution OS Prime that ": [
      2608.7,
      2672.3,
      65
    ],
    "that it has that specific event. And then it has some other solution on I try some other subsets of those events that don't konflict and so-and-so. What can we conclude using the inductive hypothesis of this? Well, yeah, we know that I prime is less than end. Right so, how'd it what does that tell us about s of I to The Green Solution on iprimus optimal rent. Yes. ": [
      2766.1,
      2804.8,
      68
    ],
    "that it is a solution and so we have to kind of use that. Sort of vague definition while we're doing the proof. Okay, so this is going to be how we mainly do it. There's a few different ways. There's the modify the solution or exchange argument. This is the most General this what we're going to do today. This is basically what I'm going to ask you to ": [
      1638.2,
      1665.1,
      39
    ],
    "that should be G1. Sorry about that. Thank you. Are there any other questions? Okay good. So OS Prime is valid great. We've done that now we have to show that OS Prime is greater than or equal to iOS and I was going to have you guys talked about this with your neighbors, but maybe we should just say it because it's it's pretty simple just from the way ": [
      2365.9,
      2396.6,
      57
    ],
    "that we constructed it, right if we include G1 and take away J1 then OS Prime. Is equal to o s + 1 - 1 so that means they're equal. It's okay, if they're equal. It's just that you don't want one to be worse. You don't want OS Prime to be worse than the other. And in this case we have that OS Prime. Is equal to o s ": [
      2396.6,
      2427.1,
      58
    ],
    "the homework you can use whatever one you want. But the modify the solution AKA exchange argument applies almost universally. So that's the one we're going to work on today. Okay modify the solution AKA exchange argument. I know this is a lot to unpack but I mainly put this slide up there for you guys to reference later. Okay, so I'll just kind of go through the main points ": [
      1720.7,
      1748.8,
      42
    ],
    "the the earliest and time and then you pick the earliest and time among all the events that don't reflect. Okay, so by conclusion you get this you started with iOS. We use the exchange argument to force it to have the first greedy choice. We broke it up into the greedy choice plus all the other events. We use the induction hypothesis to show that that it's better to ": [
      2845.1,
      2874.3,
      70
    ],
    "thing happened. Does anybody have anything that's better than N squared? Okay good. Okay good. So basically you want to You're using a priority queue. I have a different way of doing it, which is sort of the same thing as you sort it first. And then you go through and you sort it by finish time. So, you know that you have to take the first event. And you ": [
      1323.8,
      1363.7,
      29
    ],
    "this new solution, you're exchanging one event, or thing for another is this where have the in animation? Oh, yeah. Pretty cool, huh? Okay, so that's that's the exchange and it's easy easy enough to say and in fact, I'm I made it even a little bit more specific I said. If J1 intersects with G1 then then exchange one for the other if they don't intersect then just add ": [
      1985.5,
      2022.6,
      50
    ],
    "time. the number That's why it's good to do this thing. We're trying to maximize the number of events in the subset. Okay, any other ideas? Okay. I have a few more. Shortest duration doesn't these are the two that we looked at right shows duration in earliest and time. You could also consider early as start time or fewest conflicts right now. I'm not claiming that all of these ": [
      462.6,
      522.9,
      12
    ],
    "times. So you just pretty much figure out where that where the next. one starts current when you keep on putting it in. Okay. So basically this is going to take Big O of n log n time And this whole thing. Is going to take a big old van time. So the whole thing will be big Olaf in login. I don't really know if you can get any ": [
      1412.1,
      1442.6,
      32
    ],
    "to G1. Now, let's define OS Prime from OS. Okay, so let's just kind of think about it in this picture. This is the the schedule of os remember it's a legal valid schedule which means that none of the events conflict. Right? And the only thing that we can say for sure about it is that it does not include G1. Okay, so our to-do list is to First ": [
      1898.5,
      1933.6,
      48
    ],
    "to look at it. Okay, so we're going to prove the event scheduling problem with the greedy choice being the earliest and time. Let me be the set of events you want through e end where s i and f i r the start and finish times of the event at 9. Let's say that one is the event with the earliest finish time the first video the first greedy ": [
      1779.7,
      1812.9,
      44
    ],
    "us to take the set of an event and make it a smaller set by eliminating everything that conflicts with G1. Yeah. Okay good. So that's what we have. So now let I prime be the set of events that don't konflict with G1. Right, so it's like all the events that remain. Then OS Prime is going to be G1. We know that it it gives us we know ": [
      2724.6,
      2766.1,
      67
    ],
    "use the greedy solution for those other events. And then this is just the definition of the greedy solution. So we started with any Solution on I and we show that it's less than or equal to the greedy Solution on eye. We'll see a few more of these as we go along but they're all going to have this sequence of inequalities inequalities. It's always going to look something ": [
      2874.3,
      2907.2,
      71
    ],
    "want you guys to prove this with your neighbors. I want a clear justification that is based on like mathematical inequalities based on the construction of os Prime. diagram Well, the diagram is just a diagram. I want you to use like all the definitions and start time. Right, you can use the diagram as a help, but I don't want you to rely on the diagram for your justification. ": [
      2124.7,
      2183.7,
      54
    ],
    "we'll pick the one that ends the earliest which is the one that ends at 11, right? Okay. Now that means that we cancel out all the things that are conflicting all of these. And this one? Cake stand out of the remaining ones which one ends the earliest it's going to be I guess this one that ends at 15, right? So you pick that one and you cancel ": [
      959.3,
      998.7,
      22
    ],
    "what's going to be on the next homework that I'll released today and the next homework will be due next Sunday and it's basically all just trying to prove greedy algorithms are correct any other questions or comments? It was like around 60. percent there's a Piazza post with some. With some common mistakes that I think you all should look at 2 to get a sense of even if ": [
      180.6,
      221.9,
      4
    ],
    "where it fails. Might be a good exercise to look at that. Where does this spell? I don't know. I mean you can talk about a greedy choice for traveling salesman. Just always take the the shortest path from where you are. I can show you where this fails for. That might be a good idea question. Can you eat San Diego podcast? ": [
      2976.5,
      3009.8,
      73
    ],
    "will be necessary sort of the idea. Okay, so let's do the exchange argument. So let the events in OSB J1 food. JK. Remember OS is just some kind of random arbitrary solution. The only the only thing we really know about it is that it does not include the first greedy choice. Okay, so it's ordered by start and finish times and we know that J1 is not equal ": [
      1867.1,
      1898.5,
      47
    ],
    "will work. It will always give you the optimal strategy or come up with a counterexample. Ready go. and raise your hand if you have a question or you need a yeah. Right. Yeah, that's why all the greedy strategies are always going to work. It's always going to be pick the greedy Choice and then reconfigure your input so that your next choice is valid. better than granular Okay, ": [
      547.8,
      654.4,
      14
    ],
    "work. I'm just we're just trying to brainstorm about what are some greedy strategies and I'll tell you right now. Some of them work and some of them don't okay. So let's go through them. the shortest duration So I'm just going to give you like 1 minute or so. I want you to talk it over with your neighbor and I want you to either say that it it ": [
      522.9,
      547.8,
      13
    ],
    "you got it, right or you got it wrong. I think it's good to look and on that on that post. I recently edited it so that there's a there's kind of like a brief summary of one way to do it. That being said we saw many different ways to do it correctly. So just like All of these problems there may be more than one way, but I ": [
      221.9,
      249.2,
      5
    ],
    "you guys do we do this last time brainstorm? Okay, so let's do it now. So what are some greedy strategies? Remember the green strategy is basically to pick some sort of simple rule to pick the next event and then eliminate all the conflicting ones. So what's one simple rule? Okay, so choose it by? earliest And the time like that right anybody else? Pick the shortest one each ": [
      415.2,
      462.6,
      11
    ],
    "you play around with it, you can convince yourself pretty well, but you know at first it's not so obvious. And so that's why we're going to we're going to have to come up with a proof. Okay, so we can't find a counterexample will prove that it works soon. OK Google So let's do it on here. Let's do the actual algorithm on this particular set of events. So ": [
      933.6,
      959.3,
      21
    ],
    "you set your F value which is like, you know, the the time the latest time that you have the latest finish time out of all the events in your set and then you kind of cycle through the events and find out where the wherever the next one starts which is after your finish time. That's going to be your next choice cuz you've already ordered them by finish ": [
      1383.8,
      1412.1,
      31
    ],
    "you're minimizing then the cost of the greedy solution is less than or equal to the cost of the optimal the cost of any other solution. Okay, so I'll use value and cost value usually means I'm trying to maximize it trying to maximize the value cost usually means I'm trying to minimize it and turn them into mice cost for so for the event scheduling problem. You think about ": [
      1589.9,
      1613.1,
      37
    ],
    "your goals are scheduled the most of it's possible. I think we already talked about this if we had an events then. Then there would be two to the end subset. So that's one way to do it if you wanted to do a brute force would be to go through every single possible subsets check if it follows the constraints and if it does record its size and then ": [
      364.0,
      387.4,
      9
    ]
  },
  "Class Name": "cse101",
  "Date": "02042019",
  "Full Transcript": "Listen to a podcast. Okay, let's get started.  So the quiz grades have been released.  So I guess  about the quiz you can drop one quiz. And another thing is that if you didn't do so well on this quiz, I wouldn't I wouldn't let that get you down so much because you can drop a quiz and also the this class if you haven't already kind of figure it out is going to be sort of like we're going to be changing topics for Better or For Worse, right? Maybe that means that the next topic will really click with you and you can figure it out really well, so  yeah, maybe the next Quiz will be more kind of your  type of problems. I don't know. Just keep on moving forward with what we have to do here. And does anybody have any questions or comments?  Yeah, so this next Quiz I can already tell you it's going to be a some true-false questions that are mostly going to be do have to do with minimum spanning trees and things like that. And then the design question is going to be a greedy algorithm that I'll actually give you the algorithm, but you have to prove its correctness. So in that sense, it'll be a lot more straightforward and not as  Creative as this other quiz, so I don't know if that if you like that better or not or however that works with you. So I'll give you more information on the quiz.  Next week, but today's lecture is really kind of the heart of what's going to be on that next Quiz. It's the heart of what's going to be on the next homework that I'll released today and the next homework will be due next Sunday and it's basically all just trying to prove greedy algorithms are correct any other questions or comments?  It was like around 60.  percent  there's a Piazza post with some.  With some common mistakes that I think you all should look at 2 to get a sense of even if you got it, right or you got it wrong. I think it's good to look and on that on that post. I recently edited it so that there's a there's kind of like a brief summary of one way to do it.  That being said we saw many different ways to do it correctly. So just like  All of these problems there may be more than one way, but I put one way that was kind of director straightforward that I thought.  Any other questions?  Okay, let's move forward. So let some let's go back to this event scheduling the cookie conference. We want to schedule the most events possible without two events. Overlapping cuz think about the only have one room to schedule everything. So let's fill in these specifications again. So the instance is going to be a set.  events  and what a kind of information does an event hold is just basically the start time and finish time they so we're going to have like anyone event one up to event.  write a set of events where  EI is going to just be an ordered pair Sif I start and finish time the solution format is going to be a subset.  And the constraints are no two events in the subset can conflict right? No conflicts.  Or no conflicting events and the objective here all we want to we want to maximize the number of events right so maximized.  Let's say let's call the solution format subset s-so maximize s the size of the subset.  Okay, so this is going to be helpful when we start making the algorithm and proving the algorithm and everything.  Okay, so your goals are scheduled the most of it's possible. I think we already talked about this if we had an events then.  Then there would be two to the end subset. So that's one way to do it if you wanted to do a brute force would be to go through every single possible subsets check if it follows the constraints and if it does record its size and then at the end of take the maximum size.  But that's going to be exponential time. I think we can do better. Okay, so, okay. So here's just an example and we'll come back to this in a minute if you guys want to like look at see if you can figure out what is the  What is a maximal solution what is an optimal solution for this? So what did you guys do we do this last time brainstorm?  Okay, so let's do it now. So what are some greedy strategies? Remember the green strategy is basically to pick some sort of simple rule to pick the next event and then eliminate all the conflicting ones.  So what's one simple rule?  Okay, so choose it by?  earliest  And the time like that right anybody else?  Pick the shortest one each time.  the number  That's why it's good to do this thing.  We're trying to maximize the number of events in the subset.  Okay, any other ideas?  Okay. I have a few more.  Shortest duration doesn't these are the two that we looked at right shows duration in earliest and time. You could also consider early as start time or fewest conflicts right now. I'm not claiming that all of these work. I'm just we're just trying to brainstorm about what are some greedy strategies and I'll tell you right now.  Some of them work and some of them don't okay. So let's go through them.  the shortest duration  So I'm just going to give you like 1 minute or so. I want you to talk it over with your neighbor and I want you to either say that it it will work. It will always give you the optimal strategy or come up with a counterexample. Ready go.  and raise your hand if you have a question or you need a  yeah.  Right. Yeah, that's why all the greedy strategies are always going to work. It's always going to be pick the greedy Choice and then reconfigure your input so that your next choice is valid.  better than granular  Okay, so does anybody have a counterexample or does anyone want to try to convince me that it works all the time?  Okay.  Okay 9 to 12.  I guess the rest of them.  Okay good. So what is the spell is because if I choose the smallest one, which is the 9 to 12, then I can't choose any of the other ones cuz they're all conflicting and that would give me an answer of only one event where the actual optimal solution has two events that questions about that.  Okay. How about earliest start time? I just give you one more minute to think about this one.  Well at work, or give me a counterexample.  You got you got a counterexample already.  Starting at 2 so you owe me this.  Let's get the point across. Thank you for that.  Okay.  How about by the fewest conflicts?  So let's just take a vote here who thinks that this will work?  And who thinks that this will not work?  Okay, so kind of half-and-half. This one's kind of tricky actually doesn't work but the to get a counterexample sort of tricky and so  I came up with this one.  and let's let's just share it so you can see sort of why I'm sure you could come up with an easier one, but  I was just feeling creative so, okay. So how many conflicts does this one have?  1 2 3 4 5 6 7  this one also has seven. This one also has seven.  All of these ones have eight, right?  And this one only has one two, three, four, five six, seven eight. This one also has eight.  These ones only have three a piece.  right  4  right  4 piece  this one has one two, three, four, five six, seven eight.  Each one of these has one two, three, four, five six, seven eight.  and each one of these has 1 2 3 4 5 6 7  You guys see what's going to happen here.  Right before we go any further. Let's figure out what is the optimal?  Schedule pick one of these guys right pick this guy.  Pick this guy and then pick this guy.  Right she can get for but if I pick the fours then I've kind of like destroyed this optimal schedule.  questions about that  Okay, so that one doesn't work. Okay. How about earliest finish time?  Who says this one doesn't work?  Okay, who says it works good, it works.  I mean, I mean if you play around with it, you can convince yourself pretty well, but you know at first it's not so obvious. And so that's why we're going to we're going to have to come up with a proof.  Okay, so we can't find a counterexample will prove that it works soon.  OK Google  So let's do it on here. Let's do the actual algorithm on this particular set of events.  So we'll pick the one that ends the earliest which is the one that ends at 11, right?  Okay. Now that means that we cancel out all the things that are conflicting all of these.  And this one?  Cake stand out of the remaining ones which one ends the earliest it's going to be I guess this one that ends at 15, right?  So you pick that one and you cancel out all of the conflicting events that remain and this one.  Okay, and then the one that ends the earliest now is just this one here.  And then after that, I don't think you have anything other other conflicts. So then this is the last one remaining and so you choose it there so you can get you could packing for I claim that you can't pack in any more events for is the optimal choice.  Take questions about that.  Okay, so  So how we going to implement this?  Kate we're going to we want to design an algorithm that uses the greedy choice of picking the next available event with the earliest finish time. So I want you guys to get into groups talk about how would you implement this so that it runs efficiently.  Well, there could be as many as 2 to the N Optimal Solutions. Is that right?  No, that's not right.  Don't know. I don't know.  Trying to think if there are exponentially many but maybe not because there's only really one ordering that it could be.  I guess it kind of could be in like this weird way where a bunch of the events are the same.  Or if every pair every event was doubled right then you'd have to the end over to right.  So, I mean you could probably figure out a way to do it, but it might run too long because there are so many events in the worst-case. Yeah.  All of these problems were only going to want to know the existence of one and that's going to be good enough.  Costco  Yeah, let's say that there are an events, right?  Okay, so let's let's take a let's kind of brainstorm a little bit about how to do this one way would be to go through find the earliest Endtime pick that one and then go through each event to see if it conflicts and if it does then remove it from the set and repeat right so find earliest.  end time  Go through.  and delete  conflicting events  repeat  Okay, how long would this take in the worst-case?  Right Big O of N squared because basically you could have  you could have whatever you pick the earliest end time. You may not have eliminated anything else. So then in your next Loop you have and -1 events to look at and then in -2 and then and -3 so you get kind of a big O of N squared thing happened.  Does anybody have anything that's better than N squared?  Okay good.  Okay good. So basically you want to  You're using a priority queue. I have a different way of doing it, which is sort of the same thing as you sort it first.  And then you go through and you sort it by finish time. So, you know that you have to take the first event.  And you put it into a q i mean or you could do it your way where you just don't sort it at all and you start with a priority queue. It's going to be the same run time.  The same complexity but I just kind of think that this might be a little bit easier to kind of think about so you sort it and then you put the first event you set your F value which is like, you know, the the time the latest time that you have the latest finish time out of all the events in your set and then you kind of cycle through the events and find out where the wherever the next one starts which is after your finish time. That's going to be your next choice cuz you've already ordered them by finish times. So you just pretty much figure out where that where the next.  one starts  current when you keep on putting it in.  Okay. So basically this is going to take  Big O of n log n time  And this whole thing.  Is going to take a big old van time. So the whole thing will be big Olaf in login.  I don't really know if you can get any better than that because I really think that the Sorting part is necessary whether it be in a priority queue or outside.  one for all the end of x + 1,000 * X then every event is in a certain time, and tomorrow we should have stopped and then she wants you to find the next load and time you can just  search for the  the next Louis start time  right  Yes.  because I imagine you have a bunch of events that have the same start and end time always Point your hash-table wouldn't really get you anything because if your hashing based off starting at times, but you used to  Yeah, it's okay. It's definitely a way that you could do it though. It would work.  But you might or might not get better than this.  For some light really kind of weird edge cases. You can get like a N squared run time if you have like a bunch of collisions.  Okay, so let some.  Run time we already did that. Okay, let's move on. Okay, so proving optimality where we at we have time for this good.  Okay. So what does it mean that when I say that the greedy algorithm solves and optimization problem? Okay. So remember that we have an instance which is like the information given let's say that GS is the greedy solution and that oasses any other solution to the instance for The Green Solution to be called optimal that means that the value of any solution is less than or equal to the value value of the greedy solution.  And it kind of depends on are you maximizing or minimizing if you're minimizing then the cost of the greedy solution is less than or equal to the cost of the optimal the cost of any other solution.  Okay, so I'll use value and cost value usually means I'm trying to maximize it trying to maximize the value cost usually means I'm trying to minimize it and turn them into mice cost for so for the event scheduling problem. You think about it as a value cuz we're trying to maximize the number of events.  Okay, so we need to show that for every instance for every input. The greedy solution will always be optimal. Okay. So the tricky part here is that the OS solution that were trying to compare the greedy solution to is an arbitrary solution. And so we don't really know much about it. All we know is that it is a solution and so we have to kind of use that.  Sort of vague definition while we're doing the proof.  Okay, so this is going to be how we mainly do it. There's a few different ways. There's the modify the solution or exchange argument. This is the most General this what we're going to do today. This is basically what I'm going to ask you to do on the quiz next Friday. So we'll do more examples in just the one today but there is a step-by-step way that I want you two to go about doing it.  Then there's the greedy stays ahead. It's more intuitive. It kind of makes more sense. As you go. The exchange argument one at start of this backwards way of proving it. Where is a greedy stays ahead. I feel like it's a more kind of direct way. It only works in certain cases, though.  Then there's a greedy achieved the band which is really the the most elegant way, but it it doesn't always work. It's not always applicable.  Okay. So which one do you is which one do you use is up to you and I'll say unless I say otherwise  unless I State otherwise  turn on the homework you can use whatever one you want.  But the modify the solution AKA exchange argument applies almost universally. So that's the one we're going to work on today. Okay modify the solution AKA exchange argument. I know this is a lot to unpack but I mainly put this slide up there for you guys to reference later. Okay, so I'll just kind of go through the main points The Exchange argument comes in two parts or the the proof of correctness comes in two parts parts 1 through 3 or the exchange argument.  And then part for is induction.  Okay, and it's basically the exchange argument is a helper Lema in order to prove the induction and kind of keeps the induction going.  Okay, so, let's see it in action cuz I think that's the best way to to look at it.  Okay, so we're going to prove the event scheduling problem with the greedy choice being the earliest and time.  Let me be the set of events you want through e end where s i and f i r the start and finish times of the event at 9. Let's say that one is the event with the earliest finish time the first video the first greedy decision, right? That's the first thing that you choose.  Okay, and now we're going to have OSB any legal schedule that does not include G1.  When I claim is that there exists some other schedule that does include G1 that is just as good or even better than OS will call that OS Pro case of this is the exchange argument. This is what we're going to try to prove. It doesn't seem at first glance that this is going to be any help for the for proving the correctness of the algorithm. We're not even talking about the greedy solution at all own. We're only talking about the first greedy choice, but I claimed that if I can show you the first greedy choice is necessary that's enough to do an induction to show that every subsequent greedy choice will be necessary sort of the idea.  Okay, so let's do the exchange argument.  So let the events in OSB J1 food. JK. Remember OS is just some kind of random arbitrary solution. The only the only thing we really know about it is that it does not include the first greedy choice.  Okay, so it's ordered by start and finish times and we know  that J1 is not equal to G1.  Now, let's define OS Prime from OS.  Okay, so let's just kind of think about it in this picture. This is the  the schedule of os remember it's a legal valid schedule which means that none of the events conflict. Right? And the only thing that we can say for sure about it is that it does not include G1.  Okay, so our to-do list is to First Define OS Prime and then show three things.  Has no overlaps it includes G1 and it's better or just as good as OS.  Okay, so  anybody have any ideas on how to define OS Prime from OS?  And then what do you do with J-1?  Okay, so you exchange G14 J1? Okay good. That's that's why it's called an exchange argument because most most of the time when you build this new solution, you're exchanging one event, or  thing for another  is this where have the in animation? Oh, yeah.  Pretty cool, huh?  Okay, so that's that's the exchange and it's easy easy enough to say and in fact, I'm I made it even a little bit more specific I said.  If J1 intersects with G1 then then exchange one for the other if they don't intersect then just add G1 in there.  Because if they don't intersect, then it won't hurt by adding a new interval.  Any questions about that?  Okay good. So now let's prove that now let's prove the things right? Well, we don't really have to prove that g one is in OS Prime because it's just is by construction. But we do have to prove first that OS Prime is valid and to that OS Prime is bigger or equal to than OS.  Okay, so  this case is Trivial, right?  Because if there's no conflicts, then it will if it won't conflict with jwonn and won't conflict with anything else so you can just add it in.  but for this one  the claim is that of prime is valid or another way to say that it does not contain any overlapping events, but we're sort of borrowing events from OS right from the other original solution. And so we already know that since it's valid. None of the JV intervals will ever intersect with each other. So the only thing I really need to show you is that that new interval G will not intersect with anything and it it's sufficient to just prove that g one does not overlap with J2.  Okay, so I want you guys to prove this with your neighbors. I want a clear justification that is based on like mathematical inequalities based on the construction of os Prime.  diagram  Well, the diagram is just a diagram. I want you to use like all the definitions and  start time.  Right, you can use the diagram as a help, but I don't want you to rely on the diagram for your justification. That kind of makes sense.  10th right and we just yeah.  Family Family Feud  Meghan Markle in February  Okay, just let anybody have a justification.  Did they want to share?  About pollution and time of Jay 184 or I guess people at work counting the best settings.  Start time of day to okay.  This is from the validity, right?  of OS  Therefore we know that g12 not overlapping.  Okay, good. This is by the choice of the greedy choice, right?  Or the by the nature of the greedy Choice could thank you. Okay. So this is a really good clear argument because we have  We have Justified each one of those inequalities, right and so it's always the case that the finish time of G1 is going to be at or before the start time of J2.  question  Oh, yes, that should be G1. Sorry about that.  Thank you.  Are there any other questions?  Okay good. So OS Prime is valid great. We've done that now we have to show that OS Prime is greater than or equal to iOS and I was going to have you guys talked about this with your neighbors, but maybe we should just say it because it's it's pretty simple just from the way that we constructed it, right if we include G1 and take away J1 then OS Prime.  Is equal to o s + 1 - 1 so that means they're equal. It's okay, if they're equal. It's just that you don't want one to be worse. You don't want OS Prime to be worse than the other.  And in this case we have that OS Prime.  Is equal to o s plus one, right? Which means that I guess I should do. This OS Prime is equal to OS.  And Os Prime is great strictly greater than OS.  And that's what we needed to show that it all cases OS Prime is better than or equal to questions about that.  Okay, so that is the exchange argument. That's the kind of the the the main part of the proof the induction part. I know it's going to seem like it's a lot but it's really systemic and you just have to follow the same format every time okay, we're going to go through it. But I just want you to know that to me. This is the most most important part of the proof. You need to prove this first and once you prove it you can be confident that your algorithm is correct, but if you want to finish the proof, you still have to go through the motions of induction, okay?  So let's take a look.  So what are we established? This is the exchange argument claim in general. So whenever you do an exchange argument, this is will visit will be what you have. Let G be the first greedy Choice let OSB any solution that does not include G, then we can conclude that there exists some solution OS Prime that does that does include G and is better or just as good as like I said, this alone does not prove that the album is correct, but we will use an induction argument to use it in and induction argument.  induction the greedy solution is optimal or another way to say that is for any solution OS The Green Solution GS is better or just as good as  Hey, we're going to do it by strong induction on N. Okay, which is the number of events?  Bass cases simple if there's only one event the greedy choice will choose that event and that has to be the optimal schedule, right?  Induction hypothesis just assumed that for any of nek events and he said okay events. The greedy solution will always be optimal whenever K is in between. This should be one.  I guess maybe we could we could do another base case at 0 that that might be better and equal zero greedy works.  Free also works cuz it just doesn't pick anything which is sort of its trivially the optimal.  Okay.  Another way to say that is that if the if the input is less than n then the greedy solution is better than any other solution.  The goal is to show that The Green Solution is optimal for any input of size exactly end.  Let's get started.  Let OSB any solution of the set of events. I equals e 1 through e n what can we conclude using the exchange argument?  Okay, so we can conclude that there.  exist  a solution  OS Prime  that  contains  G1 the first greedy choice  and  what else do we know about OS Prime?  in relation to iOS  good and his  at least  as good  SOS or in other words OS Prime is greater than or equal to OS.  Tech questions about that  No, this is this is what the exchange argument gives us. This has nothing to do with the induction hypothesis yet.  This is going to allow us to take the set of an event and make it a smaller set by eliminating everything that conflicts with G1.  Yeah.  Okay good. So that's what we have.  So now let I prime be the set of events that don't konflict with G1.  Right, so it's like all the events that remain.  Then OS Prime is going to be G1. We know that it it gives us we know that it has that specific event. And then it has some other solution on I try some other subsets of those events that don't konflict and so-and-so.  What can we conclude using the inductive hypothesis of this?  Well, yeah, we know that I prime is less than end. Right so, how'd it what does that tell us about s of I  to The Green Solution on iprimus optimal rent. Yes. Okay. So good. We know that.  SI Prime  has got to be less than or equal to GS of I Prime.  Where GS is the greedy solution.  All right good.  So basically we get in this is what I just showed you by definition the greedy Solution on the whole set. I is the first greedy choice plus The Green Solution on I Prime  Exactly. What you do you pick the the earliest and time and then you pick the earliest and time among all the events that don't reflect.  Okay, so by conclusion you get this you started with iOS.  We use the exchange argument to force it to have the first greedy choice.  We broke it up into the greedy choice plus all the other events.  We use the induction hypothesis to show that that it's better to use the greedy solution for those other events. And then this is just the definition of the greedy solution. So we started with any  Solution on I and we show that it's less than or equal to the greedy Solution on eye.  We'll see a few more of these as we go along but they're all going to have this sequence of inequalities inequalities. It's always going to look something like this and you will always be able to kind of use the same argument.  question  The Green Solution for a 2 month anniversary gift  that's like what we did here.  Yeah.  Why would you do a greedy algorithm for hamiltonian path?  It would depend on what is your greedy Choice. What is your greedy choice?  Yeah, what you come up with a greedy Choice, then we can show you where it fails. Might be a good exercise to look at that. Where does this spell?  I don't know.  I mean you can talk about a greedy choice for traveling salesman.  Just always take the the shortest path from where you are. I can show you where this fails for. That might be a good idea question.  Can you eat San Diego podcast? ",
  "Section": "a00",
  "Time": "1500",
  "Video URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-02042019-1500.mp4",
  "Audio URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-02042019-1500.mp3",
  "File Name": "lecture_12.flac"
}