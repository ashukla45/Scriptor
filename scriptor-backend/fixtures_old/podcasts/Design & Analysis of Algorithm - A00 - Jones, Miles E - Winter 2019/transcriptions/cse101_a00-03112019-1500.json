{
  "Blurbs": {
    "But then when you do the Ford Fulkerson method you are basically showing that the flood the max flow is equal to some cut and since it has to be less than or equal to all Cuts. Then that has to be the maximum for the idea. So you let the cut be the unreachable vertices night, then all the edges that cross over the cut are being used to ": [
      515.8,
      544.0,
      10
    ],
    "I am of where do I call it? X y j. Is Max profit? from X by y sheet considering Craftsman one through J. I'm hoping that gives you kind of a head start on aisle where to go from there specially with the cuts and stuff. Don't be a three-dimensional array. Okay any other questions? Okay, so let some finish up with this network flow problem and then we'll ": [
      297.5,
      353.3,
      5
    ],
    "I don't know boys, and the other side is girls and there's an edge between a boy and a girl if they like each other and then what you want to do is maybe match them all up in such a way that everybody gets a match. Is that possible or not? So think about maybe something like this? Does this have a perfect matching? You want me to go ": [
      1036.6,
      1086.9,
      26
    ],
    "I don't know if we really talked about this so much last time but let's think about why this method will or will not terminate now in my example. We had a bunch of integer value things, right? And so the minimum amount that you could You could change would be buy one, right? Cuz one of the smallest integer and so if you have Flo's or Edge Edge weights ": [
      604.7,
      639.2,
      13
    ],
    "I think I think your class will be in this room. so the final will be in this room from what was it 3 to 6. P.m. And then the other class. Is in Warren lecture hall. 2001 next door, I guess there's some practice problems for y'all. I'll put some solutions. We're going to have a review session on Thursday. review Thursday any other questions about that? Okay. Yeah. ": [
      72.2,
      145.6,
      1
    ],
    "Listen to a podcast. Okay, let's get started. so last week of classes a lot of things going on. There's a homework due tomorrow night. I'm having a few extra office hours tomorrow morning from 9 to 11. Extra office hours will start my office. Maybe I'm going to need a bigger room. Any questions about the homework? Okay. I guess. Yeah, let's talk about the final. It's on Saturday. ": [
      1.9,
      72.2,
      0
    ],
    "The instance here is a graph. with positive Edge weights and starting node v-0. The solution for Matt is going to be a sequence. vertices v-0 up to V 0 right starting at V 0 and ending at V 0. And this kind of gives you a sense of how big that solution space is, right? Because there's going to be n factorial many different ways that you could arrange ": [
      2311.9,
      2348.8,
      57
    ],
    "What if we take to our original graph and use that same cut. Right, then what I claim? Is that the flow along a cut right which is going to be the the number of the the sum of all the edges that cross over the cut. I'm saying that the actual Max flow can never be greater than that cut. That kind of makes sense cuz you're going to ": [
      453.8,
      487.3,
      8
    ],
    "Y are not equal to one or I guess what's call this number and phone number and X and Y are not equal to one or n. And XY is equal to end so some non-trivial factorization. Okay constraint. Or maybe that's the constraint. Let's do it that way. two integers x and y k constraint is that X Y is equal to N X and Y are not equal ": [
      1816.4,
      1855.9,
      44
    ],
    "Yeah, that's kind of like the whole point of the problem or else you'll just give one sheet to the to the highest paying Craftsman. Let me see if I can. scishow yeah, let's say that this was my sheet of silk and let's say a Craftsman wants like that portion. Then you can like let's say you cut horizontally first so you cut horizontally and cut that off, right? ": [
      156.8,
      198.7,
      2
    ],
    "a little bit more with this talk more about what is NP complete and that will pretty much be the rest of the new content. What I meant was like. Factoring I'd heard it was very officially doable with quantum computers. Which but some in an empty Browns are not easily. Turn lights on. Yeah, so factoring is not np-complete. And so but it is not pee not is not ": [
      2899.3,
      2951.2,
      68
    ],
    "about how efficient the algorithms are that solve them. It says nothing about that at all. All it says is that there's a polynomial time verifier? Okay. So if you want to start talking about efficiency, there's another class called P. This is the class of all decision problems that that have a known polynomial time solution that have a polynomial time solution. Let's say Okay, so what are some ": [
      2047.6,
      2076.6,
      50
    ],
    "all in place, but actually Generating that solution that takes more work, right? So that's that's the sort of difference between these two ideas. Is it easy to verify is it easy to solve and P equals NP if that's true. That means that that would be true if it's easy to verify then it's actually easy to stall. Okay, so let's take a take a look at the traveling ": [
      2244.2,
      2274.8,
      55
    ],
    "also be verified in polynomial time. And soapy is a subset of NP. Now this is the statement of p is equal to NP. Every decision problem that can be verified can also be solved so it's kind of like the converse so we know that this top statement is true is the converse always true. We actually don't know nobody knows. Any questions about that? So for finding a ": [
      2172.9,
      2213.5,
      53
    ],
    "and good. Let's talk a little bit about how to improve this. Because something like this could happen. where You have like a bunch of really heavy edges and then one in the middle that is light. So what if I was really unlucky and the first path that I got from DFS was this past year? Then when I make the residual graph. Basically, I send only one unit ": [
      760.0,
      797.0,
      18
    ],
    "and kind of work your way into the I want to share this with you because p and NP depending on whether they're equal or not has a lot of consequences on whether or not problems are even in and pee or not. Right? We we don't know if the optimization problem is in NP it all depends on if p is equal to NP. Okay, so Wednesday will do ": [
      2869.3,
      2899.3,
      67
    ],
    "and you can do that in polynomial time with respect to the number of bits. array of prime numbers Does that mean that you can still check that because multiplying a bunch of prime numbers together is still polynomial time? Oh. yeah, I suppose that would be harder to do that at all. Would all depend on if the if the if saying a number is prime is efficient, but ": [
      1937.7,
      1991.7,
      47
    ],
    "another instructor. He said that if p is equal to NP, then this class instead of being called design. What is it called design and Analysis of algorithms instead. It would be called design and Analysis of algorithm. You guys got it kind of. The reason is because if p is equal to NP, then all of these problems that we've seen which we're going to kind of classify these ": [
      1278.2,
      1313.7,
      31
    ],
    "back from each one of those edges. So I got something like this. Where is it? And this is going wait. What was this one going? This was going opposite or now. It's going down. And this is going this way, but I have one going back like that. Frank and then what if I was unlucky again and the next PATH I chose was this one you could see ": [
      797.0,
      834.0,
      19
    ],
    "back to the definition of perfect matching? anybody this one Okay. that one this one has to go there and this one goes there. Okay, great many questions about that. perfect matching was that what's the marriage Lima? Oh, okay. Okay. So how do I solve this problem using network flow? Okay, we're going to do is Well Network flow. You need a starting vertex in attending vertex right as ": [
      1086.9,
      1157.3,
      27
    ],
    "basically true. Okay. So this matching problem in general is a lot more complicated, but you can see how you can solve it really fast using this idea any questions before we move on. Okay, let's start with the p versus NP. kind of like to end with this because This class what we've seen mostly are our problems in p and I'll share with you a joke from Russell ": [
      1236.9,
      1278.2,
      30
    ],
    "can beat the budget, right? until you can What do you call that? You can find. a path within the budget Okay, good. So is there a is there a like maybe a more efficient way to use the same sort of strategy, but use fewer calls to the decision problem. Yeah. do a kind of binary search where to start so yeah, so there's a few ways you can ": [
      2769.9,
      2832.0,
      65
    ],
    "coloring 01101 alternating path? Okay is graph. bipartite What was the other one week? That is the sad part of a cycle, right? Okay, so there's a ton of them. Right? But just all of these ones are decision problems, which means that they give a yes or no answer about the problem. Okay. Is there an Arbitrage right does a bipartite graph have a perfect matching? Okay. So how ": [
      1484.3,
      1544.8,
      36
    ],
    "decision problems can all kind of be reduced to each other. And so if you can solve one of them efficiently you can solve another one efficiently and will go into kind of what I mean by those relationships. Okay, let's start with optimization problems. We've seen this many times before right you have your instant solution format constraints and objective function. You're basically looking searching through the space of ": [
      1313.7,
      1341.1,
      32
    ],
    "do I know that that path reaches that bus budget? Well, you just add up all the edge and if the edges are less than b then it's done. So this problem is in p in achieving in NP. Sorry. Okay, so why are these why are these so related? Well, it turns out that if I can solve the this decision version in polynomial time, then I can solve ": [
      2470.8,
      2501.0,
      61
    ],
    "do this. One of them is a question. Yeah, you can start with at some random path right that random path can't be lower than the than the than the minimum right? So start at some random path and then maybe make the budget halfway between that value and 0 right and if it's over then kind of move the budget up if it's lower than move the budget down ": [
      2832.0,
      2869.3,
      66
    ],
    "examples of problems in p? right path in graphs right What are some other decision problems we talked about? is there a perfect matching and bipartite graphs and so on right mainly all the decision problems we see in this class or mostly all of them have all been problems in p questions about that Okay good. P vs. NP so this is the big question. We don't know if ": [
      2076.6,
      2136.3,
      51
    ],
    "hard are these problems? and I guess we're using hard. We're going to kind of give him more of a formal definition of what heart is because are we thinking I don't know if you guys kind of classify the problems as hard if they're hard to like come up with an algorithm to solve them. We're not talking about that. It's more of a How how efficient is the ": [
      1544.8,
      1572.5,
      37
    ],
    "have to get from from one side to the other anyway, and so you're going to have to in this case send 5 units from the left subset to the right subset and that'll be true for any cut. Where you separate S&T, right? So this is sort of like an achieved the bound tight proof. We're going to say that the max flow is never greater than any cut. ": [
      487.3,
      515.8,
      9
    ],
    "if if the input Is there a solution to the input that meets the constraints yes or no, true or false? What are some decision problems that we've seen? I'll put Sudoku up there. happy path right doesn't exist or not write a lot of the graph problems Racine right? Like the what was the other one? That was weird the alternating? Do we do like the blue and red ": [
      1438.8,
      1484.3,
      35
    ],
    "improvements. You're not you're not getting unlucky and going down this path of flow one each time. Okay, let's see. Let's look at a problem that you can solve using this idea. It's called perfect bipartite matching and graph matching in general is a common problem that you might see come up and this is a special example. We were talking about bipartite graphs. Okay. So a bipartite graph has ": [
      968.7,
      1002.8,
      24
    ],
    "in t so we're going to do is just create those and put one on the left side and one on the right side. right something like this. Okay, then if I give all the edges capacity one And all of those inside capacity one. What would what would be true about the max flow if there was a perfect matching like if there was a perfect matching here, what ": [
      1157.3,
      1193.9,
      28
    ],
    "input. It gives just gives you a yes or no answer. So let's let's pause for just a second so that we can address factoring because it is it will see that factoring is a Factoring is NP. Okay factoring. What is the instance? some number right and let's say let's say that it's in bits. Right because I actually want my algorithms efficiency to be dependent on the bits ": [
      1715.6,
      1769.4,
      42
    ],
    "integer value. So the residual capacities are integers in any Improvement that you make has to be by at least 1 so if we have integer values, we know that it will always terminate because we're going to at least improve it by one each time and eventually that'll go down to zero. Okay, stop the total flow can be no more than WV and so the number of steps ": [
      671.0,
      696.5,
      15
    ],
    "is that? That's what NP is? Okay, and this is something that I want you guys to remember. This is going to be one of the true false questions going to be about NP. I'm going to talk about what kind of problems are in in pee and so the only thing that you know about problems in NP is that there is a polynomial time verifier. Okay doesn't talk ": [
      2023.4,
      2047.6,
      49
    ],
    "is what most of our credit cards and encryption a lot of Internet Security is based on the fact that right now nobody has an efficient algorithm for factoring large numbers. Factoring is definitely NP. Yeah, we're going to I'll give you a definition of NP in a minute and we can we can revisit factoring. Independent set we talked about this when we started talking about backtracking. I didn't ": [
      1604.3,
      1650.1,
      39
    ],
    "known to BP either but kind of like in this weird gray area where we don't know where it goes and maybe maybe I don't know so much about Quantum Computing in the classification, so I don't know exactly but Yeah Lil B ": [
      2951.2,
      2970.0,
      69
    ],
    "like or you can cut it vertically first and then or something. Any other questions? You can sell it to the same Craftsman as much as you want. Just imagine that they have an A victim and is always enough that they'll Always by as much as possible. Any other questions? And I gave did you guys all see the hint? I gave you the what the subproblem should be. ": [
      245.2,
      296.5,
      4
    ],
    "max flow is 200 million. And you can get there a lot faster if the first path you picked was this path? Right in the second packet pick was the bottom path. They so it actually makes it a lot more efficient. If you can find the path with the max bandwidth, do we know how to do that? Yeah, right. We did that the first day or the first ": [
      875.4,
      907.9,
      21
    ],
    "most efficient algorithm that solves it? That's how we're kind of going to classify in terms of hardness. Okay, so we have a number of approaches that give Fast algorithms for a wide variety of search optimization decision problems. Some of them though it kind of defeat our standard algorithm look methods if you guys know of No. This p and NP problem. You know that factoring is hard. This ": [
      1572.5,
      1604.3,
      38
    ],
    "noticed that. What happened here noticed that if you could do this you could do you could you could factorize all of them into the prime factorization. If you can do this efficiently, then you just do this over and over and over again until you're done until you get the Primes. Because you do this again and the end it doesn't give you two integers, right? Okay, so where ": [
      1991.7,
      2023.4,
      48
    ],
    "of the number because that's like the the amount of information that you used to store it. Okay, what about the solution format? Maybe the prime factorization kind of depends on what you're trying to do. Are you just trying to factor it once or you trying to factor it more than once? Let's say it. Let's say it's 2. integers What's a X and Y. Such that. X and ": [
      1769.4,
      1816.4,
      43
    ],
    "optimization problem will also be in pee. Exactly. Is it this is it this is a complete graph to so there's an edge between every pair notes. Does anybody have any ideas on how to do this? Okay, good. So start be low. And run the decision traveling salesman problem over and over. increasing B every time until I guess until you find a until until you right until you ": [
      2619.3,
      2769.9,
      64
    ],
    "p is equal to NP. What would that mean? What's the consequence of that? so this is the I guess I should write this P equals NP means. this thing any problem that can be solved in polynomial time can also run away. Sorry. I was thinking about the other slide. This is as big as a true statement. Any decision problem that can be solved in polynomial time can ": [
      2136.3,
      2172.9,
      52
    ],
    "pass through some Edge in the cut. Now when the full Ferguson algorithm terminates its flow is equal to some cut that cut that we did right there for All flows have to be less than or equal to that cut and we went we showed that that cut is actually equal to the flow that we got which means that Festa maximum that the flow could be. Okay, so ": [
      576.7,
      604.7,
      12
    ],
    "path from s to T. And I guess along the way keep on adding the the bandits of those pads to get the maximum flow. So like we said before there's that most WV iterations each iteration takes big O of e time because we're just basically doing a DFS the linear time thing. And so the total time is Big O of wve. Okay, so this is all well ": [
      726.8,
      760.0,
      17
    ],
    "path the verifier would take a graph. And a sequence of edges and tell you this sequence of edges is a path. But actually finding that sequence of edges kind of involves more more work, right and it's kind of the idea. like for example a solution to a Sudoku problem is really easy to verify right you just go through and make sure all the ones and nines are ": [
      2213.5,
      2244.2,
      54
    ],
    "really we never came up with a polynomial time algorithm. Remember we kept on getting a more and more efficient algorithm, but they're all still exponential time hamiltonian path or happy path. In dags, you've you all have seen that it's possible to do it efficiently, but in general finding hamiltonian passes. There's no known efficient algorithm for it. So the question about p and NP is are all reasonable ": [
      1650.1,
      1684.7,
      40
    ],
    "remaining possible flow. And so the total number of iterations is at most HELOC w a v and so the total time because you have to do this at least e x is this kind of big messy thing, which I'm not going to go into the full detail. I just kind of want to share with you that this is a better way to go because you're getting more ": [
      943.4,
      968.7,
      23
    ],
    "s-2t anymore. So Basically, what we've done is we've created a cut which is a separation of the vertices into two groups. Okay in the cut that we made is this Okay, and oh shoot, let me do something real fast. I want the original graph. copy Okay. So this is this is the residual graph. This is when we got stuck right because there's no edges going into tea. ": [
      389.0,
      453.8,
      7
    ],
    "salesman problem. the optimization version so we're giving a complete graph of an vertice or I guess I have and plus one vertices here. Okay. Positive Edge weights would you can think of as like distances between the vertices you want to know? What's the cheapest route that you can take from the starting of v-0 and visiting every single other node and coming back to the zero? Okay, so ": [
      2274.8,
      2309.7,
      56
    ],
    "search and optimization problems easy. If not, what makes some of them hard and can we classify them? And how do we measure that classification? Okay, so this is what MP is. It's the class or set of all decision problems where there's an efficient verifier are what is our well our takes the input and the solution. And it tells you if the solution is a solution to the ": [
      1684.7,
      1715.6,
      41
    ],
    "so now you have like this part and this part right and then you cut vertically. And now you have these two parts. And you're saying can I can you use those these two leftover things? Yeah, for sure, but then you'd sell this portion to whatever Craftsman wants it and then you can cut those in the same manner to give to the rest of the Craftsman if you ": [
      201.7,
      245.2,
      3
    ],
    "solution. We're just trying to find a solution. But most of the problems we've done in this class have been optimization problems good. Yeah, here's some other ones. Okay decision problems. Now, this is like a Sudoku type thing where you have your instant solution for Matt and constraints and now you don't have an objective function. Your objective is just basically to find if a solution matches the constraints ": [
      1408.7,
      1438.8,
      34
    ],
    "solutions trying to find the best one, right? So for what? What are some optimization problems we've seen? Okay. Let's say what shortest path. Max bandwidth Anybody else? What is all events scheduling? scooters Has anybody used that algorithm yet? in practice no. What else all those DP problems knapsack? silk Merchant Sudoku Sudoku is like it's not going to be optimization because we're not trying to find the best ": [
      1341.1,
      1408.7,
      33
    ],
    "start talking about peeing in pee. Okay, so we went through this. This algorithm the Ford Fulkerson algorithm. You basically find a path. You send a flow down the path. That's based on the the lightest Edge in the path. And then you make the residual graph right by Reversing all the edges and you just keep on going until you have reached a point where you can't reach from ": [
      353.3,
      389.0,
      6
    ],
    "that are not integer valued then you can see that you could decrease it by smaller and smaller values and it could lead to some sort of infinite time algorithm. So let's just stick with integer values for edgeways. So basically if the capacities are integers from 1 to W, let's say w is the heaviest one among all the edges we maintain that the invariant that the flow has ": [
      639.2,
      671.0,
      14
    ],
    "that you could keep on getting very unlucky and taking away one every time. Okay, so that's bad because that's really inefficient. Is there a is there a better path to start with? Rather than going through that one. I mean you guys can just look at this and and maybe have an idea of what is the maximum flow? 2 how big is that number? 200 million write the ": [
      834.0,
      875.4,
      20
    ],
    "the first week. Okay. So if W is large we might spend more time for pastors and try to find a better path which path gives us the most Improvement the max bandwidth. Okay, so Now we're doing a little bit more per iteration. But we're gaining much more in the improvements. And so you can show that each iteration gets at at least a one ovary fraction of the ": [
      907.9,
      943.4,
      22
    ],
    "the optimization version in polynomial time. If I could solve the traveling salesman decision problem in Big O and K time then I could use that to solve the search Problem. The dip let's call it optimization problem. the optimization traveling salesman problem Okay. I want you guys to take a few minutes and come up with a way to do it. Okay, ready go. So you have you have ": [
      2501.0,
      2536.7,
      62
    ],
    "the verifier is really easy because we know how to multiply numbers quickly. So the verifier will be our of you give the instance and a solution. Right and this is going to be equal to true if x y is equal to end and false if x y is not equal to end. So kind of just verifies if those two numbers can multiply together to give you in ": [
      1907.7,
      1937.7,
      46
    ],
    "their full capacity. Therefore cut is the total capacity of all such edges than the flow is actually equal to that cut. You're sort of the achieved the bound type proof for any Cut St. With S and S and T and T in any flow f flow f is always less than or equal to that cut. Kind of talked about that already. Because all flows must have to ": [
      544.0,
      576.7,
      11
    ],
    "these vertices. the constraint Is that v-0 up to v-0 must? pass through every vertex and the objective is the minimize. length of length of what do you call it path? Okay, so traveling salesman problem. This problem is optimization problem. We don't know. If this is nnp. Right and let's think about the the reasons why if I gave you a graph and gave you a path. How would ": [
      2348.8,
      2406.9,
      58
    ],
    "to get there have to be at most WV in the very worst case where you keep on improving it by one time. Okay, so here is the algorithm. You have your grass your Ed Koss your starting and ending vertex. Repeat until there's no path find a path make the residual graph and repeat find another path and keep on going. Until you can't get a patent. There's no ": [
      696.5,
      726.8,
      16
    ],
    "to one X and Y are not equal to end and the objective. is just to decide if a solution exist What's the best way to do it? I guess this is not a decision problem. You actually want to know what those things are, right. Might be so objective is to just return. the two integers Okay, so why is this in why is this problem in NP because ": [
      1855.9,
      1907.7,
      45
    ],
    "two sets of vertices and the edges only go between the vertices they don't go within the set. And so what I want to know is is there a perfect bipartite matching that means that is there an edge that goes from a Vertex each vertex on Wednesday to each vertex on the other where each each pair is matched. Think about like maybe one side of the vertices are ": [
      1002.8,
      1033.5,
      25
    ],
    "version Now you have a graph. Starting vertex v0 and a budget bee and now the question is can I find a path that? is less than this budget be this is a problem is in NP. Why is it in mp? Is it easy to verify? Yes, right. You give me a graph a budget and a path and a vertex. And then also give me a path. How ": [
      2432.2,
      2470.8,
      60
    ],
    "would the max glow be? 4 right Because you're only allowed to send one on on each one of these edges from s. And you're only allowed to accept one on each one of these edges from T. So in order to get the maximum full potential you would need to kind of push for. From the from one side to the other. Crenshaw sort of an easy easy reduction ": [
      1193.9,
      1232.8,
      29
    ],
    "you have this magical algorithm that can solve traveling salesman in polynomial time build an algorithm that can solve the optimization version also in polynomial time. What's up? Yeah, I have to go through every vertex exactly once. Yeah. Decision problem is in NP. We don't know if the traveling salesman problem is p okay. So now I'm saying under the assumption that traveling salesman is P show that the ": [
      2536.7,
      2619.3,
      63
    ],
    "you know that that path is the best? And how would you know that path is the optimal path is really hard to do, right? You have to kind of go through all the pads and make sure that it's it's better than everything else. So what we can do is we can change this problem into a decision version and turn it into an NP problem. Okay, so decision ": [
      2406.9,
      2432.2,
      59
    ]
  },
  "Class Name": "cse101",
  "Date": "03112019",
  "Full Transcript": "Listen to a podcast.  Okay, let's get started.  so  last week of classes a lot of things going on. There's a homework due tomorrow night. I'm having a few extra office hours tomorrow morning from 9 to 11.  Extra office hours will start my office. Maybe I'm going to need a bigger room.  Any questions about the homework?  Okay.  I guess.  Yeah, let's talk about the final. It's on Saturday. I think I think your class will be in this room.  so the final  will be in this room from what was it 3 to 6.  P.m. And then the other class.  Is in Warren lecture hall.  2001 next door, I guess there's some practice problems for y'all. I'll put some solutions. We're going to have a review session on Thursday.  review Thursday  any other questions about that?  Okay.  Yeah.  Yeah, that's kind of like the whole point of the problem or else you'll just give one sheet to the to the highest paying Craftsman.  Let me see if I can.  scishow  yeah, let's say that this was my  sheet of silk  and let's say a Craftsman wants like that portion. Then you can like let's say you cut horizontally first so you cut horizontally and cut that off, right?  so now you have like  this part  and this part right and then you cut vertically.  And now you have these two parts.  And you're saying can I can you use those these two leftover things?  Yeah, for sure, but then you'd sell this portion to whatever Craftsman wants it and then you can cut those in the same manner to give to the rest of the Craftsman if you like or you can cut it vertically first and then or something.  Any other questions?  You can sell it to the same Craftsman as much as you want. Just imagine that they have an  A victim and is always enough that they'll Always by as much as possible.  Any other questions?  And I gave did you guys all see the hint?  I gave you the  what the subproblem should be.  I am of where do I call it? X y j.  Is Max profit?  from  X by y sheet  considering  Craftsman  one through J. I'm hoping that gives you kind of a head start on aisle where to go from there specially with the cuts and stuff.  Don't be a three-dimensional array.  Okay any other questions?  Okay, so let some finish up with this network flow problem and then we'll start talking about peeing in pee.  Okay, so we went through this.  This algorithm the Ford Fulkerson algorithm. You basically find a path. You send a flow down the path. That's based on the the lightest Edge in the path. And then you make the residual graph right by  Reversing all the edges and you just keep on going until you have reached a point where you can't reach from s-2t anymore.  So  Basically, what we've done is we've created a cut which is a separation of the vertices into two groups. Okay in the cut that we made is this  Okay, and oh shoot, let me do something real fast.  I want the original graph.  copy  Okay. So this is this is the residual graph. This is when we got stuck right because there's no edges going into tea. What if we take to our original graph and use that same cut.  Right, then what I claim? Is that the flow along a cut right which is going to be the the number of the the sum of all the edges that cross over the cut.  I'm saying that the actual Max flow can never be greater than that cut.  That kind of makes sense cuz you're going to have to get from from one side to the other anyway, and so you're going to have to in this case send 5 units from the left subset to the right subset and that'll be true for any cut. Where you separate S&T, right?  So this is sort of like an achieved the bound tight proof. We're going to say that the max flow is never greater than any cut. But then when you do the Ford Fulkerson method you are basically showing that the flood the max flow is equal to some cut and since it has to be less than or equal to all Cuts. Then that has to be the maximum for the idea. So you let the cut be the unreachable vertices night, then all the edges that cross over the cut are being used to their full capacity.  Therefore cut is the total capacity of all such edges than the flow is actually equal to that cut.  You're sort of the achieved the bound type proof for any Cut St. With S and S and T and T in any flow f flow f is always less than or equal to that cut.  Kind of talked about that already.  Because all flows must have to pass through some Edge in the cut. Now when the full Ferguson algorithm terminates its flow is equal to some cut that cut that we did right there for  All flows have to be less than or equal to that cut and we went we showed that that cut is actually equal to the flow that we got which means that Festa maximum that the flow could be.  Okay, so I don't know if we really talked about this so much last time but let's think about why this method will or will not terminate now in my example. We had a bunch of integer value things, right? And so the minimum amount that you could  You could change would be buy one, right? Cuz one of the smallest integer and so  if you have  Flo's or Edge Edge weights that are not integer valued then you can see that you could decrease it by smaller and smaller values and it could lead to some sort of  infinite time algorithm. So let's just stick with integer values for edgeways.  So basically if the capacities are integers from 1 to W, let's say w is the heaviest one among all the edges we maintain that the invariant that the flow has integer value. So the residual capacities are integers in any Improvement that you make has to be by at least 1 so if we have integer values, we know that it will always terminate because we're going to at least improve it by one each time and eventually that'll go down to zero.  Okay, stop the total flow can be no more than WV and so the number of steps to get there have to be at most WV in the very worst case where you keep on improving it by one time.  Okay, so here is the algorithm.  You have your grass your Ed Koss your starting and ending vertex.  Repeat until there's no path find a path make the residual graph and repeat find another path and keep on going.  Until you can't get a patent. There's no path from s to T.  And I guess along the way keep on adding the the bandits of those pads to get the maximum flow.  So like we said before there's that most WV iterations each iteration takes big O of e time because we're just basically doing a DFS the linear time thing.  And so the total time is Big O of wve.  Okay, so this is all well and good. Let's talk a little bit about how to improve this.  Because something like this could happen.  where  You have like a bunch of really heavy edges and then one in the middle that is light. So what if I was really unlucky and the first path that I got from DFS was this past year?  Then when I make the residual graph.  Basically, I send only one unit back from each one of those edges. So I got something like this. Where is it?  And this is going wait. What was this one going? This was going opposite or now. It's going down.  And this is going this way, but I have one going back like that.  Frank and then what if I was unlucky again and the next PATH I chose was  this one  you could see that you could keep on getting very unlucky and taking away one every time.  Okay, so that's bad because that's really inefficient. Is there a is there a better path to start with?  Rather than going through that one.  I mean you guys can just look at this and and maybe have an idea of what is the maximum flow?  2 how big is that number?  200 million write the max flow is 200 million.  And you can get there a lot faster if the first path you picked was this path?  Right in the second packet pick was the bottom path. They so it actually makes it a lot more efficient. If you can find the path with the max bandwidth, do we know how to do that?  Yeah, right. We did that the first day or the first the first week.  Okay. So if W is large we might spend more time for pastors and try to find a better path which path gives us the most Improvement the max bandwidth.  Okay, so  Now we're doing a little bit more per iteration. But we're gaining much more in the improvements. And so you can show that each iteration gets at at least a one ovary fraction of the remaining possible flow. And so the total number of iterations is at most  HELOC w a v and so the total time because you have to do this at least e x is this kind of big messy thing, which I'm not going to go into the full detail. I just kind of want to share with you that this is a better way to go because you're getting more improvements. You're not you're not getting unlucky and going down this path of flow one each time.  Okay, let's see. Let's look at a problem that you can solve using this idea. It's called perfect bipartite matching and graph matching in general is a common problem that you might see come up and this is a special example. We were talking about bipartite graphs.  Okay. So a bipartite graph has two sets of vertices and the edges only go between the vertices they don't go within the set.  And so what I want to know is is there a perfect bipartite matching that means that is there an edge that goes from a Vertex each vertex on Wednesday to each vertex on the other where each each pair is matched. Think about like maybe  one side of the vertices are  I don't know boys, and the other side is girls and there's an edge between a boy and a girl if they like each other and then what you want to do is maybe match them all up in such a way that everybody gets a match. Is that possible or not? So think about maybe something like this?  Does this have a perfect matching?  You want me to go back to the definition of perfect matching?  anybody  this one  Okay.  that one  this one has to go there and this one goes there.  Okay, great many questions about that.  perfect matching  was that  what's the marriage Lima?  Oh, okay.  Okay. So how do I solve this problem using network flow?  Okay, we're going to do is Well Network flow. You need a starting vertex in attending vertex right as in t so we're going to do is just create those and put one on the left side and one on the right side.  right  something like this.  Okay, then if I give all the edges capacity one  And all of those inside capacity one.  What would what would be true about the max flow if there was a perfect matching like if there was a perfect matching here, what would the max glow be?  4 right  Because you're only allowed to send one on on each one of these edges from s.  And you're only allowed to accept one on each one of these edges from T. So in order to get the maximum full potential you would need to kind of push for.  From the from one side to the other.  Crenshaw  sort of an easy easy reduction  basically true. Okay. So this matching problem in general is a lot more complicated, but you can see how you can solve it really fast using this idea any questions before we move on.  Okay, let's start with the p versus NP.  kind of like to end with this because  This class what we've seen mostly are our problems in p and I'll share with you a joke from Russell another instructor. He said that if p is equal to NP, then this class instead of being called design. What is it called design and Analysis of algorithms instead. It would be called design and Analysis of algorithm.  You guys got it kind of.  The reason is because if p is equal to NP, then all of these problems that we've seen which we're going to kind of classify these decision problems can all kind of be reduced to each other. And so if you can solve one of them efficiently you can solve another one efficiently and will go into kind of what I mean by those relationships.  Okay, let's start with optimization problems. We've seen this many times before right you have your instant solution format constraints and objective function. You're basically looking searching through the space of solutions trying to find the best one, right?  So  for what? What are some optimization problems we've seen? Okay. Let's say what shortest path.  Max bandwidth  Anybody else?  What is all events scheduling?  scooters  Has anybody used that algorithm yet?  in practice  no.  What else all those DP problems knapsack?  silk Merchant  Sudoku  Sudoku is like it's not going to be optimization because  we're not trying to find the best solution. We're just trying to find a solution.  But most of the problems we've done in this class have been optimization problems good.  Yeah, here's some other ones. Okay decision problems. Now, this is like a Sudoku type thing where you have your instant solution for Matt and constraints and now you don't have an objective function. Your objective is just basically to find if a solution matches the constraints if if the input  Is there a solution to the input that meets the constraints yes or no, true or false? What are some decision problems that we've seen? I'll put Sudoku up there.  happy path  right doesn't exist or not write a lot of the graph problems Racine right? Like the what was the other one? That was weird the alternating?  Do we do like the blue and red coloring 01101 alternating path?  Okay is graph.  bipartite  What was the other one week? That is the sad part of a cycle, right?  Okay, so there's a ton of them. Right? But just all of these ones are decision problems, which means that they give a yes or no answer about the problem. Okay. Is there an Arbitrage right does a bipartite graph have a perfect matching?  Okay. So how hard are these problems?  and  I guess we're using hard. We're going to kind of give him more of a formal definition of what heart is because are we thinking I don't know if you guys kind of classify the problems as hard if they're hard to like come up with an algorithm to solve them. We're not talking about that. It's more of a  How how efficient is the most efficient algorithm that solves it? That's how we're kind of going to classify in terms of hardness.  Okay, so we have a number of approaches that give Fast algorithms for a wide variety of search optimization decision problems.  Some of them though it kind of defeat our standard algorithm look methods if you guys know of  No.  This p and NP problem. You know that factoring is hard. This is what most of our credit cards and encryption a lot of Internet Security is based on the fact that right now nobody has an efficient algorithm for factoring large numbers.  Factoring is definitely NP. Yeah, we're going to I'll give you a definition of NP in a minute and we can we can revisit factoring.  Independent set we talked about this when we started talking about backtracking. I didn't really we never came up with a polynomial time algorithm. Remember we kept on getting a more and more efficient algorithm, but they're all still exponential time hamiltonian path or happy path.  In dags, you've you all have seen that it's possible to do it efficiently, but in general finding hamiltonian passes.  There's no known efficient algorithm for it.  So the question about p and NP is are all reasonable search and optimization problems easy. If not, what makes some of them hard and can we classify them? And how do we measure that classification?  Okay, so this is what MP is.  It's the class or set of all decision problems where there's an efficient verifier are what is our well our takes the input and the solution.  And it tells you if the solution is a solution to the input. It gives just gives you a yes or no answer. So let's let's pause for just a second so that we can address factoring because it is it will see that factoring is a  Factoring is NP.  Okay factoring.  What is the instance?  some  number right and let's say let's say that it's in bits.  Right because I actually want my algorithms efficiency to be dependent on the bits of the number because that's like the the amount of information that you used to store it.  Okay, what about the solution format?  Maybe the prime factorization kind of depends on what you're trying to do. Are you just trying to factor it once or you trying to factor it more than once? Let's say it.  Let's say it's 2.  integers  What's a X and Y.  Such that.  X and Y are not equal to one or I guess what's call this number and phone number and  X and Y are not equal to one or n.  And XY is equal to end so some non-trivial factorization.  Okay constraint.  Or maybe that's the constraint. Let's do it that way.  two integers x and y k constraint  is that X Y is equal to N X and Y are not equal to one X and Y are not equal to end and the objective.  is just to decide if  a solution  exist  What's the best way to do it?  I guess this is not a decision problem. You actually want to know what those things are, right.  Might be so objective is to just return.  the two integers  Okay, so why is this in why is this problem in NP because the verifier is really easy because we know how to multiply numbers quickly. So the verifier will be our of you give the instance and a solution.  Right and this is going to be equal to true if x y is equal to end and false if x y is not equal to end. So kind of just verifies if those two numbers can multiply together to give you in and you can do that in polynomial time with respect to the number of bits.  array of prime numbers  Does that mean that you can still check that because multiplying a bunch of prime numbers together is still polynomial time?  Oh.  yeah, I suppose that would be harder to do that at all. Would all depend on if the  if the  if saying a number is prime is efficient, but noticed that.  What happened here noticed that if you could do this you could do you could you could factorize all of them into the prime factorization. If you can do this efficiently, then you just do this over and over and over again until you're done until you get the Primes.  Because you do this again and the end it doesn't give you two integers, right?  Okay, so where is that? That's what NP is? Okay, and this is something that I want you guys to remember. This is going to be one of the true false questions going to be about NP.  I'm going to talk about what kind of problems are in in pee and so the only thing that you know about problems in NP is that there is a polynomial time verifier. Okay doesn't talk about how efficient the algorithms are that solve them. It says nothing about that at all. All it says is that there's a polynomial time verifier?  Okay.  So if you want to start talking about efficiency, there's another class called P. This is the class of all decision problems that that have a known polynomial time solution that have a polynomial time solution. Let's say  Okay, so what are some examples of problems in p?  right path  in graphs  right  What are some other decision problems we talked about?  is there  a perfect  matching  and bipartite graphs  and so on right mainly all the decision problems we see in this class or mostly all of them have all been problems in p  questions about that  Okay good.  P vs. NP so this is the big question.  We don't know if p is equal to NP. What would that mean? What's the consequence of that?  so  this is the I guess I should write this P equals NP means.  this thing  any problem that can be solved in polynomial time can also run away. Sorry. I was thinking about the other slide.  This is as big as a true statement.  Any decision problem that can be solved in polynomial time can also be verified in polynomial time.  And soapy is a subset of NP.  Now this is the statement of p is equal to NP.  Every decision problem that can be verified can also be solved so it's kind of like the converse so we know that this top statement is true is the converse always true. We actually don't know nobody knows.  Any questions about that?  So for finding a path the verifier would take a graph.  And a sequence of edges and tell you this sequence of edges is a path.  But actually finding that sequence of edges kind of involves more more work, right and it's kind of the idea.  like for example a solution to a Sudoku problem is really easy to verify right you just go through and make sure all the ones and nines are all in place, but actually  Generating that solution that takes more work, right? So that's that's the sort of difference between these two ideas. Is it easy to verify is it easy to solve and P equals NP if that's true. That means that that would be true if it's easy to verify then it's actually easy to stall.  Okay, so let's take a take a look at the traveling salesman problem.  the optimization version  so  we're giving a complete graph of an vertice or I guess I have and plus one vertices here. Okay.  Positive Edge weights would you can think of as like distances between the vertices you want to know? What's the cheapest route that you can take from the starting of v-0 and visiting every single other node and coming back to the zero?  Okay, so  The instance here is a graph.  with positive  Edge weights  and starting node v-0. The solution for Matt is going to be a sequence.  vertices  v-0 up to V 0 right starting at V 0 and ending at V 0.  And this kind of gives you a sense of how big that solution space is, right? Because there's going to be n factorial many different ways that you could arrange these vertices.  the constraint  Is that v-0 up to v-0 must?  pass  through  every vertex  and the objective is the minimize.  length of length of  what do you call it path?  Okay, so  traveling salesman problem. This problem is optimization problem. We don't know.  If this is nnp.  Right and let's think about the the reasons why if I gave you a graph and gave you a path.  How would you know that that path is the best?  And how would you know that path is the optimal path is really hard to do, right? You have to kind of go through all the pads and make sure that it's it's better than everything else. So what we can do is we can change this problem into a decision version and turn it into an NP problem. Okay, so decision version  Now you have a graph.  Starting vertex v0 and a budget bee and now the question is can I find a path that?  is less than this budget be  this is a problem is in NP. Why is it in mp?  Is it easy to verify?  Yes, right.  You give me a graph a budget and a path and a vertex. And then also give me a path. How do I know that that path reaches that bus budget? Well, you just add up all the edge and if the edges are less than b then it's done. So this problem is in p  in achieving in NP. Sorry.  Okay, so why are these why are these so related? Well, it turns out that if I can solve the this decision version in polynomial time, then I can solve the optimization version in polynomial time.  If I could solve the traveling salesman decision problem in Big O and K time then I could use that to solve the search Problem.  The dip let's call it optimization problem.  the optimization traveling salesman problem  Okay. I want you guys to take a few minutes and come up with a way to do it. Okay, ready go.  So you have you have you have this magical algorithm that can solve traveling salesman in polynomial time build an algorithm that can solve the optimization version also in polynomial time.  What's up?  Yeah, I have to go through every vertex exactly once.  Yeah.  Decision problem is in NP. We don't know if the traveling salesman problem is p  okay. So now I'm saying under the assumption that traveling salesman is P show that the optimization problem will also be in pee.  Exactly. Is it this is it this is a complete graph to so there's an edge between every pair notes.  Does anybody have any ideas on how to do this?  Okay, good. So start be low.  And run the decision traveling salesman problem over and over.  increasing  B every time  until  I guess until you find a  until until you  right until you can beat the budget, right?  until you can  What do you call that?  You can find.  a path  within the budget  Okay, good. So is there a is there a like maybe a more efficient way to use the same sort of strategy, but use fewer calls to the decision problem.  Yeah.  do a kind of  binary search  where to start  so yeah, so there's a few ways you can do this. One of them is a question.  Yeah, you can start with at some random path right that random path can't be lower than the than the than the minimum right? So  start at some random path and then maybe make the budget halfway between that value and 0 right and if it's over then kind of move the budget up if it's lower than move the budget down and kind of work your way into the  I want to share this with you because p and NP depending on whether they're equal or not has a lot of consequences on whether or not problems are even in and pee or not. Right? We we don't know if the optimization problem is in NP it all depends on if p is equal to NP.  Okay, so Wednesday will do a little bit more with this talk more about what is NP complete and that will pretty much be the rest of the new content.  What I meant was like.  Factoring I'd heard it was very officially doable with quantum computers. Which but some in an empty Browns are not easily.  Turn lights on.  Yeah, so factoring is not np-complete.  And so  but it is not pee not is not known to BP either but kind of like in this weird gray area where we don't know where it goes and maybe maybe I don't know so much about Quantum Computing in the classification, so I don't know exactly but  Yeah Lil B ",
  "Section": "a00",
  "Time": "1500",
  "Audio URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-03112019-1500.mp3",
  "File Name": "lecture_26.flac"
}