{
  "Blurbs": {
    "* 8 of T2 + 1 is less than equal to end of T2. does it that the inductive hypothesis and so Whichever one is bigger and one or and to both of these things have to be less than that. I have you. Has to be less than the max in of T1, and up to 2. Any other questions? Okay, so Okay, so I just want to give ": [
      1746.9,
      1835.0,
      32
    ],
    "1 0 relates to 0 0 0 does not relate to once you know, what else do you have zero zero zero relates to 110 something like that. Because 0 0 0, 1 0 0 is in Arctic. Okay. So those are a few examples. Here's one more example where the relations not like a nice little rule. It's actually just a set of ordered pairs. Okay. So this is ": [
      2169.2,
      2210.3,
      42
    ],
    "First Column is bigger. But one is not bigger than 2. Mustang less than or equal to Okay, and we're so this one is actually X is less than or equal to Y. This is the relation. X relates to y means that X is less rain. Okay, you can also talk about students and Majors, right? And so you can you can have a student has more than one ": [
      2018.5,
      2063.0,
      38
    ],
    "Got any questions about that? Because it doesn't have the number one. It just needs to follow this this rule, right? So it's just an implication. So if the the hypothesis of the implication is false, then it doesn't matter if we have a pair where a relief to B&B relates to see we have to have the other one. Okay, good. So So let's define what it means to ": [
      2653.9,
      2700.4,
      53
    ],
    "Into collections of disjoint nonempty subset that have asses their Union. So there's two kind of ways that you can think about equivalence relations. And if we if you if you can show a relation is a equivalence relation then automatically you get this partition. so let's look at some more notation that we're going to use is that if equivalence relation, then this sort of brackets of our is ": [
      2734.5,
      2768.8,
      55
    ],
    "It is really useful when you're trying to make and I and ideal hash function. It's an extremely important in security. Most of our computer security is based on modular arithmetic. So it's a very important topic in computer science. So let's get started with trees. I'm going to quickly go through these definitions that we covered last time. Okay, so we have a graph now. This is not like ": [
      103.3,
      140.4,
      3
    ],
    "Now we're now we're saying R1 and R2 good to an R3. All I want is not reflective right one relates to two. but two I say it like this one relates to but two does not relate to one. Okay, but everything that has the same number of symbols as the other one will have the same number of symbols. Right? So it's kind of like back and forth ": [
      2522.9,
      2550.9,
      50
    ],
    "Okay. Good morning. Welcome back everyone from from break. Hope everybody had a nice relaxing time. Now, you're ready. You're awake and ready to learn. I didn't prepare a like a learning goals today, but maybe we can just kind of talk through them. so we're going to do some some things with trees because we kind of that's what we left off on and we didn't really finish it ": [
      1.9,
      42.3,
      0
    ],
    "These are the three requirements relations that we talked about. Rank the set of all ordered pairs where X is less than y the set of all pairs of fit strings where the two strings have the same length and the pair the set of all, I guess instead of these three relations which of these relations Is reflexive. Okay, we're looking at C&D here. They're pretty even. You guys ": [
      2357.3,
      2426.2,
      47
    ],
    "This thing here aren't buying or inductive hypothesis. This is less than or equal to. well I kind of pens write 51 is bigger than 51 has a bigger height than T to write then this is going to be I guess it depends on who has the most. vertices but we can say for sure that this is less than or equal to. the max and of T1, and ": [
      1269.3,
      1312.7,
      26
    ],
    "a XY coordinate graph. This is a discrete math object called a graph. It's a collection of vertices and edges where each Edge connects two vertices. Poetry is a graph that just doesn't have any Cycles. There's no there's no loops. There's exactly one path between any two vertices. Okay rooted trees. This is a special type of tree where one vertex is designated as as the root and all ": [
      140.4,
      177.0,
      4
    ],
    "a is equal to the equivalence class of be. He relates to be sorry and also their equivalent classes are. non empty right through the intersection song is a few more minutes here. Okay song. Let's look at this example that we had about the length of strings peso to string two bit strings relate to each other if they have the same number of symbols. This turns out to ": [
      2802.3,
      2848.5,
      57
    ],
    "about our two? R2 is reflected. Right every string has the same number of characters as itself. So, it's good. How about our three? Right because two does not relate to two. Every element has to relate to itself in order for the whole relation to be reflexive. Okay good. what about Symmetric which one of these is symmetric. If a relates to be then be released today. Okay, good. ": [
      2465.5,
      2522.9,
      49
    ],
    "and this one's actually reflects it because you can just kind of go through every single element and see if it works. Okay, if zero or relates to zero than zero relates to zero good if she relates to to relate to zero that's good and if two released a zero than zero released into but they're all there. Okay good. Okay. how about transitivity which one of these is ": [
      2550.9,
      2586.8,
      51
    ],
    "ap2 Brent and now What do I want to do from here? Where am I notes? Okay, where's my panda? 1 to 2 sequel to that What did I do wrong here? T1 T2 so I guess we can. We can do it by cases here. If we assume that. Yeah, let's do it. That way. Here we go. This is certainly less than or equal to 2 times the ": [
      1312.7,
      1511.3,
      27
    ],
    "are we going to do is? Start to finding some functions on trees. And so the first function we're going to do is the height function. The height function is a function that Maps the set of all rooted trees to the integers. Okay, basically it associate a number with the tree this number we're going to call the height is the maximum distance from a route from the route ": [
      358.6,
      388.4,
      10
    ],
    "basis step. Is a child of the solitary node, what's going to be the height of just a solitary note? 0 write the total number of edges or skinny the maximum length from the route to any other vertex is zero because there's there's really no other vertex to get to okay recursive step. so the height of T1 dotted with T2 is equal to what? Let's look at kind ": [
      485.0,
      539.8,
      13
    ],
    "be an equivalence relation in two ways. One is that it's a relation that has these three properties. We just talked about reflexive symmetric and transitive and then a consequence or a another definition of an equivalence relation is you can partition a set into equivalence classes Each of which consists of similar elements. And what about what do I mean by similar? It depends on what the relation is. ": [
      2700.4,
      2733.2,
      54
    ],
    "be an equivalent class. And if you remember on a on those three quick or questions, it was it was reflexive. It was symmetric and it was transitive. Therefore. It is an equivalence relation. So once we have an equivalence relation, how does it partition are sets and partitions the sets into groups of strings that all have the same length. These are all called equivalence classes. Okay, so What ": [
      2848.5,
      2877.5,
      58
    ],
    "be how we denote equivalence classes Okay, so maybe we can stop there and pick up on this on Wednesday. ": [
      2906.0,
      2918.2,
      60
    ],
    "binary tree's empty is always going to be greater than equal to 2 times the age of tea + 1 Do you guys believe this? I'll prove it to you. Right here are my recursive functions h&n. What's my basic structural induction? What's my basis step? And of diamond is equal to what? one, right How many vertices does the single rooted tree have only one? What's 2 * 8 ": [
      818.1,
      878.6,
      19
    ],
    "does not relate to one. Because one, two is in this set. All right. Here's another example of a relation where the set I'm talking about now is the set of all binary strings and one string relates to another if they have the same length. So it's the set of all ordered pairs W, you such that the length of w is equal to the length of you. So ": [
      2131.7,
      2169.2,
      41
    ],
    "equal to. Nrt to. Okay, so this is less than or equal to end of T1. 9 + 1 + 1 and one has to be less than or equal to end of T2 and T1 plus and of T2 plus one. So this is got to be This is equal to n of T1 T2. Okay. Sorry about the the delay But maybe you can kind of see where ": [
      1588.0,
      1637.9,
      29
    ],
    "finish this as an exercise. Spanish exercise Okay. So what we're going to do is start with this side. And show that it is less than or equal to n of T1. T2 the other way around. Okay. So this is equal to 2 times. What is age of T1 T2? It's the max. T1. Jimmy, T2 Dark Age of t122 plus one now let's let's do a little bit ": [
      1105.4,
      1194.0,
      24
    ],
    "function is a function from trees two integers so you can turn to an integer add the integers together and then add one for the vertex. That's that's this. Operation Operation, will you take the two trees and then you connect their roots to another route. Okay questions. so now let's use these functions use the structural the recursive structure of the trees to prove this claim. for all full ": [
      768.1,
      818.1,
      18
    ],
    "have the property. This is the only way to build trees for this is kind of the inductive thing, right this is going to Imply that this this claim is true for all trees. Okay. So let's start with the with the left hand side. Right. I'm going to try to prove this thing here. So let's start with the left hand side and of T1 T2. Okay. Now anybody ": [
      1010.2,
      1040.2,
      22
    ],
    "height of this case 52 is bigger. You have the height of T2, but you have one more Edge cuz you have a new route node. Any other questions? Okay, is that a question up there? No. This is just the finding the height function function. Okay, let's let's try to find another function. This is going to be called and of tea. Okay, and if he counts the number ": [
      601.7,
      653.6,
      15
    ],
    "here that this is why it's different than a function. You see how one relates to several different elements K one relates to one and one relates the two and one relates to four and one release date night so you can do it like that to relate to to to relates to for 2 release date and so on. Anybody see a pattern in this relation? Or wait the ": [
      1981.1,
      2018.5,
      37
    ],
    "if you describe your function based on that recursion, it makes it a lot easier to write out. Daiso You just plug this in. Okay. So, how is it? How is it defined a solitary node. This is where Chris is Step. Okay. So how we going to define it? Oh, wait, did I just screw it up? Okay, good. Okay, so I must have find it like this the ": [
      440.9,
      485.0,
      12
    ],
    "internal nodes, so The book that's just what a leaf and a internal node is okay. Let's move on to Binary relations. Okay. So what are some binary relations? It's a lot like a function except for now. We don't have to. We don't have to have this well-defined thing where each. Element of the domain domain maps to a unique element in the codomain. Okay, instead we can kind ": [
      1900.2,
      1947.3,
      35
    ],
    "is the equivalence class containing just the string 0? All strings that have the same size as just that strength. So it's just 0 and 1 right? It's all strings of length 1 what's the equivalent class of the string containing 00? It's going to be all strings that have exactly two symbols 0 0 0 1 1 0 1 1 and so on. okay, so this is going to ": [
      2877.5,
      2906.0,
      59
    ],
    "like a it's a graph. And so it's good for you to be introduced to that too. So then the next thing we're going to do our relations. and relations you'll see what they are willing to find them and everything and that's that's going to lead us to modular arithmetic And this is like one of the last topics that we're going to do why is modular arithmetic important? ": [
      71.7,
      103.3,
      2
    ],
    "major. So it's a relation now. It's not a function anymore. If each student only had one major then it will be a function but now since since y'all has. Two majors economics and computer science, you know ya relates to economics and our relation computer science and and so on. So now let's go to sort of the formal definition. So let a be some set a binary relation ": [
      2063.0,
      2095.5,
      39
    ],
    "max of an of T1, and of T2. There we go. Plus 2 how do I get rid of that too there? If FT ones bigger than T2. then we get this it I guess this is got to be. Okay. Wait. No, not that. Here we go. This is going to be less than or equal to. Let's say without loss of generality that 51 is greater than or ": [
      1511.3,
      1588.0,
      28
    ],
    "mean to be symmetric? It means that if a relay stavi than be released. Okay, so you have the sort of symmetry and transitivity means that you could kind of imply that if a relates to B & B relates to see then you know that a relates to see. Okay, so we need all three of these properties in order to be an equivalence relation. Let's do some exercises. ": [
      2328.4,
      2355.7,
      46
    ],
    "means to Partition. So in order to show that a relation is an equivalence relation. We need to have these three properties reflexivity symmetric symmetry. Isn't is there like a noun version? symmetric cavity symmetry thank-you transitivity up here. Okay. What does it mean to be symmetric means that everything relates to itself in your set. Okay for all a and your set a release today? Okay. What does it ": [
      2278.4,
      2328.4,
      45
    ],
    "nodes coming down from it. Right? It's the nose that it branches out towards if a leaf is a note with no children and an internal note. Is any know that is not a leaf peso in one of your homework problems. We ask you to do a structural inductive induction proof about leaves. so we talked about functions of tea and I of tea that count the leaves and ": [
      1871.1,
      1900.2,
      34
    ],
    "of cleaning up here. This is going to be the max of H of T1. , age of T2 + 1 + what's the best way to do this? All right, let's do it this way. 2 * the max age of T1, age of T2 + 2 + 1 write. Okay good. now let's use our inductive hypothesis. Let's write it like this + 1 + 2. Okay, so ": [
      1194.0,
      1264.7,
      25
    ],
    "of have that element relate to more than one element. Okay, and that's why it's called a relation. Okay, so dispersed example over here the power set relates to the power set. This is just a very simple relationship where each set just relates to itself. Okay. So the empty set release the empty set set a relates to set a and so on. Here's another relation. Okay, and notice ": [
      1947.3,
      1981.1,
      36
    ],
    "of nodes in the tree node is just a synonym for vertex, okay? node equals vertex Okay. in the basis step What is an of the single vertex? Okay, perfect. Good. It should be one right because the the tree would one vertex has one vertex good. questions about that Okay, so then the recursive step. End of T1 T2 how many vertices does this have? guys are think about ": [
      653.6,
      715.1,
      16
    ],
    "of sort of a simple simplified picture. So let's 81 is a short tree and T2 is a big tree, right? And then you put them together right really what I want. Is this height, right? Stop you take the maximum of the to the heights of the two trees and then you add one. Any questions about that? Because of this this ad right here. How to get the ": [
      539.8,
      601.7,
      14
    ],
    "of t plus 1 remember what age of thr Diamond age of diamond is? What is equal to 1? Okay, so the basis step holds greater than equal to 2 h of this. Got any questions about that? Okay now inductive step. suppose that for trees T1 and T2 that the claim holds let's just say the claim holds. I just don't have to write it but we're going to ": [
      878.6,
      960.5,
      20
    ],
    "off and The reason that we're going through trees mainly is to give you another example of structural induction. So you have more of a sense and this is going to be a type of object. It's a little bit different than what we've seen before rant. Usually we've seen functions sets integers right numbers. this is more of kind of like a A different type of object right? It's ": [
      42.3,
      71.7,
      1
    ],
    "on a is any subset of a cross a okay. So how do you visualize this this thing? Let's do an example If a is the set of all integers and I make the relation r 1 is equal to the set of all ordered pairs X Y such that X is less than y okay. So this is how we say it one relates. 2 2 okay, but two ": [
      2095.5,
      2131.7,
      40
    ],
    "one. Okay. Good see. OKC is not a full binary tree. Why is that is because this vertex only has one one branch coming out right? So when it says full binary trees that mean its vertex either has zero branches or one or two. This is still a binary tree. But it's not a full binary tree. That's going to see the difference there. All right good. So what ": [
      313.9,
      358.6,
      9
    ],
    "other vertices have pads to them from the root. They're very important in computer science as well. You'll see when you start taking data structure classes. They're good for organizing your data in such a way that it's really easy to find what you're looking for. You don't have to go through the whole list if it's structured in a tree you can you know, figure it out quickly. Okay, ": [
      177.0,
      203.2,
      5
    ],
    "prove using this recursive definition. Okay. So basic step solitary note is a full binary tree. The recursive step is if you have two binary tree's T1 and T2, you can make another binary tree by linking the roots of those two trees to another route. Guys, that's kind of like you have T1 and T2. And you can make a new tree by connecting their Roots like that. And ": [
      238.9,
      271.1,
      7
    ],
    "remember what this is equal to in terms of n? Nft 1 + + 52. Plus one. Okay good. Oh, yeah. I forgot. Let's do it the other direction. Sorry, I forgot. I did this I did this in my notes and if you do it this way. It still works. It's just a little tricky. Let's try to do it the other way and and maybe you guys can ": [
      1040.2,
      1105.4,
      23
    ],
    "say if T1 is greater than or equal to end of T2, right then. This thing has got to be less than or equal to. and of T1 I guess I guess I better way to say that would be. Try not to land a great job of this. We know that two h of T 1 + 1 is less than or equal to n of T1 and 2 ": [
      1707.8,
      1746.9,
      31
    ],
    "sets based on what the remainder is when you divide by a certain number. Okay, so I guess let's go back. Yeah, so partition of a set is when you you break it up into a bunch of subsets such that no two subsets have anything in common they so it's kind of like you're really just grouping all the elements into a bunch of different sets. That's what it ": [
      2246.1,
      2278.4,
      44
    ],
    "so binary trees. Are trees that each vertex. Can Branch out into two different directions, but two is the maximum amount of times I can Branch out we're going to look at a subset of binary tree's called. Binary tree's and the way that we're going to Define them is using a recursive definition. This is nice because any type of property we want to prove about them. We can ": [
      203.2,
      238.9,
      6
    ],
    "the is the set of all elements that are in the same equivalence class as a and what does that mean? It's the set of all elements such that a soda, as is in our Okay. So here's our theorem. If R is an equivalence relation on a set a for the elements A and B of A A relates to our this also means that the equivalence class of ": [
      2768.8,
      2802.3,
      56
    ],
    "the relation is 0000 relates to zero zero relates to and to release the zero and that's it. So what relations are really nice for our if there an equivalence relation, then they partition the set into these things called equivalence classes that are really important for a lot of different applications. Mainly what we're going to use it for is to partition all of the integers in two different ": [
      2210.3,
      2246.1,
      43
    ],
    "the tree right T1 has some vertices T2 has some vertices and then you have this route for texting like this. No, cuz it was a trick question. trick question guys trick question great. Good job guys. What is the answer? It's right. Big and little and little end of T1 plus little end of T2 + 1 think about types, right? You can't add trees together. But this in ": [
      717.6,
      768.1,
      17
    ],
    "to another for text. Caso height of tea is is maximum distance and when I say distance, I'm really talking number of edges. from route two other vertex okay, so this is kind of like the the informal definition so formally let's let's build up this function recursively. Okay, and it's nice that were able to do this because our domain which is trees are also built up recursively. So ": [
      388.4,
      440.9,
      11
    ],
    "transitive which means that if a relates to B&B relates to see than a relates to see okay some other combination. What's the other combination? R1 R2 why is R3 not transitive? Okay good. So we have that to relates to zero. and 0 relate to but we don't have that to relate to to for this to be transitive. We need we need to relate to in there also. ": [
      2586.8,
      2648.5,
      52
    ],
    "use that information, right? want to show that the claim holds for T1 T2 Okay, let's just write that. Formerly want to show that n of T1 T2. Is greater than or equal to 2H of T1 T2? plus one Okay, so if we can show that then that means that any if we assume any two trees have they have the property then when you put them together, they ": [
      960.5,
      1010.2,
      21
    ],
    "want to do a little discussion to see if we can kind of tilta? All right, so are one. Okay, so I guess we're all in agreement that are one is not reflexive right? How do you show that is not reflective? You just need one counterexample. Kr1, so one does not relate to one right cuz one is not less than one case or one is not reflexive. How ": [
      2426.2,
      2465.5,
      48
    ],
    "we usually draw trees kind of growing down which is weird because the actual Botanical tree grows up from the roots, but a lot of the times you'll see it with the root at the top and then it grows down like that. Okay, so which one of these trees is not a full binary tree? A b c d is more than one he is none there all for ": [
      271.1,
      313.9,
      8
    ],
    "where you get stuck sometimes and how to get through it. Are there any questions? I'm so We know that two times age of T 1 + 1 is less than or equal to. And maybe we should write it out on another slide here. Okay, so we have two times the max of ht1, age of T 2 + 1 okay, so this is got to be like let's ": [
      1637.9,
      1707.8,
      30
    ],
    "you guys a few more vocab or are we okay with this? kind of iFunny proof, but Made me look kind of like a dummy up here, but we'll just move forward. Okay, but we did it, you know and it's it's done. So that's good. Alright, so let's do a few more vocab words. So for any Vertex or node in a rooted tree, its children are the connected ": [
      1835.0,
      1871.1,
      33
    ]
  },
  "File Name": "Discrete Mathematics - A00 - Jones, Miles E - Fall 2018-lecture_24.flac",
  "Full Transcript": "Okay. Good morning. Welcome back everyone from from break. Hope everybody had a nice relaxing time. Now, you're ready. You're awake and ready to learn. I didn't prepare a  like a learning goals today, but maybe we can just kind of talk through them.  so  we're going to do some some things with trees because we kind of that's what we left off on and we didn't really finish it off and  The reason that we're going through trees mainly is to give you another example of structural induction. So you have more of a sense and this is going to be a type of object. It's a little bit different than what we've seen before rant. Usually we've seen functions sets integers right numbers.  this is more of kind of like a  A different type of object right? It's like a it's a graph.  And so it's good for you to be introduced to that too. So then the next thing we're going to do our relations.  and relations you'll see what they are willing to find them and everything and that's that's going to lead us to  modular  arithmetic  And this is like one of the last topics that we're going to do why is modular arithmetic important? It is really useful when you're trying to make and I and ideal hash function.  It's an extremely important in security. Most of our computer security is based on modular arithmetic. So it's a very important topic in computer science. So let's get started with trees. I'm going to quickly go through these definitions that we covered last time. Okay, so we have a graph now. This is not like a XY coordinate graph. This is a discrete math object called a graph. It's a collection of vertices and edges where each Edge connects two vertices.  Poetry is a graph that just doesn't have any Cycles. There's no there's no loops.  There's exactly one path between any two vertices. Okay rooted trees. This is a special type of tree where one vertex is designated as as the root and all other vertices have pads to them from the root.  They're very important in computer science as well. You'll see when you start taking data structure classes. They're good for organizing your data in such a way that it's really easy to find what you're looking for. You don't have to go through the whole list if it's structured in a tree you can you know, figure it out quickly.  Okay, so binary trees.  Are trees that each vertex.  Can Branch out into two different directions, but two is the maximum amount of times I can Branch out we're going to look at a subset of binary tree's called.  Binary tree's and the way that we're going to Define them is using a recursive definition. This is nice because any type of property we want to prove about them. We can prove using this recursive definition.  Okay. So basic step solitary note is a full binary tree. The recursive step is if you have two binary tree's T1 and T2, you can make another binary tree by linking the roots of those two trees to another route.  Guys, that's kind of like you have T1 and T2.  And you can make a new tree by connecting their Roots like that. And we usually draw trees kind of growing down which is weird because the actual Botanical tree grows up from the roots, but a lot of the times you'll see it with the root at the top and then it grows down like that.  Okay, so which one of these trees is not a full binary tree?  A b c d is more than one he is none there all for one.  Okay. Good see.  OKC is not a full binary tree. Why is that is because this vertex only has one one branch coming out right? So when it says full binary trees that mean its vertex either has zero branches or one or two.  This is still a binary tree.  But it's not a full binary tree.  That's going to see the difference there.  All right good. So what are we going to do is?  Start to finding some functions on trees. And so the first function we're going to do is the height function. The height function is a function that Maps the set of all rooted trees to the integers. Okay, basically it associate a number with the tree this number we're going to call the height is the maximum distance from a route from the route to another for text.  Caso height of tea is is  maximum  distance and when I say distance, I'm really talking number of edges.  from route  two other vertex  okay, so this is kind of like the  the informal  definition so formally let's let's build up this function recursively. Okay, and it's nice that were able to do this because our domain which is trees are also built up recursively.  So if you describe your function based on that recursion, it makes it a lot easier to write out.  Daiso  You just plug this in.  Okay. So, how is it? How is it defined a solitary node. This is where Chris is Step. Okay. So how we going to define it?  Oh, wait, did I just screw it up?  Okay, good. Okay, so I must have find it like this the basis step.  Is a child of the solitary node, what's going to be the height of just a solitary note?  0 write the total number of edges or skinny the maximum length from the route to any other vertex is zero because there's there's really no other vertex to get to  okay recursive step.  so the height of  T1 dotted with T2  is equal to what?  Let's look at kind of sort of a simple simplified picture. So let's 81 is a short tree and T2 is a big tree, right?  And then you put them together right really what I want. Is this height, right?  Stop you take the maximum of the to the heights of the two trees and then you add one.  Any questions about that?  Because of this this ad right here.  How to get the height of this case 52 is bigger. You have the height of T2, but you have one more Edge cuz you have a new route node.  Any other questions?  Okay, is that a question up there?  No.  This is just the finding the height function function.  Okay, let's let's try to find another function. This is going to be called and of tea. Okay, and if he counts the number of nodes in the tree node is just a synonym for vertex, okay?  node  equals vertex  Okay.  in the basis step  What is an of the single vertex?  Okay, perfect. Good. It should be one right because the the tree would one vertex has one vertex good.  questions about that  Okay, so then the recursive step.  End of T1 T2 how many vertices does this have?  guys are think about  the tree right T1 has some vertices T2 has some vertices and then you have this route for texting like this.  No, cuz it was a trick question.  trick question guys  trick question great. Good job guys. What is the answer?  It's right. Big and little and little end of T1 plus little end of T2 + 1 think about types, right? You can't add trees together.  But this in function is a function from trees two integers so you can turn to an integer add the integers together and then add one for the vertex.  That's that's this.  Operation Operation, will you take the two trees and then you connect their roots to another route.  Okay questions.  so  now  let's use these functions use the structural the recursive structure of the trees to prove this claim.  for all full binary tree's empty is always going to be greater than equal to 2 times the age of tea + 1  Do you guys believe this?  I'll prove it to you.  Right here are my recursive functions h&n.  What's my basic structural induction? What's my basis step?  And of diamond is equal to what?  one, right  How many vertices does the single rooted tree have only one?  What's 2 * 8 of t plus 1 remember what age of thr Diamond age of diamond is?  What is equal to 1?  Okay, so  the basis step holds  greater than equal to 2 h of this.  Got any questions about that?  Okay now inductive step.  suppose that for trees  T1 and T2  that  the claim holds  let's just say the claim holds.  I just don't have to write it but we're going to use that information, right?  want to show  that  the claim holds for T1 T2  Okay, let's just write that.  Formerly want to show that n of T1 T2.  Is greater than or equal to 2H of T1 T2?  plus one  Okay, so if we can show that then that means that any if we assume any two trees have they have the property then when you put them together, they have the property. This is the only way to build trees for this is kind of the inductive thing, right this is going to  Imply that this this claim is true for all trees. Okay. So let's start with the with the left hand side.  Right. I'm going to try to prove this thing here. So let's start with the left hand side and of T1 T2.  Okay. Now anybody remember what this is equal to in terms of n?  Nft 1 + + 52.  Plus one. Okay good.  Oh, yeah.  I forgot.  Let's do it the other direction.  Sorry, I forgot. I did this I did this in my notes and if you do it this way.  It still works. It's just a little tricky. Let's try to do it the other way and and maybe you guys can finish this as an exercise.  Spanish  exercise  Okay. So what we're going to do is start with this side.  And show that it is less than or equal to n of T1. T2 the other way around.  Okay. So this is equal to 2 times. What is age of T1 T2? It's the max.  T1. Jimmy, T2  Dark Age of t122  plus one  now  let's  let's do a little bit of cleaning up here.  This is going to be the max of H of T1.  ,  age of T2  + 1 +  what's the best way to do this?  All right, let's do it this way.  2 * the max  age of T1, age of T2  + 2 + 1 write. Okay good.  now  let's use our inductive hypothesis.  Let's write it like this + 1 + 2.  Okay, so  This thing here aren't buying or inductive hypothesis. This is less than or equal to.  well  I kind of pens write 51 is bigger than 51 has a bigger height than T to write then this is going to be  I guess it depends on who has the most.  vertices  but we can say for sure that this is less than or equal to.  the max  and of T1, and ap2  Brent  and  now  What do I want to do from here?  Where am I notes?  Okay, where's my panda?  1 to 2  sequel to that  What did I do wrong here?  T1 T2  so  I guess we can.  We can do it by cases here.  If we assume that.  Yeah, let's do it. That way. Here we go. This is certainly less than or equal to 2 times the max of an of T1, and of T2. There we go.  Plus  2  how do I get rid of that too there?  If FT ones bigger than T2.  then  we get  this it I guess this is got to be.  Okay. Wait. No, not that.  Here we go.  This is going to be less than or equal to.  Let's say without loss of generality that 51 is greater than or equal to. Nrt to.  Okay, so this is less than or equal to end of T1.  9 + 1 + 1  and one has to be less than or equal to end of T2 and T1 plus and of T2 plus one. So this is got to be  This is equal to n of T1 T2.  Okay. Sorry about the  the delay  But maybe you can kind of see where where you get stuck sometimes and how to get through it.  Are there any questions?  I'm so  We know that two times age of T 1 + 1 is less than or equal to.  And maybe we should write it out on another slide here.  Okay, so we have two times the max of ht1, age of T 2 + 1  okay, so this is got to be like let's say if  T1 is greater than or equal to end of T2, right then. This thing has got to be less than or equal to.  and of T1  I guess I guess I better way to say that would be.  Try not to land a great job of this.  We know that two h of T 1 + 1 is less than or equal to n of T1 and 2 * 8 of T2 + 1 is less than equal to end of T2.  does it that the inductive hypothesis and so  Whichever one is bigger and one or and to both of these things have to be less than that.  I have you.  Has to be less than the max in of T1, and up to 2.  Any other questions?  Okay, so  Okay, so I just want to give you guys a few more vocab or are we okay with this?  kind of  iFunny proof, but  Made me look kind of like a dummy up here, but we'll just move forward.  Okay, but we did it, you know and it's it's done. So that's good. Alright, so let's do a few more vocab words.  So for any Vertex or node in a rooted tree, its children are the connected nodes coming down from it. Right? It's the nose that it branches out towards if a leaf is a note with no children and an internal note. Is any know that is not a leaf peso in one of your homework problems. We ask you to do a structural inductive induction proof about leaves.  so  we talked about functions of tea and I of tea that count the leaves and internal nodes, so  The book that's just what a leaf and a internal node is okay. Let's move on to Binary relations.  Okay. So what are some binary relations?  It's a lot like a function except for now. We don't have to.  We don't have to have this well-defined thing where each.  Element of the domain domain maps to a unique element in the codomain.  Okay, instead we can kind of have that element relate to more than one element. Okay, and that's why it's called a relation.  Okay, so  dispersed example over here  the power set relates to the power set. This is just a very simple relationship where each set just relates to itself. Okay. So the empty set release the empty set set a relates to set a and so on.  Here's another relation.  Okay, and notice here that this is why it's different than a function. You see how one relates to several different elements K one relates to one and one relates the two and one relates to four and one release date night so you can do it like that to relate to to to relates to for 2 release date and so on.  Anybody see a pattern in this relation?  Or wait the First Column is bigger.  But one is not bigger than 2.  Mustang  less than or equal to  Okay, and we're so this one is actually X is less than or equal to Y. This is the relation.  X relates to y means that X is less rain.  Okay, you can also talk about students and Majors, right? And so you can you can have a student has more than one major. So it's a relation now. It's not a function anymore. If each student only had one major then it will be a function but now since since y'all has.  Two majors economics and computer science, you know ya relates to economics and our relation computer science and and so on. So now let's go to sort of the formal definition.  So let a be some set a binary relation on a is any subset of a cross a  okay. So how do you visualize this this thing?  Let's do an example  If a is the set of all integers and I make the relation r 1 is equal to the set of all ordered pairs X Y such that X is less than y okay. So this is how we say it one relates.  2 2  okay, but two does not relate to one.  Because one, two is in this set.  All right.  Here's another example of a relation where the set I'm talking about now is the set of all binary strings and one string relates to another if they have the same length.  So it's the set of all ordered pairs W, you such that the length of w is equal to the length of you. So 1 0 relates to 0 0 0 does not relate to once you know, what else do you have zero zero zero relates to  110 something like that.  Because 0 0 0, 1 0 0 is in Arctic.  Okay. So those are a few examples. Here's one more example where the relations not like a nice little rule. It's actually just a set of ordered pairs. Okay. So this is the relation is 0000 relates to zero zero relates to and to release the zero and that's it.  So what relations are really nice for our if there an equivalence relation, then they partition the set into these things called equivalence classes that are really important for a lot of different applications. Mainly what we're going to use it for is to partition all of the integers in two different sets based on what the remainder is when you divide by a certain number.  Okay, so  I guess let's go back. Yeah, so partition of a set is when you you break it up into a bunch of subsets such that no two subsets have anything in common they so it's kind of like you're really just grouping all the elements into a bunch of different sets. That's what it means to Partition.  So in order to show that a relation is an equivalence relation. We need to have these three properties reflexivity symmetric symmetry.  Isn't is there like a noun version?  symmetric cavity  symmetry thank-you transitivity up here. Okay. What does it mean to be symmetric means that everything relates to itself in your set. Okay for all a and your set a release today? Okay. What does it mean to be symmetric? It means that if a relay stavi than be released. Okay, so you have the sort of symmetry and transitivity means that you could kind of imply that if a relates to B & B relates to see then you know that a relates to see. Okay, so we need all three of these properties in order to be an equivalence relation.  Let's do some exercises.  These are the three requirements relations that we talked about.  Rank the set of all ordered pairs where X is less than y the set of all pairs of fit strings where the two strings have the same length and the pair the set of all, I guess instead of these three relations which of these relations Is reflexive.  Okay, we're looking at C&D here. They're pretty even.  You guys want to do a little discussion to see if we can kind of tilta?  All right, so are one. Okay, so I guess we're all in agreement that are one is not reflexive right?  How do you show that is not reflective? You just need one counterexample.  Kr1, so one does not relate to one right cuz one is not less than one case or one is not reflexive. How about our two?  R2 is reflected. Right every string has the same number of characters as itself. So, it's good. How about our three?  Right because two does not relate to two.  Every element has to relate to itself in order for the whole relation to be reflexive.  Okay good.  what about  Symmetric which one of these is symmetric.  If a relates to be then be released today.  Okay, good. Now we're now we're saying R1 and R2 good to an R3. All I want is not reflective right one relates to two.  but two  I say it like this one relates to but two does not relate to one.  Okay, but everything that has the same number of symbols as the other one will have the same number of symbols. Right? So it's kind of like back and forth and this one's actually reflects it because you can just kind of go through every single element and see if it works. Okay, if zero or relates to zero than zero relates to zero good if she relates to to relate to zero that's good and if two released a zero than zero released into but they're all there.  Okay good.  Okay.  how about  transitivity  which one of these is transitive which means that if a relates to B&B relates to see than a relates to see  okay some other combination. What's the other combination?  R1 R2 why is R3 not transitive?  Okay good. So we have that to relates to zero.  and 0 relate to  but we don't have that to relate to to for this to be transitive. We need we need to relate to in there also.  Got any questions about that?  Because it doesn't have the number one. It just needs to follow this this rule, right?  So it's just an implication. So if the the hypothesis of the implication is false, then it doesn't matter if we have a pair where a relief to B&B relates to see we have to have the other one.  Okay, good. So  So let's define what it means to be an equivalence relation in two ways. One is that it's a relation that has these three properties. We just talked about reflexive symmetric and transitive and then a consequence or a  another definition of an equivalence relation is you can partition a set into equivalence classes Each of which consists of similar elements. And what about what do I mean by similar? It depends on what the relation is.  Into collections of disjoint nonempty subset that have asses their Union. So there's two kind of ways that you can think about equivalence relations. And if we if you if you can show a relation is a equivalence relation then automatically you get this partition.  so let's look at some more notation that we're going to use is that if equivalence relation, then this sort of brackets of our is the is the set of all elements  that are in the same equivalence class as a  and what does that mean? It's the set of all elements such that a soda, as is in our  Okay. So here's our theorem. If R is an equivalence relation on a set a for the elements A and B of A A relates to our this also means that the equivalence class of a is equal to the equivalence class of be.  He relates to be sorry and also their equivalent classes are.  non empty right through the intersection  song  is a few more minutes here.  Okay song.  Let's look at this example that we had about the length of strings peso to string two bit strings relate to each other if they have the same number of symbols. This turns out to be an equivalent class. And if you remember on a on those three quick or questions, it was it was reflexive. It was symmetric and it was transitive. Therefore. It is an equivalence relation. So once we have an equivalence relation, how does it partition are sets and partitions the sets into groups of strings that all have the same length.  These are all called equivalence classes.  Okay, so  What is the equivalence class containing just the string 0?  All strings that have the same size as just that strength. So it's just 0 and 1 right? It's all strings of length 1  what's the equivalent class of the string containing 00?  It's going to be all strings that have exactly two symbols 0 0 0 1 1 0 1 1 and so on.  okay, so this is going to be how we  denote equivalence classes  Okay, so maybe we can stop there and pick up on this on Wednesday. "
}