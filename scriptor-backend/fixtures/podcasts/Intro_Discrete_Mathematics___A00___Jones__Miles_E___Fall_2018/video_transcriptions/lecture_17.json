{
    "Blurbs": {
        "-4 * a + -1 don't you guys got? any questions So what's the next element in the list? 512 * -4 is what negative 2048? Is that right? No. Yes. That's right. Yes questions about that. Okay, how about the summation thing? So summations actually are really They are really related to recursively defined functions. And the reason is because you can just think about the the function of ": [
            898.6,
            967.1,
            18
        ],
        "01 star where Lambda is the empty string? And the recursive step if you have some W, so some string of zeros and ones sumbit string if it's in 01 star than w0 is in there and WW1 stars in there. Okay, let's look at kind of how this set could be built. Okay, so we have the empty string. and if you guys haven't seen the empty string before ": [
            1666.8,
            1701.9,
            37
        ],
        "G of I write you're just adding up all the i n minus one term and then you add the next one. questions about that What do you mean the other way around? re-index I don't know if I understand all you're doing G of 1 + the rest. that would be valid but it won't help you with writing a recursive function because the the idea that we want ": [
            1071.4,
            1123.5,
            22
        ],
        "I get to is that this thing here is actually a half of n - 1 And if you start at 2 then. not really part of the definition Okay, so then we have a set of n 50 equal to G of n + 1/2 of N - 1 when? An is greater than or equal to one. Good questions about that. Because I just said that the domain ": [
            1123.5,
            1164.6,
            23
        ],
        "I guess I should say 4 and greater than or equal to one. Okay. So next thing we're going to do is Define asset recursively, so we're defining one set but The way that you figure out what's a member of the set is by a recursive rule? Okay. So you have the same things you have the basics step and the recursive step the bases step. You kind of ": [
            1202.0,
            1231.4,
            25
        ],
        "Lambda. Does it have the equal number of zeros and ones? Lambda has 00 and 01 recursive step Cancel this is just like we had an induction where we were trying to we're trying to prove that if W is in the the language or swimming if W is in the set. then Applying the rules to W to get these new strings. Those also have the property and has ": [
            2435.0,
            2481.0,
            56
        ],
        "Let's look at them one by one. Okay, n factorial. How do I Define this recursively remember I need a basis step and then I need a recursive step. Okay. So for all of these. Functions, let's consider. the domain to be Are the positive integers? Okay, so the basic step in this case is going to be what happens when you have zero factorial. Basis step vs. Spaces Step ": [
            613.7,
            670.9,
            14
        ],
        "Okay, good morning morning. Man, that was a long weekend, huh? Is nice. Didn't feel particularly long for anybody else. like an hour longer no. Yeah, I got an hour more sleep to an hour. Feels like its 12 right now. No. Still too early, huh? Okay, let's get started. Singh is not loud enough iPhone. Okay, what are we doing today? Continue along with induction. We're going to kind ": [
            71.1,
            132.8,
            0
        ],
        "Okay. Good question, though. Okay. So how do we Define a function recursively? It's a lot like how we did the induction so you specify the function value at zero and then you figure out how to to get to the next value from the previous value. Can you give a rule for finding its value based on the values of smaller integer? So it's kind of like you start ": [
            492.0,
            521.3,
            12
        ],
        "V the purpose that you describe. The reason that you describe them recursively is because usually it's a small amount of code to build this really big complex object and this is recursion and and things like that. They have a lot to do with fractals and nature nature kind of works recursively. If you think about a tree when it grows it kind of splits off and then each ": [
            2051.5,
            2081.3,
            46
        ],
        "W + 0 1 W each half. equal number of zeros and ones you guys could probably already see where the proof is going. If you start with equal number of zeros and ones and then you add exactly 1 0 and 1 1 then the result will have equal number of zeros and ones. You see how it's powerful to use induction. You don't have to go through the ": [
            2574.0,
            2615.9,
            59
        ],
        "Zero factorial recursive step is going to be what? We need to figure out how do I get to n factorial from smaller factorials? okay, good times and -1 factorial for n greater than or equal to one. Everybody knows what factorial means are there any questions about factorial? Okay, we're all good. Good good. Okay questions about this recursive function. Okay, how would you all do to to the ": [
            670.9,
            728.6,
            15
        ],
        "a checkmark there. Okay. What about this thing here? All the... Kind of means that it goes on forever goes on for Infinity. So it's like an infinite sequence of zeros and ones. This is not a bit string. There's no way to get to this with a sequence of recursive recursive steps as we Define in the previous slide. questions about that Binary strings, but have to be finite ": [
            1940.0,
            1974.7,
            43
        ],
        "about that set. Okay, so I want to prove something about every one of these things in the set. What's the statement? We can say about every single element in this set? Okay, good. That was the one that we're going to do good. Thank you. So the claim is that every element ask has equal numbers zeros and ones You guys believe this to be true? Yeah, right kind ": [
            2340.7,
            2390.6,
            54
        ],
        "an to be the partial sum up to n Okay, and then so then so if you have that then the function 1/10 + 1 is just a partial sum of 2 n + the next element. Okay. So let's see how that works. So Lake let's look first at Athens zero. What is F10 here? If I equals 120 g of i k is anybody know how we resolve ": [
            967.1,
            997.6,
            19
        ],
        "and it's it's really helpful. If you have some sort of set that's defined recursively then we can use induction to show that things are true about the set. Okay, so we're also going to talk about recursion. What does it mean to define something recursively whether that be a function or a SAT or something like that? And and you're going to you're going to notice that recursion and ": [
            162.9,
            193.3,
            2
        ],
        "any questions about this? Cuz the Lambda is the empty string. It's the string without any characters. So if you start with no characters and you put a zero next to it then all you get is just 0. kind of subtle butt Okay, which one of these strings is not a bit string? And remember, what is the definition of bit string? It's It's what we had in the ": [
            1785.6,
            1838.7,
            40
        ],
        "as a sequence. And if I say I want to know what half of 15 is then I take my sequence and I go down 15 places and figure out what that is, right. So now we can kind of start linking different types of mathematical structures together. So functions over non-negative integers are mainly all they are really are just sequences peso anything that works with sequences works with ": [
            383.4,
            410.5,
            9
        ],
        "at a seed which is like a zero or apple zero and that seemed kind of grows into a sequence. So what's good are clickers out? Which one of these sequences? Can we describe using a recursive function? And how would we do it? Let me just do this real fast. Where am I? Okay, let's see what you guys say. Okay, good. All of them can be defined recursively. ": [
            521.3,
            613.7,
            13
        ],
        "bases step 4 is in s good recursive step. So the recursive step says something like this. If let's call it. Hey if a is an ass. Then a + 1 is an ass. Pain in the night that saw this describes the whole set. What about the number a hundred? How do you know a hundred is in the set? Well, if 99 is in the set that is ": [
            1305.1,
            1343.5,
            28
        ],
        "being one to one being onto it's going to be important how we distinguish the range from the codomain, but for right now you can kind of think the co domain is the set of the set of values that you could expect to see but it might have values in the codomain that you can never get to sort of a little bit later. We start talking about functions. ": [
            458.7,
            490.8,
            11
        ],
        "branch splits off. What else is like that? Michael Rivers when they split in guess I'm just talking about tree structures, but yeah, it's a lot of complex information that you can build but it's it's kind of packaged in this nice small amount of steps right beside the algorithm to kind of build these things. Okay. So what we've done it with induction so far is we've kind of ": [
            2081.3,
            2125.1,
            47
        ],
        "built this linear pathway because we're trying to prove something about all integers and integers are all integers greater than or equal to 0 and that set is nice because I has this linear path right cat pee of cake and pie pfk plus one and you can just go down the whole thing. Now what structural induction we made we may build these sets with kind of a nonlinear ": [
            2125.1,
            2154.8,
            48
        ],
        "don't know some animal. Let's say hummingbird. Okay. Now if all the hummingbirds the initial population if they all carry a certain trait, right like let's say they're all pink. And we know that they they pass on that trait to their offspring if that's a rule. No matter how long they stay on this island. All hummingbirds will always be paint. So it's you can kind of think about ": [
            2655.3,
            2689.4,
            61
        ],
        "end? 2 to the zero is equal to one right and then what 2 to the N is equal to? 2 * 2 to the N minus 1 4 and greater than or equal to one. Okay. How about this one? Why don't you guys take a few minutes to see if you can figure it out with your neighbor? We need a basis step and we need a recursive ": [
            728.6,
            770.0,
            16
        ],
        "finite in length. Okay good. Okay, so recursive definitions that you may have seen already. strings are are really a great mathematical object that you can define recursively you can to find all these recursive Define all these sets of strings recursively if you guys are planning on taking CSE 105, then this is like This is like basically what you do the whole time in that class talked about ": [
            1974.7,
            2019.9,
            44
        ],
        "for this Okay. So this was our original recursion for bit strings. We're just kind of growing them by one bit each time. So how many strings are formed using the basis stepped and at most and applications of the recursive step? Okay good. So if you like if you kind of think about the sequence. after 0 applications, you just get the set the empty empty string one application ": [
            2854.3,
            2932.5,
            65
        ],
        "function. What do you need to specify a function? You need to know? What the domain what are the allowable inputs? What's the codomain? What type of inputs do you expect? And what's the rule? How do I given a certain input? How do I figure out what its images or what the function value is? So today primarily the in the domain is going to be positive. integers or ": [
            249.0,
            285.0,
            5
        ],
        "functions over non-negative integers and vice versa. question No, what's the difference? I know it's not that specific. So the codomain is sort of the it's okay. The range is easy to just Define. The range is all of the function values that are possible. The codomain is just any superset of the range. that might be kind of weird to think about but once we start talking about functions ": [
            410.5,
            458.7,
            10
        ],
        "have? 00 and 01 are both in their right by these two rules. And since one is in there, we get 1 0 to me. Yeah, 1 0 and 1 1 those are both in there. And since we have all those we get 0 0 0 0 0 1 and so on. So this is actually going to generate the whole set of all possible bit strings. Are there ": [
            1751.5,
            1785.6,
            39
        ],
        "if three is in the set than 3 + 2 is in this so far and so on. Okay. So let's look at another type of set of things we've been talking about sets of integers a lot. Let's talk about sets of strings. Okay. So strings are just sequences of characters. Often times will talk about bit strings. Okay, so bit strings are sequences of zeros and ones and ": [
            1587.3,
            1623.3,
            35
        ],
        "in s and then I have the recursive step is if a is in s than a plus two is an S. What is an equivalent description of this set? Okay, good all positive odd integers. questions You could just kind of think about it you put one in the set. And then if one is in the set than one plus two is in the sets of three good ": [
            1533.9,
            1587.3,
            34
        ],
        "in the set. How do you know 99 isn't it? Isn't it all the way back to 4 so Yeah, it's a different way to describe this set any questions about it. What is the spectacle 44073? No, but three is not an ass. Sure, you can cuz you suck them a hundred and you back up back it up until you get to 4th. And then for you can ": [
            1343.5,
            1390.3,
            29
        ],
        "in this particular example the trait is that each string will always have zeros in ones and their offspring equal number of zeros and ones and their offspring will always have that equal number of zeros and ones just by the nature of the the process the nature of the recursion any questions about that that help with the Thanks. Okay. Okay, so that's so here's the proof. This is ": [
            2691.9,
            2733.6,
            62
        ],
        "in this set. We have Lambda. We have zero one, Lambda. n10, Lambda What else do we have based on those? 1010 1001 what else we have? That's kind of coming from this guy. From this one we have what one? Well, I guess that's coming from this one. Dorset so I don't care about the order, right? And this guy gives me. 011001 and 01 and someone take questions ": [
            2281.2,
            2340.7,
            53
        ],
        "induction really go hand-in-hand there one in the same thing recursion is more about how to define something recursively and induction using the same concept but to prove something and is you using your using the recursive property the recursive nature the only reason induction works on the set of all integers it because the integers have this recursive property where if any of the integer than n + 1 ": [
            193.3,
            221.9,
            3
        ],
        "infinite set. You can just kind of show that the recursion holds these properties right and it carries it Carries On. So I was looking at different ways to talk about structural induction and I came across this. This nice analogy which was supposed you had a like some Island that is separated from all the other Society or anything like that. Okay, and you have initial population of I ": [
            2615.9,
            2655.3,
            60
        ],
        "is an integer and so then you can use that to kind of build up. So we're going to kind of generalize that type of argument Okay, so we're getting we can come at recursive definition this kind of in a few different ways. One of them is how to define a function. This might be how you guys are normally acquainted with her Persian. You can recursively Define a ": [
            221.9,
            249.0,
            4
        ],
        "it kind of but you you bring up a good point because we in order to show that a hundred is in the set maybe like your scratch work would be going backwards like that trying to get the four but your presentation should look something like okay for is in the sat there for five in the set their 46247 if me and someone yeah. But it would be ": [
            1439.7,
            1474.2,
            32
        ],
        "it's just a string with no characters kind of like Okay, so if the empty string is in there, that means that the empty string. 0 and the empty string one are both in there. And a better way to write this. would be 0 and 1 peso. These are the same these mean the same thing. questions Okay. So since since 0 is in there, what else do we ": [
            1701.9,
            1751.5,
            38
        ],
        "just what I wrote down before I guess I'll have you guys prove this as an exercise. All right. so last kind of recursive definition we're going to have is hey. Recursively defined set a function on a recursive lead to find set okay. So the domain is going to be the set that has this recursive structure and then you have a function that goes to some codomain. Let ": [
            2733.6,
            2784.3,
            63
        ],
        "maybe non- okay. so one of the other Something like that. The kodo name is going to be a lot of different things right you could you could either have the codomain be integers or real numbers or even sets ranked. So doesn't they don't have to match the codomain in the domain don't have to match. Okay, so if our domain were the set of non-negative integers are natural ": [
            285.0,
            329.4,
            6
        ],
        "me give you an example. the length of function What is the length of a string? a string is what? Okay, good the number of characters. Okay, so l is a function from the set of all bit strings to the non-negative integers for example L of 0100 is equal to 4 your input is a string and output is a number a non-negative integer so if we have time ": [
            2784.3,
            2854.3,
            64
        ],
        "now how do I Define f of n well, let's just write it out at the van is I equals 1 to n g of I right. And so basically you're just doing G of 1 + G of 2 + G of 3 all the way up to plenty of end. So it's natural to decompose this 2 G of n Plus I equals 1 2 N -1 of ": [
            1037.4,
            1071.4,
            21
        ],
        "numbers. Then you can actually just write out what each function value is half of 0 is something half of one is something effort to is something now. This will be like an infinite list of assignments. But if you had infinite time you could write them all out and if you had infinite time you can kind of read them all but we don't have time. So generally what ": [
            329.4,
            352.7,
            7
        ],
        "of easy to see maybe some of your even thinking about it recursively which is well if they haven't even number of 100 wants to start with then I'm adding a zero and a one that's my only rule. So the next one will have the even number of zeros and ones equal number of zeros together. What's what in the world? proof by structural induction Okay basis step. Okay, ": [
            2390.6,
            2435.0,
            55
        ],
        "of talk about how to apply induction to a different type of problem. Remember we said that induction problems are really nice to show that something is true for all non-negative integers and or even all integers greater than or equal to some other integer and it works really well for that. There's another type of structure that works well for and for that reason we call it structural induction ": [
            132.8,
            162.9,
            1
        ],
        "one is in the set then a is in a second. That's not what I said. I said I said, let's see if a hundred is in the set a hundred is in the set if 99 is an asset 99 is in the set if 98 is in the set ideas in the set if 97 right and then you go back down to four is anisette and then ": [
            1419.1,
            1439.7,
            31
        ],
        "out. What is the set? Where's the set look like? For what else 5 6 7 and so on. Who the infinite set right when you going to see that? We only need to find out amount of information in order to describe it? How do we describe it recursively basis step? Let's call this set ass faces step. What do we want to put into a cynicial e? 40K ": [
            1262.6,
            1305.1,
            27
        ],
        "path. If there's two or more rules, then you can maybe get to a number in different ways or get to certain numbers that you couldn't get to others. If you go down a certain branch of the tree guy. So structural induction is a generalization of mathematical induction or were talking more about recursively defined sets instead of just the non-negative integers. So how do you do structural induction ": [
            2154.8,
            2184.5,
            49
        ],
        "previous slide. We defined it recursively case of this whatever we defined here is the set of all bit strings. I'll take a look. naked Okay, so if if something is not a bit string that means that you can't get to it using a sequence recursive steps, right? Is the empty string a bit string? Yes, right. It's the basis step. It's the first string that we that we ": [
            1838.7,
            1896.0,
            41
        ],
        "put into the set. Let's go back for a sec. You guys can't see it. The first drink is a basic step. Lambda is a bit string Lambda is in this set. All right. What about 1? Is that a bit string? Yes, I just added to 1 how about 000? Also, yes. Hey, so all three of these are. What about 0 1 0 1 0 1? Already put ": [
            1896.0,
            1940.0,
            42
        ],
        "put some initial elements in there may be one or two or three. In the recursive step tells you how to get two new elements. How do you add new elements to the set? Let's look at an example. the example of all integers X such that X is an integer and X is greater than 3 Okay, so maybe some place to start with this is to just write ": [
            1231.4,
            1262.6,
            26
        ],
        "say I know for is in the set because of the base set. I mean that no because 3 is not in the set. This is this is a good this is a good example of the implication only going One Direction. But it says that if a is in the sack than a plus one is in the set, but that's not the same as saying if a plus ": [
            1390.3,
            1419.1,
            30
        ],
        "so we'll start with Dad on Wednesday. structuralism ": [
            2987.1,
            2999.5,
            67
        ],
        "step. Okay, ready? Go? Call Patricia. Let me know if you want me to write some more. some more numbers in the sequence Hi Mario, how's it going? Okay, how does it go? What is F4? Let's call this function. I am so let's say this is a 0 A1 A2 A3 before a 0 is equal to what? Two very good. And a n is equal to what? Write ": [
            770.0,
            898.6,
            17
        ],
        "strings sets of strings. And how do you describe them? You can describe them recursively that using one model or describe them by listing them out or describe them using these other types of tools called regular expressions and stuff like that. Okay, so there's data structures that you guys may have seen already in some of your coding classes often times. They're defined recursively like trees like linkless grass ": [
            2019.9,
            2051.5,
            45
        ],
        "the property than the new strings that you make will also have the property. So how we going to do this? Let W be in the sack. and assume W has equal number zeros and ones let's just highlight some of these things first. So when I say let wbns this is like when we're doing induction. This is like when we say let K be greater than or equal ": [
            2481.0,
            2525.6,
            57
        ],
        "the same. That that would be an equivalent statement. question andechs are recursive stuff. Can you say that again? 04 all s a s and s implies a plus one is as that's fine. Let's write that kind of an alternative way to say it for all ass. A&S implies a plus one is in it. Okay good. Alright, let's look at another example. Okay, I have that one is ": [
            1474.2,
            1533.9,
            33
        ],
        "this when the when the index starts number after the the after it supposed to end. It's just zero notice that this is Nike not really the way you want to write a summation with a bunch of terms because you're starting at 1 and going to zero. So if the index starts before or after it supposed to end then we just defined that to be zero. Okay. So ": [
            997.6,
            1037.4,
            20
        ],
        "to 0. and then assume W has an equal number of zeros and ones this is the inductive hypothesis. Pace what has the same exact structure as regular induction just a little bit in generalized. Okay, then. We want the show. That each one of the rules will result in a string that has equal number of zeros and ones want to show that. I guess it would be 10 ": [
            2525.6,
            2574.0,
            58
        ],
        "to have I want to build this subset s okay. It's not all the bit strings, but it's just some of the bit strings to subsets. How do we Define it? We're going to put in the empty string. Lambda and then if we have a string in s then 10 W is in sn01 W is in s let's let's write out a few of the first few strings ": [
            2253.1,
            2281.2,
            52
        ],
        "to lot like regular induction? You shall I guess I have to tell you what types of problems you can do with structural induction. They so if you have a recursively defined fat ass. And I want to show that some statement is true for all of the values of s. IU structural induction. So the first thing you do is say okay. Is it true for the is it ": [
            2184.5,
            2215.2,
            50
        ],
        "true for the basis step of your recursively defined set? And you can usually just do that by inspection and then you show that if it's true for some element of the set, then it must be true for all of the all of the new elements in the recursive step. I think it's an example would be nice to see. Okay, so let's look at this example. I want ": [
            2215.2,
            2253.1,
            51
        ],
        "we don't we just write them in one after the other we don't. Separate them by commas or anything like that. They're just sequences of strength, okay. So this symbol 01 * this thing is called. cleaning star and it's an operation that you do on sets and the operation has a recursive meaning for a recursive definition. Okay, here it is. The recursive definition is this Lambda is in ": [
            1623.3,
            1666.8,
            36
        ],
        "we like to do is have some sort of formula that you plug it into right? So what does that look like? we can do we can kind of talk about the formula as What happens when I plug in a certain number and then you may be a 10 squared or whatever and plus one or something like that or you can think about these values please function values ": [
            352.7,
            383.4,
            8
        ],
        "will be starting from zero. So I was just trying to keep it. Keep it consistent with the other ones, but you can start at half of one if you wanted to and you just have half of 1 is equal to G of Frank and then go from there. I feel like this Mike is a little too loud. There any other questions? Pick up. That's what we got. ": [
            1164.6,
            1202.0,
            24
        ],
        "you get what the empty string 0 and 1 I hear we get 132 applications. We get the empty set empty string 0 1 0 0 1 1 0 1 1 0 so that's how many 7 and so on right? It's basically like for every every time You apply it you keep on getting 2K + 1. Play why did I say end? I should have said k Okay, ": [
            2932.5,
            2987.1,
            66
        ]
    },
    "File Name": "Intro_Discrete_Mathematics___A00___Jones__Miles_E___Fall_2018-lecture_17.flac",
    "Full Transcript": "Okay, good morning morning.  Man, that was a long weekend, huh?  Is nice.  Didn't feel particularly long for anybody else.  like an hour longer  no.  Yeah, I got an hour more sleep to an hour.  Feels like its 12 right now. No.  Still too early, huh? Okay, let's get started.  Singh is not loud enough iPhone.  Okay, what are we doing today?  Continue along with induction. We're going to kind of talk about how to apply induction to a different type of problem.  Remember we said that induction problems are really nice to show that something is true for all non-negative integers and or even all integers greater than or equal to some other integer and it works really well for that. There's another type of structure that works well for and for that reason we call it structural induction and it's it's really helpful. If you have some sort of set that's defined recursively then we can use induction to show that things are true about the set.  Okay, so we're also going to talk about recursion.  What does it mean to define something recursively whether that be a function or a SAT or something like that? And  and you're going to you're going to notice that recursion and induction really go hand-in-hand there one in the same thing recursion is more about how to define something recursively and induction using the same concept but to prove something and is you using your using the recursive property the recursive nature the only reason induction works on the set of all integers it because the integers have this recursive property where if any of the integer than n + 1 is an integer and so then you can use that to kind of build up. So we're going to kind of generalize that type of argument  Okay, so  we're getting we can come at recursive definition this kind of in a few different ways. One of them is how to define a function. This might be how you guys are normally acquainted with her Persian. You can recursively Define a function. What do you need to specify a function? You need to know? What the domain what are the allowable inputs? What's the codomain? What type of inputs do you expect? And what's the rule? How do I given a certain input? How do I figure out what its images or what the function value is?  So today primarily the in the domain is going to be positive.  integers  or maybe non-  okay.  so one of the other  Something like that. The kodo name is going to be a lot of different things right you could you could either have the codomain be integers or real numbers or even sets ranked. So doesn't they don't have to match the codomain in the domain don't have to match.  Okay, so  if our domain were the set of  non-negative integers are natural numbers.  Then you can actually just write out what each function value is half of 0 is something half of one is something effort to is something now. This will be like an infinite list of assignments. But if you had infinite time you could write them all out and if you had infinite time you can kind of read them all but we don't have time. So generally what we like to do is have some sort of formula that you plug it into right?  So what does that look like?  we can do we can kind of talk about the formula as  What happens when I plug in a certain number and then you may be a 10 squared or whatever and plus one or something like that or you can think about these values please function values as a sequence. And if I say I want to know what half of 15 is then I take my sequence and I go down 15 places and figure out what that is, right. So now we can kind of start linking different types of mathematical structures together. So functions over non-negative integers are mainly all they are really are just sequences peso anything that works with sequences works with functions over non-negative integers and vice versa.  question  No, what's the difference?  I know it's not that specific.  So the codomain is sort of the  it's okay. The range is easy to just Define. The range is all of the function values that are possible.  The codomain is just any superset of the range.  that might be kind of weird to think about but once we start talking about functions being one to one being onto it's going to be important how we distinguish the range from the codomain, but for right now you can kind of think the co domain is the set of  the set of values that you could expect to see but it might have values in the codomain that you can never get to sort of a little bit later.  We start talking about functions.  Okay. Good question, though.  Okay. So how do we Define a function recursively? It's a lot like how we did the induction so you specify the function value at zero and then you figure out how to to get to the next value from the previous value. Can you give a rule for finding its value based on the values of smaller integer? So it's kind of like you start at a seed which is like a zero or apple zero and that seemed kind of grows into a sequence.  So what's good are clickers out?  Which one of these sequences?  Can we describe using a recursive function?  And how would we do it?  Let me just do this real fast.  Where am I?  Okay, let's see what you guys say.  Okay, good. All of them can be defined recursively. Let's look at them one by one.  Okay, n factorial.  How do I Define this recursively remember I need a basis step and then I need a recursive step. Okay. So for all of these.  Functions, let's consider.  the domain  to be  Are the positive integers?  Okay, so the basic step in this case is going to be what happens when you have zero factorial.  Basis step vs. Spaces Step Zero factorial recursive step is going to be what?  We need to figure out how do I get to n factorial from smaller factorials?  okay, good times and -1 factorial  for n greater than or equal to one.  Everybody knows what factorial means are there any questions about factorial?  Okay, we're all good. Good good.  Okay questions about this recursive function.  Okay, how would you all do to to the end?  2 to the zero is equal to one right and then what 2 to the N is equal to?  2 * 2 to the N minus 1  4 and greater than or equal to one.  Okay. How about this one? Why don't you guys take a few minutes to see if you can figure it out with your neighbor? We need a basis step and we need a recursive step. Okay, ready? Go?  Call Patricia.  Let me know if you want me to write some more.  some more numbers in the sequence  Hi Mario, how's it going?  Okay, how does it go? What is F4? Let's call this function.  I am so let's say this is a 0 A1 A2 A3 before a 0 is equal to what?  Two very good.  And a n is equal to what?  Write -4 * a + -1 don't you guys got?  any questions  So what's the next element in the list? 512 * -4 is what negative 2048?  Is that right?  No.  Yes.  That's right. Yes questions about that.  Okay, how about the summation thing?  So summations actually are really  They are really related to recursively defined functions. And the reason is because you can just think about the  the function of an to be the partial sum up to n  Okay, and then so then so if you have that then the function 1/10 + 1 is just a partial sum of 2 n + the next element. Okay. So let's see how that works. So Lake let's look first at Athens zero. What is F10 here?  If I equals 120 g of i k is anybody know how we resolve this when the when the index starts number after the the after it supposed to end.  It's just zero notice that this is Nike not really the way you want to write a summation with a bunch of terms because you're starting at 1 and going to zero. So if the index starts before or after it supposed to end then we just defined that to be zero.  Okay. So now how do I Define f of n well, let's just write it out at the van is I equals 1 to n g of I right.  And so basically you're just doing G of 1 + G of 2 + G of 3 all the way up to plenty of end. So it's natural to  decompose this 2 G of n Plus  I equals 1 2 N -1 of G of I write you're just adding up all the i n minus one term and then you add the next one.  questions about that  What do you mean the other way around?  re-index  I don't know if I understand all you're doing G of 1 + the rest.  that would be valid but it won't help you with writing a recursive function because the the idea that we want I get to is that this thing here is actually a half of n - 1  And if you start at 2 then.  not really part of the definition  Okay, so then we have a set of n 50 equal to G of n + 1/2 of N - 1 when?  An is greater than or equal to one.  Good questions about that.  Because I just said that the domain will be starting from zero. So I was just trying to keep it.  Keep it consistent with the other ones, but you can start at half of one if you wanted to and you just have half of 1 is equal to G of Frank and then go from there.  I feel like this Mike is a little too loud.  There any other questions?  Pick up. That's what we got. I guess I should say 4 and greater than or equal to one.  Okay. So next thing we're going to do is Define asset recursively, so we're defining one set but  The way that you figure out what's a member of the set is by a recursive rule? Okay. So you have the same things you have the basics step and the recursive step the bases step. You kind of put some initial elements in there may be one or two or three.  In the recursive step tells you how to get two new elements. How do you add new elements to the set?  Let's look at an example.  the example of all integers X such that X is an integer and X is greater than 3  Okay, so maybe some place to start with this is to just write out. What is the set? Where's the set look like?  For what else 5 6 7 and so on.  Who the infinite set right when you going to see that? We only need to find out amount of information in order to describe it?  How do we describe it recursively basis step?  Let's call this set ass faces step.  What do we want to put into a cynicial e?  40K bases step 4 is in s good recursive step.  So the recursive step says something like this.  If let's call it.  Hey if a is an ass.  Then a + 1 is an ass.  Pain in the night that saw this describes the whole set. What about the number a hundred? How do you know a hundred is in the set? Well, if 99 is in the set that is in the set. How do you know 99 isn't it? Isn't it all the way back to 4 so  Yeah, it's a different way to describe this set any questions about it.  What is the spectacle 44073?  No, but three is not an ass.  Sure, you can cuz you suck them a hundred and you back up back it up until you get to 4th. And then for you can say I know for is in the set because of the base set.  I mean that no because 3 is not in the set.  This is this is a good this is a good example of the implication only going One Direction.  But it says that if a is in the sack than a plus one is in the set, but that's not the same as saying if a plus one is in the set then a is in a second. That's not what I said. I said I said, let's see if a hundred is in the set a hundred is in the set if 99 is an asset 99 is in the set if 98 is in the set ideas in the set if 97 right and then you go back down to four is anisette and then it kind of but you you bring up a good point because we  in order to show that a hundred is in the set maybe like your scratch work would be going backwards like that trying to get the four but your presentation should look something like okay for is in the sat there for five in the set their 46247 if me and someone  yeah.  But it would be the same.  That that would be an equivalent statement.  question  andechs are recursive stuff. Can you say that again?  04 all s a s and s implies a plus one is as that's fine.  Let's write that kind of an alternative way to say it for all ass.  A&S implies a plus one is in it.  Okay good.  Alright, let's look at another example.  Okay, I have that one is in s and then I have the recursive step is if a is in s than a plus two is an S. What is an equivalent description of this set?  Okay, good all positive odd integers.  questions  You could just kind of think about it you put one in the set. And then if one is in the set than one plus two is in the sets of three good if three is in the set than 3 + 2 is in this so far and so on.  Okay.  So let's look at another type of set of things we've been talking about sets of integers a lot. Let's talk about sets of strings. Okay. So strings are just sequences of characters.  Often times will talk about bit strings.  Okay, so bit strings are sequences of zeros and ones and we don't we just write them in one after the other we don't.  Separate them by commas or anything like that. They're just sequences of strength, okay.  So this symbol 01 * this thing is called.  cleaning star  and it's an operation that you do on sets and the operation has a recursive meaning for a recursive definition. Okay, here it is. The recursive definition is this  Lambda is in 01 star where Lambda is the empty string?  And the recursive step if you have some W, so some string of zeros and ones sumbit string if it's in 01 star than w0 is in there and WW1 stars in there.  Okay, let's look at kind of how this set could be built.  Okay, so we have the empty string.  and if you guys haven't seen the empty string before it's just a string with no characters kind of like  Okay, so if the empty string is in there, that means that the empty string.  0 and the empty string one are both in there.  And a better way to write this.  would be  0 and 1 peso. These are the same these mean the same thing.  questions  Okay. So since since 0 is in there, what else do we have?  00 and 01 are both in their right by these two rules.  And since one is in there, we get 1 0 to me. Yeah, 1 0 and 1 1 those are both in there. And since we have all those we get 0 0 0 0 0 1 and so on.  So this is actually going to generate the whole set of all possible bit strings.  Are there any questions about this?  Cuz the Lambda is the empty string. It's the string without any characters. So if you start with no characters and you put a zero next to it then all you get is just 0.  kind of subtle butt  Okay, which one of these strings is not a bit string?  And remember, what is the definition of bit string? It's  It's what we had in the previous slide. We defined it recursively case of this whatever we defined here is the set of all bit strings.  I'll take a look.  naked  Okay, so if if something is not a bit string that means that you can't get to it using a sequence recursive steps, right?  Is the empty string a bit string?  Yes, right. It's the basis step.  It's the first string that we that we put into the set. Let's go back for a sec. You guys can't see it.  The first drink is a basic step. Lambda is a bit string Lambda is in this set.  All right.  What about 1?  Is that a bit string?  Yes, I just added to 1 how about 000?  Also, yes.  Hey, so all three of these are.  What about 0 1 0 1 0 1?  Already put a checkmark there. Okay. What about this thing here?  All the... Kind of means that it goes on forever goes on for Infinity. So it's like an infinite sequence of zeros and ones. This is not a bit string. There's no way to get to this with a sequence of recursive recursive steps as we Define in the previous slide.  questions about that  Binary strings, but have to be finite finite in length.  Okay good.  Okay, so  recursive definitions that you may have seen already.  strings are are really a great mathematical object that you can define recursively you can to find all these recursive Define all these sets of strings recursively if you guys are planning on taking CSE 105, then this is like  This is like basically what you do the whole time in that class talked about strings sets of strings. And how do you describe them? You can describe them recursively that using one model or describe them by listing them out or describe them using these other types of  tools called regular expressions and stuff like that.  Okay, so there's data structures that you guys may have seen already in some of your coding classes often times. They're defined recursively like trees like linkless grass V the purpose that you describe. The reason that you describe them recursively is because usually it's a small amount of code to build this really big complex object and this is recursion and and things like that. They have a lot to do with fractals and nature nature kind of works recursively. If you think about a tree when it grows it kind of splits off and then each branch splits off.  What else is like that?  Michael Rivers when they split in guess I'm just talking about tree structures, but  yeah, it's a lot of complex information that you can build but it's it's kind of packaged in this nice small amount of  steps right beside the algorithm to kind of build these things.  Okay. So what we've done it with induction so far is we've kind of built this linear pathway because we're trying to prove something about all integers and integers are all integers greater than or equal to 0 and that set is nice because I has this linear path right cat pee of cake and pie pfk plus one and you can just go down the whole thing.  Now what structural induction we made we may build these sets with kind of a nonlinear path. If there's two or more rules, then you can maybe get to a number in different ways or get to certain numbers that you couldn't get to others. If you go down a certain branch of the tree guy. So structural induction is a generalization of mathematical induction or were talking more about recursively defined sets instead of just the non-negative integers.  So how do you do structural induction to lot like regular induction?  You shall I guess I have to tell you what types of problems you can do with structural induction. They so if you have a recursively defined fat ass.  And I want to show that some statement is true for all of the values of s.  IU structural induction. So the first thing you do is say okay. Is it true for the is it true for the basis step of your recursively defined set?  And you can usually just do that by inspection and then you show that if it's true for some element of the set, then it must be true for all of the all of the new elements in the recursive step.  I think it's an example would be nice to see.  Okay, so let's look at this example.  I want to have I want to build this subset s okay. It's not all the bit strings, but it's just some of the bit strings to subsets. How do we Define it? We're going to put in the empty string.  Lambda  and then if we have a string in s then 10 W is in sn01 W is in s  let's let's write out a few of the first few strings in this set.  We have Lambda. We have zero one, Lambda.  n10, Lambda  What else do we have based on those?  1010  1001 what else we have? That's kind of coming from this guy.  From this one we have what one?  Well, I guess that's coming from this one.  Dorset so I don't care about the order, right?  And this guy gives me.  011001 and 01 and someone take questions about that set.  Okay, so I want to prove something about every one of these things in the set. What's the statement? We can say about every single element in this set?  Okay, good. That was the one that we're going to do good. Thank you. So the claim is that every  element  ask  has  equal numbers  zeros and ones  You guys believe this to be true?  Yeah, right kind of easy to see maybe some of your even thinking about it recursively which is well if they haven't even number of 100 wants to start with then I'm adding a zero and a one that's my only rule.  So the next one will have the even number of zeros and ones equal number of zeros together.  What's what in the world?  proof by structural induction  Okay basis step.  Okay, Lambda. Does it have the equal number of zeros and ones?  Lambda has  00 and 01  recursive step  Cancel this is just like we had an induction where we were trying to we're trying to prove that if W is in the the language or swimming if W is in the set.  then  Applying the rules to W to get these new strings. Those also have the property and has the property than the new strings that you make will also have the property.  So how we going to do this?  Let W be in the sack.  and assume  W has  equal  number  zeros and ones  let's just highlight some of these things first. So when I say let wbns  this is like when we're doing induction. This is like when we say let K be greater than or equal to 0.  and then assume  W has an equal number of zeros and ones this is the inductive hypothesis.  Pace what has the same exact structure as regular induction just a little bit in generalized.  Okay, then.  We want the show.  That each one of the rules will result in a string that has equal number of zeros and ones want to show that.  I guess it would be 10 W + 0 1 W each half.  equal number of zeros and ones  you guys could probably already see where the proof is going.  If you start with equal number of zeros and ones and then you add exactly 1 0 and 1 1 then the result will have equal number of zeros and ones.  You see how it's powerful to use induction. You don't have to go through the infinite set. You can just kind of show that the recursion holds these properties right and it carries it Carries On.  So I was looking at different ways to talk about structural induction and I came across this.  This nice analogy which was supposed you had a like some Island that is separated from all the other Society or anything like that. Okay, and you have initial population of I don't know some animal. Let's say hummingbird. Okay. Now if all the hummingbirds the initial population if they all carry a certain trait, right like let's say they're all pink.  And we know that they they pass on that trait to their offspring if that's a rule.  No matter how long they stay on this island. All hummingbirds will always be paint. So it's you can kind of think about  in this particular example the trait is that each string will always have zeros in ones and their offspring equal number of zeros and ones and their offspring will always have that equal number of zeros and ones just by the nature of the the process the nature of the recursion any questions about that that help with the  Thanks.  Okay.  Okay, so that's so here's the proof.  This is just what I wrote down before I guess I'll have you guys prove this as an exercise.  All right.  so last kind of recursive definition we're going to have is  hey.  Recursively defined set a function on a recursive lead to find set okay.  So the domain is going to be the set that has this recursive structure and then you have a function that goes to some codomain.  Let me give you an example.  the length of function  What is the length of a string?  a string  is what?  Okay, good the number of characters.  Okay, so l  is a function  from  the set of all bit strings to the non-negative integers  for example  L of 0100 is equal to 4 your input is a string and output is a  number a non-negative integer  so if we have time for this  Okay. So this was our original recursion for bit strings. We're just kind of growing them by one bit each time.  So how many strings are formed using the basis stepped and at most and applications of the recursive step?  Okay good.  So if you like if you kind of think about the sequence.  after 0 applications, you just get the set the empty empty string one application you get what the empty string 0 and 1  I hear we get 132 applications. We get the empty set empty string 0 1 0 0 1 1 0 1 1 0 so that's how many 7 and so on right? It's basically like for every every time  You apply it you keep on getting 2K + 1.  Play why did I say end? I should have said k  Okay, so we'll start with Dad on Wednesday.  structuralism "
}