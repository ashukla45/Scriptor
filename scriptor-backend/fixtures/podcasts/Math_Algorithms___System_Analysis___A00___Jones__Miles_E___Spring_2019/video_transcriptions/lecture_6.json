{
    "Blurbs": {
        "* meaning really really for sorting algorithms the best measure for how long they take is number of comparisons. So the number of comparisons is big state of N squared for average case. Yes. Now you still have to do it because there's no check to see if it's sorted yet. I suppose you could check it first and then if it's not sorted run merch store. No, just bien. ": [
            3637.9,
            3692.0,
            81
        ],
        "+ 7 is 21 so that'll be bigger than 1 + 3 which is 4 Okay, so this is how how they ordered it, but there's nothing on here telling me how did you sort it? Okay, so they just had to figure it out. Okay, I like that. It works for small values. Okay. Merge me. We did merge sort also, okay starting from the beginning of each set ": [
            1680.6,
            1724.3,
            27
        ],
        "5 two times? Okay. 25 is 5 Square pretty good. I never heard that one. Okay so number. 5 * evenly divided I-5 anybody else I could be I don't know. okay, what I was thinking was You all ready for this? all depends on how you Well 42 starts with an F 10 starts with a t t e n. So all depends on what you how you define ": [
            508.1,
            612.2,
            9
        ],
        "Are you going to let me see you tonight? Take a nap. All right. Let's get started. They buddy have any questions before we begin. No. Which room is the midterm in? Anybody know? I'm sorry. Solis it's on the what is that called the schedule of classes? Webb Bridge, yeah. We should make a post of it though on Piazza. Remind everybody. So let's get started or doing sorting ": [
            51.8,
            143.0,
            0
        ],
        "Are you? Alright, does anybody have any extras? Are you need some more here? Just getting from your neighbor there. Alright, so you guys need some. O none of y'all got any. alright, so working group so like these sections, okay. And does anybody understand what you're doing? Okay. Ready go. Do you have any leftover? How do you spell restaurant? How's the weather? Sorry. Okay. You guys all sort ": [
            845.7,
            1137.3,
            17
        ],
        "Biggest to check to check to see if something sorted will take linear time. Yeah, so yeah, and maybe you could I don't know maybe you can do a mixture of these things and say well if it's very close to sorted by some measure. Maybe I'll just use bubble sort to kind of fixed the the rest of them. But if it's all kind of crazy random then merchsource ": [
            3692.9,
            3718.4,
            82
        ],
        "But if I assume that then this should be pretty clear. Iterate from 1 2 N -1 set a.m. To be the minimum interchange a inam and then that should work. Okay, how's it going over there? Okay, you can you can take a break. Yeah, I don't know if it's worth it. You're the you're the only one working. Oh wow. You going to show up now? I have ": [
            2454.4,
            2506.2,
            46
        ],
        "Hey, how about binary search tree traversal? Did you guys do binary search trees in 30 or 12 or 15 or 8 or l or? Well, okay. So this one is basically you you build a binary binary search tree and then you kind of pluck everything off or you kind of read them in order and they're going to be in sorted order if you do it that way. ": [
            3289.2,
            3319.0,
            71
        ],
        "How do you put them in a sending order? How do you solve the problem is to that's the algorithm description. How do you go about doing it? You need a step-by-step unambiguous set of instructions in order to start with the input and get the desired output. Why do they step solve the problem? This is the correctness proof. We're going to show why is your algorithm work? And ": [
            2222.3,
            2248.8,
            39
        ],
        "I start at 2? Why don't I start at 1? Write the first card in your list will always be sorted a sorted list in itself right to start with the second card and compare it to the first put those if you know find its position and so on find where aj belongs in the list a 1/2 AJ -1 right and then put it in its place. Here's ": [
            2929.7,
            2958.1,
            60
        ],
        "I want to stop want you to think about these. These props. Where are they? Okay, so we had the strategies is the strategy clear. I'm talking about the strategies on the board where they clear a little clearer than others. Does the strategy always work? Well, I think most of them would work all the time and this is kind of What we're going to look at today and ": [
            2069.9,
            2105.0,
            35
        ],
        "Okay, we'll come back to these. Why are there so many algorithms. Well mostly for practice. We're home so that you could do well on the homework and the exams and maybe there's a job interview that I'll ask you some sort of sorting question. So you should know what they are. They're really good models for what we're going to be doing in this class, which is teaching about ": [
            3321.3,
            3346.7,
            72
        ],
        "Okay. How about from this this area? Are you guys had a big group? Okay, cool. And then from over there? Okay, start start by writing your group name. And then write down your algorithm. What's your group name? Your group name is seven. Okay. back left corner black hole song I like that. All right. Hello neighbor algorithm. It could be your group name could be the same as ": [
            1235.8,
            1300.3,
            19
        ],
        "Some other ones BOGO sort. Has anybody heard that? How does that work? You throw the cards in the air and then you hope that they land in the correct order. And then what if they don't land in the correct order? You do it again, right? How long is that going to take? A long time the expected run time as what? Factorial because if you think about the ": [
            3210.3,
            3248.6,
            69
        ],
        "Thank you. Oh, no, just hold on to him for now Okay. Talk about it. Just if you want to shout out if I'm if I'm explaining it wrong then let me know. Okay, so group 7 merge sort with hands distribute one card each person each person with a card finds another with cards place the big that is kind of like what we did the first day of ": [
            1602.6,
            1640.0,
            25
        ],
        "Then you go to the next to 6 and 2 they're out of order. So you swap them value is the biggest the biggest will always bubble up to the top. That's kind of what makes the algorithm work. Continue run through it again. And you see that for bubbles up to the top and then three and then two and then one you don't have to do one because ": [
            2841.7,
            2866.6,
            57
        ],
        "Well, you guys did pretty good. Did y'all find any repeats? Yeah. I made these today if you couldn't smell the ink on them already. I just tried to put some random numbers down, but I guess I failed out of order 47. Okay. Anyhow. I'll use those for next quarter. Okay, so this is selection sort and if we want to go kind of one level deeper into the ": [
            2546.9,
            2592.3,
            48
        ],
        "What is not ascending order in terms of how the numbers are? And why did you choose to do it that way? I had an epiphany and then I'm going to say okay and then people started listening to you. Call Becca. Cuz like I don't want to do the same store or store or like collections or do you still need to sort them after you do it? Okay. ": [
            1552.9,
            1602.6,
            24
        ],
        "a good point in that. It'll probably cut down on the on the searching cost. good point like why is the average actually equal to the worst case? so so how would it how is it defined is defined to be. You basically run the algorithm on every single possible permutation and then you show that and then you take the average of all of the run times. And run ": [
            3585.4,
            3637.9,
            80
        ],
        "a much more complicated or lower lower lower level where you actually go through and first find out where it goes and then you make room for it and put it where it needs to be. okay, so this is find where it goes. make room and insert Okay. Do I have an example of this? Okay, good. Yeah, so here's your original list. The first element is already in ": [
            2958.1,
            3005.0,
            61
        ],
        "a sort of stack of number and + 1 numbers? wow, unsorted short Okay, so these are all great and thank you for doing this activity with me. I do see kind of a theme at least with some of them where it says kind of Stuart Little groups and then put them together. So now put all the cards together ready. I'm going to time y'all ready go. Yeah, ": [
            1912.0,
            1961.1,
            33
        ],
        "about the input for that to be for that to happen? It's already sorted. Okay, and so you can put like a a break in the code and check to see if it's already sorted because remember how bubble sort works is you just compare every consecutive pair of integers, right? If they're already in sorted order then you didn't do any swaps. So if you didn't do any swaps, ": [
            3398.8,
            3429.1,
            75
        ],
        "algorithms today. So let's take a look at you know certain things right? So here we have an unordered mass and here we have a very ordered set of dolls. When we talked about ordered, what do we mean? Well, this is ordered by height or size right in decreasing order. This made it could be be considered to be in order. There's like there's this child in here. He's ": [
            143.0,
            182.2,
            1
        ],
        "are in sorted order. Okay, here's all this stuff again. We already saw this. Okay. So, let me just write it here. after the teeth iteration And actually there's going to be to Loop invariants that we're going to use one. Is that a 1 through 80? Are in sorted order. + 2 what else is true about a 1 through 80? True about 17 17 2017 through 26. What ": [
            3883.7,
            3939.5,
            88
        ],
        "are on the board algorithm descriptions. and We're going to look at some in particular. So the first one we're going to look at is called selection sort we're going to look at this one in a little bit more detail. You can think about it as how to organize your DVD collection. Although does anybody use DVDs anymore? No, right. Okay. Well, anyhow, if you used to use DVDs, ": [
            2322.4,
            2357.2,
            42
        ],
        "cards, there are n factorial different ways to order them. Okay, quick start. Does anybody know how that works? Yeah, you kind of pick an element to to use of the partition and you separate everything that's less than that element and everything that's greater than that element and then you sort each side and put it together. And how do you store each side and you do it recursively? ": [
            3248.6,
            3286.3,
            70
        ],
        "class. Yeah. Okay, cool. Great. Place the biggest bottom card on the table repeat until no cards are left, but you need to like sort them as you go, right. Okay, black hole some outer the name assumption. So this group actually. Ordered the cards not in ascending order of the integers but instead of ascending order of the sums of all the digits. So I guess 7 + 7 ": [
            1640.0,
            1680.6,
            26
        ],
        "compare elements from two sets and put the smaller item in front then move on to the next. Okay. Did I say that right? There's a bunch of stuff here. Anyone anyone want to elaborate? I don't know if I could follow this. Who's who's group merger me? oh-so you should be split up into two sets. okay, and then you can come and then you okay. I say and ": [
            1724.3,
            1787.8,
            28
        ],
        "do we only do it? Why don't we only stopped to their right? Turns out that you only have to go this far because these are the smallest elements. So you always know that the final element is bigger will look into this into more detail. was that we could have yeah we could have but it could have been the case that sent these were switched so we would ": [
            2702.7,
            2732.2,
            52
        ],
        "don't ever have to move it anymore. Can I find the next smallest number which is 20 and interchange it with the second now 17 and 20 are fixed. The next smallest number is 31 interchange with I'm sorry 26 interchange with 93. So these are all set and as you go you can see that you're starting to Put the elements in sorted order. one by one Now, why ": [
            2669.0,
            2702.7,
            51
        ],
        "elements is listed in sorted order. Frequency is CB. How are we doing here? A lot of you are saying all. Some of you were saying fee be sort of seems like the most natural way to sort them right B is ass is sorting them in. ascending order right good. Does anybody have any comments? the least populous Okay. Well, let's go to see then first to see is ": [
            252.0,
            338.7,
            4
        ],
        "false sense of ending. No. ": [
            4107.8,
            4112.6,
            93
        ],
        "going to use this Big O notation, right and that's cuz that's really going to tell you the time it takes how does that scale? How does that change as you change the size of the input? Okay. How is it you think you were going to finish soon or should we? It's there's a lot, huh? Wow, you guys are fast. So, how do you sort two sorted lists? ": [
            2139.5,
            2186.7,
            37
        ],
        "good. You go back. Osoyoos you ordered them in a different way as in we all we did was we just added the sum of a number and then Okay. I guess I never said any particular ordering. right Right. I should have said something. So sorry. I should have said something. Sorry to you might need to rethink. I mean, I guess you're out of work, but you were ": [
            1433.4,
            1499.3,
            22
        ],
        "have had to flip them. kind of depends on any possible ordering Okay, bubble sort so in this one. That's what you all did you compare the cards the the consecutive cards and if you ever have two cards that are out of order then you order them. And what you do is you just do that a bunch of times and every time you do it the biggest card ": [
            2732.2,
            2760.8,
            53
        ],
        "here and we're going to look at this on Tuesday and do the proof and prove that this Loop invariant is true. You're going to see that we need both of these Loop invariants to prove one another we need both of them and then Wait, one more thing one more thing before you all go. Sorry. The last thing is that if I can prove this, why does that ": [
            4044.3,
            4073.0,
            91
        ],
        "here is to write down their description so that in such a way. It's mostly to get you to practice explaining how algorithms work in words. Bubblicious, okay, that's good. Okay good. Thank you. I might call on you to you. Hold on to him for now. What time is it? Okay, great. I might I may call on you again to if I need some clarification, but it looks ": [
            1356.7,
            1433.4,
            21
        ],
        "how would you sort this using selection sort? Okay, so the idea is first find the smallest number and then interchange it with the number in the first position. So the smallest number is 100 interchange that with 15. Okay, here's another example. You can kind of see so find the smallest number 17 interchange it with the first. Okay, and now I'm 17 is in its position, right? You ": [
            2628.5,
            2669.0,
            50
        ],
        "in order. They saw this kind of leaves a lot to the imagination, but we can maybe see it a little bit better if we look at the code. No. This is sort of this is a little bit different than the other ones. It's sort of it. It's a recursive algorithm and it's kind of magic how that works. So, let's go through it. If the lift has just ": [
            3116.5,
            3147.5,
            66
        ],
        "in the worst-case. questions about that what it You still have to do but you know, she's buying something on here to try. It needs to be moved. Then it needs to move somewhere else. You still have to call. Yeah. Write a mic right? Did you hear what he said? So he's saying it might cost a lot but having to actually move makes space for it, but that's ": [
            3522.8,
            3585.4,
            79
        ],
        "invariant invariant means not in means not and variant means change right Loop not change. So there's a bunch of loop invariants. What you need to do is figure out what's the right one to pick that will get you to the correctness. You really want to make progress and you can kind of see that happening in a lot of these algorithms like the the selection sort, you know, ": [
            3752.3,
            3785.8,
            84
        ],
        "is equal to 1 J goes from 1 2 N -1 Thanks. Are you Bubble Up the entire length of the list? And then I is equal to 2. So then you Bubble Up only all the way almost all the way to the entire line and so on and then you keep on going and as you do the each biggest number bubbles to the top 10 example Are ": [
            2793.2,
            2821.2,
            55
        ],
        "is like a mid-level description where it's sort of in a code form kind of but we use we use terms like interchange and minimum instead of actually showing you how to do it. Right? This is nice because it's a little bit easier to understand exactly how to do it and I'm assuming a lot I'm assuming that you everybody knows how to find the minimum of a list. ": [
            2421.9,
            2454.4,
            45
        ],
        "is true about these? They're increasing order. So that's the first the first living variant but what other invariant is there? What is also true about these in every iteration? true about the first T elements They're sorted that's the first iteration. That's the first living variant. What's another loop invariant? there was yep. The T smallest. the elements A1 280 are all smaller than the elements 80 + 1 ": [
            3939.5,
            3989.8,
            89
        ],
        "it and if you've done it correctly the list that will come before it is already in sorted order, right? So you're you're starting it as you. okay bucket sort if there's a way to separate out the numbers or the names or something in it in like different buckets than what you can do is. Distribute them into those buckets and then sort each bucket. Right then you can ": [
            3031.4,
            3065.3,
            63
        ],
        "it's already in its position. Okay questions about that. All right. Next one insertion sort that's what these guys did or here's another what kind of idea you pass the cards from right to left each individual inserting their own car to the correct position as they relayed the pile kind of like what you all did hear. Okay, and other words take an element of a and find out ": [
            2866.6,
            2902.0,
            58
        ],
        "just put the stacks on top of each other, right? Because all the A's are going to go on top of all the bees on top of the season song for these integers. Maybe what you could do is sort them by number of digits write all the two digit numbers go over here all the three digit numbers all the four digit numbers you sort each pile and you ": [
            3065.3,
            3085.5,
            64
        ],
        "like a lower lower level be kind of more like a source code or like a code you give to a computer where you actually write out how to find the minimum Frank so for our purposes we can just kind of Turn this into set a.m. To be the minimum of a I threw a and that what it was. Okay, so let's look at an example How would ": [
            2592.3,
            2628.5,
            49
        ],
        "mean my algorithm will work? Okay good. So this is supposed to be true after every iteration. It's good to be true after the last iteration. And in the last iteration we have that a one through a n or all sorted which is what we want. So that's how we use the loop invariant to show the correctness of the algorithm. Okay. Thank you. Sorry to Give you a ": [
            4073.0,
            4107.8,
            92
        ],
        "measure everything with is how bad does it do in the worst-case because we kind of have to expect the worst. Okay, and so and I'm actually on average if all possible permutations are equally random or equally possible. Then it'll take pencil fixative and square. Okay insertion sort this one also can take linear time big Omega of end in the best-case and that's also if it's already in ": [
            3449.9,
            3490.5,
            77
        ],
        "merge right will definitely talk about that. Okay, I'm going to I'm going to keep on going through some of these slides as you all finish up. The general questions were going to ask about algorithms. and you can think about them as what how why and when okay. So what is the problem we're solving the problem specification in this case. It was given a bunch of random numbers. ": [
            2188.2,
            2222.3,
            38
        ],
        "next week. Is does the strategy scale well to longer list, which of those strategies would you prefer to do if you're going to start the entire? the entire set of all cards and what does that mean? How do we quantify it? How do we how do we say that one? Algorithm is more efficient for bigger lists or for smaller list. Write the complexity and that's where we're ": [
            2105.0,
            2139.5,
            36
        ],
        "number then inserted the next number using binary search search by halves for next open spot sorted in ascending order. Okay. So this is like a insertion sort. And this one also uses insertion sort to sort are numbers given a sort of stack of n numbers except the next number. Search one by one. Where do I insert the next card insert the next card there now? You have ": [
            1885.5,
            1912.0,
            32
        ],
        "of iterations then 3 use the invariants to prove correctness. This is just kind of like a very short two sentence line basically saying that since the loop invariant is true after every iteration then it must be true after the last iteration and after that it should imply that the algorithm is correct. Okay, so we're going to start on this proof for selection sort were going to use ": [
            3818.4,
            3848.8,
            86
        ],
        "of sorted order so that you can easily input the scores right? Also, another nice thing about sorting is that it it collects all the duplicates. So if you want to find duplicates, you can sort it first and then look through the list and find them right because they're all going to get close to each other. It's easier to access data when it's sorted because you know exactly ": [
            641.0,
            665.9,
            11
        ],
        "okay. Sorted by the number of fours in the digits. Okay. The first one has one in the second three-year. In some other order some things that are a little bit more rigorous so that basically you want to ordering so that when you sort it, there's no ambiguity. It's sorta. It's either sorted or not. Right? And if you do it by the fours, then that you need some ": [
            377.8,
            420.1,
            6
        ],
        "one element then return it because it's already sorted otherwise divided into two lists sort each list and then merge them together. Okay, how do you merge them together? We're going to talk about that in a little bit more detail. But the idea is you just if they're already sorted. You just compare the lowest the lowest cards of each stack and you pick the lower one, right and ": [
            3147.5,
            3173.5,
            67
        ],
        "order right you really want something where? For example in the ascending order you want it so that this one is less than that is less than that is less than that and you have transitivity. So 10 is also less than 30 1040 so that sort of ordering. What is it? The times that they can be evenly divided by 5. Play what do you mean evenly divided by ": [
            464.4,
            508.1,
            8
        ],
        "ordering. This is a surprisingly fast topic studied in computer science as you probably have imagined how to best store a set of objects. And we're going to look at a few different sorting algorithms today and talk about what are their advantages and disadvantages. Let me get my I thought I started the clicker. Okay, here we go. Get your clickers out. Now, which of the following collections of ": [
            209.6,
            252.0,
            3
        ],
        "other sorting mechanism for these three, right and then ones by threes or something like that man anybody else? There's a particular order that I'm thinking of. That's what somebody else said. Yeah, that's that definitely works. I mean that and that is, you know enough information to sort it in that order, but it's not like it's not really I don't know what you'd call it a linear sorting ": [
            420.1,
            464.4,
            7
        ],
        "probably the best cuz it's it's really shuffled. Okay, let's move on. Okay, we're going to go from how how do you do it? What does the algorithm description to why why does algorithm work? Okay, and so for loot-based algorithms the strategy for these proofs of correctness is using a loop invariant. It's basically something that doesn't change after every iteration of the loop. What stays the same Loop ": [
            3718.4,
            3752.3,
            83
        ],
        "put one pile on top of the other. How do you sort them within the piles? Well, you can use maybe one of these other sorting methods or if there are very few. You could just kind of figure it out. Okay. So another one merge sort we split into two groups organized each of the groups then get back together and figure out how to enter leave the groups ": [
            3085.5,
            3116.5,
            65
        ],
        "runtime analysis and loop invariants there like a really nice example to show that kind of stuff some algorithms are better than others. What does that mean? How does one how is one better than another? Well, here's a table of a bunch of algorithms Racine and what are their run times? Okay, so selection store you find the minimum and put it in the front in the worst-case. I ": [
            3346.7,
            3376.5,
            73
        ],
        "should be in the best case. There's going to be big O big O Negative N squared in the worst case is going to be Big O of N squared. So it's basically Big O of N squared big fat event Square in all cases. Okay, bubble sort in the best case we can get it to run in big Omega of end-time. What what would need to be true ": [
            3376.5,
            3398.8,
            74
        ],
        "sitting at his desk. I don't know if you got y'all saw him to start but maybe this is exactly how he wants his room. He wants the starfish in his cupboard or his dresser. He wants the ice cream cake on here and he wants his Playing cards in his lamp. Maybe he has some sort of ordering. So sorting is nothing unless you give it some sort of ": [
            182.2,
            209.6,
            2
        ],
        "so we'll talk about this one in more detail. Okay, we're going to think about describing algorithms in different layers. Okay. So the first one we started out with this is kind of like a high-level description. It gives you kind of a sense of what the algorithm is doing. The steps are not completely fleshed-out. But at least you know what it's supposed to try to do. So here ": [
            2390.6,
            2421.9,
            44
        ],
        "some sort of description to so that you know how so that you know how to do it in general. Right? Did you guys just use bubble sort? Is it like this? So then right and then you keep on doing that and what would happen is the twelve gets kind of bubbled up to the top and so on we're going to actually talk about this one took one ": [
            1854.6,
            1885.5,
            31
        ],
        "sort them but just don't put them together and sort them willy-nilly I want you to think about your strategy of sorting them. Okay, so maybe like these first four rows or first three rows or just make sure you have like enough people so that the the the Sorting is is is non-trivial. And think about it and what I want you to do read up here. I want ": [
            750.5,
            783.2,
            15
        ],
        "sorted order because it would be very fast to figure out where to put the next element. Okay, so then merge sort is is the one that sort of stands out especially because of this it's worth case run time is end login, which is actually the best you can do for sorting algorithms. that use comparisons play some Richard is great merch store is faster than all of these ": [
            3490.5,
            3522.8,
            78
        ],
        "sorted order. So then you go to the next element which is 2 and you put it in its place, which is before the four. Next element is one you put it in its place among these everything before it to put it in its place which is going to be in between here and so on so you just basically inserting each element into the list that comes before ": [
            3005.0,
            3031.4,
            62
        ],
        "supposed to order the numbers. Alphabetically. Did anybody do that? Yeah, like in the other slide. Nobody did that. What did you guys do ascending order now? I'm just playing that's that's what I expected a sentence. Arthur he's doing an example. Wow. But you did it in a different interpretation. So you did not doing it in ascending order. You did not do it and it's in ascending order. ": [
            1499.3,
            1551.0,
            23
        ],
        "than one group. Right? And then a lot of these have the sense that if you can sort a bunch of smaller list, it's easier for for you to get the whole this sorted right kind of the theme. okay, this one is just a An example and an example is often a really nice way to really understand an algorithm right? But also it would be nice to have ": [
            1823.9,
            1854.6,
            30
        ],
        "that as our example. Kate this is how it works. This is the example that we've seen. And the loop invariant that we're going to use has something to do with how how many elements are in sorted order after each iteration after the first iteration one element is in sorted order right after the second order after the 33 and so in general after the teeth interation T elements ": [
            3848.8,
            3883.7,
            87
        ],
        "the biggest number will bubble to the top. And so then the second biggest number above it to the second most in the third and fourth and so on. Best of this is bubble sort. you have a loop that goes from 1 to n -1 and then a loop that goes from 1 to n minus i k so the first Loop the first live does first Loop where ": [
            2760.8,
            2793.2,
            54
        ],
        "the name of your algorithm if you like. Merge by like that. Assumption, all right. Back, right? Okay. We did merge sort also. Is that a different group? Okay. combinatorics I so right your algorithm. merge sort but with hands or I'm going to have to ask you to explain that when we get when we get done with this. And that is your description of your algorithm. The point ": [
            1300.3,
            1356.7,
            20
        ],
        "them. Yes. Are you still working on it? Okay. Eric Walker You guys already saw yours or your part of this group? Okay. So those of you who have finished sorting, I want you to send one representative up to the board and write down your method and then you guys can join in when you're okay. So who's the representative from this group? Okay. How about from this group? ": [
            1137.3,
            1226.2,
            18
        ],
        "then it's done and you can and you can be done and this can happen in the beginning or it can happen in the middle. Or maybe it happens in the end. But this is this is nice that kind of gives you a away to quit if it's already short. In the worst-case though. It's going to take in squared and this is usually the The metric that we ": [
            3429.1,
            3449.9,
            76
        ],
        "then the idea is go through and find the smallest value and put it into the front find the smallest of there or the find the smallest of the remaining ones put it next to that and keep on going. Put another way. Use find men smallest element out of the last k-elements swap this element with the first and then swap it with the second and so on. Okay, ": [
            2357.2,
            2390.6,
            43
        ],
        "there might be too many, huh? I never done this before so I don't know how long this is supposed to take. Why you're working on that? I'm about to take a picture of this so that we can post it on Piazza. So you all have you can see it and I'll set my thing up you think this is going to work? Okay, and as you're doing it, ": [
            1961.1,
            2069.9,
            34
        ],
        "these bullet point. The strategy is a strategy clear does the strategy always work and does the strategy scale well to longer list. Okay, she'll find a group of 15 to 20 people and we're not going to do the names this time. We're going to do numbers. Okay, can you help me hand out some numbers? Yeah, one for each person and then get yourself into a group and ": [
            711.5,
            750.5,
            14
        ],
        "through a n I kind of get this break at each one of these you're separating out the smaller number from the bigger numbers. Peso to is that a 1 through 80. are smallest compared to 80 plus compared to the whole list, but another way to say it. Is that a 1 through 80 are smaller than 80 + 1 through a.m. right Okay, so we're going to end ": [
            3989.8,
            4044.3,
            90
        ],
        "to check. Okay, just hand them over. I'm sorry that you were you were. I am sorry that you were given that task. I think I underestimated. How complicated it is to sort, right? The very end is not fun, right? There's a lot in here how many students are in here right now over a hundred, right? There's so many different combinations. You could have put this in right? ": [
            2506.2,
            2536.9,
            47
        ],
        "to rearrange them so that they're in ascending order. The values can be any type of for Simplicity will use integers with ascending order. Okay, that's what this might take a while, huh? Okay, so that's the what and for what really the main things you need are. input And desired I desired output. Okay. The next thing is how these were your approaches? These are all the things that ": [
            2279.1,
            2322.4,
            41
        ],
        "what you're ordering is. Okay good. Why would you want to sort there's a lot of different reasons but here's one that you know is very close to what I have to do. Maybe not So Much Anymore now, we have gradescope but before gradescope, we have a bunch of papers and if you had to input all the scores of papers, it's better to have them in some sort ": [
            612.2,
            641.0,
            10
        ],
        "what? Descending order so it is sorted in such a way, right? I mean It still is sorted but it's sorted with the order operation being, you know, the first one is greater than the next one is greater than it is. It just completely random out of order or is there some order to it? Largest smallest second largest second smallest. Okay, that works. In a tree like pattern, ": [
            338.7,
            377.8,
            5
        ],
        "where it belongs relative to the element before it. Shift everything back to make room and put the element is proper place. Now that this element has been inserted where it belongs do the same for the next element. And here's sort of a mid-level description. And notice that I'm giving sort of a sentence instead of actual code just saying for Jay from 2 to n. Right. Why did ": [
            2902.0,
            2929.7,
            59
        ],
        "where to find it. We're going to talk about this a little bit later when we start talking about searching algorithms. If you want to search for a particular value much easier or it it's much faster. If you know that you are list is already been sorted. Okay. So how do you sort say you're organizing an event and have a bunch of cards with first names of people ": [
            665.9,
            687.9,
            12
        ],
        "who will be attending your event. You want to sort the names alphabetically, so they're easier to distribute. How do you put them in order? So I'm going to change this up a bit and have it be Instead of sorting names we're going to be sorting numbers. Those are easier to stored or easier to figure out. Okay. And what I want you to do is think about all ": [
            687.9,
            711.5,
            13
        ],
        "why does it work in all possible inputs? When do we get an answer? This is going to be the complexity. How many operations do you expect to do before you get your result so that's what these these four things are and we're going to kind of talk about all of them as we look at different algorithms. So this is the Sorting specification giving a list we want ": [
            2248.8,
            2279.1,
            40
        ],
        "you guys can do this at home? Let's just here's a here's one that's already worked out. Okay, so you compare 3 and 6 they're in there there in ascending order. So you leave them you go to the next to 6 and 1 they're out of order. So you swap them right then go to the next to 6 and 4 they're out of order. So you swap them. ": [
            2821.2,
            2841.7,
            56
        ],
        "you just keep on doing that and then that will build the sorted list. The magic comes in. How did we sort those two piles? What is it? With recursion Yeah, you sort it by using the algorithm that you're trying to sort them with a stuff kind of like this weird. Recursive idea. We're going to talk about it in more detail for a bit. Later. Okay, good now. ": [
            3173.5,
            3209.0,
            68
        ],
        "you keep on merging the sets that way. Okay, good. That's like emerge sort. Okay, torex. Short amounts for roads individually from highest to lowest then combining compared to determine final order my question is how did you sort this? is this just figure it out just like This is fine because you know, this is good. What you're doing is you're you're splitting the tasks between kind of more ": [
            1787.8,
            1823.9,
            29
        ],
        "you to have one person write up a clear English description of how did you sort these? What was your method something that somebody else could follow 2345 Carol just give you guys a stack and you can pass them on. Did you guys get any yet? Are you running out? this one Oh, there's not enough in each line. Raise your hand if you still haven't gotten a number. ": [
            783.2,
            833.7,
            16
        ],
        "you're kind of like building the sorted list one by one by chip picking the minimum element over and over. Okay. So how do we do a loop invariant proof? It's a three-step proof. First is to get a loop invariant appropriate Loop invariant. state of precisely Okay, next is to prove that it's invariant and you have to do this using induction. And that's be true after any number ": [
            3785.8,
            3818.4,
            85
        ]
    },
    "File Name": "Math_Algorithms___System_Analysis___A00___Jones__Miles_E___Spring_2019-lecture_6.flac",
    "Full Transcript": "Are you going to let me see you tonight?  Take a nap.  All right.  Let's get started. They buddy have any questions before we begin.  No.  Which room is the midterm in?  Anybody know?  I'm sorry.  Solis  it's on the  what is that called the schedule of classes?  Webb Bridge, yeah.  We should make a post of it though on Piazza.  Remind everybody.  So let's get started or doing sorting algorithms today. So let's take a look at you know certain things right? So here we have an unordered mass and here we have a very ordered set of dolls.  When we talked about ordered, what do we mean? Well, this is ordered by height or size right in decreasing order. This made it could be be considered to be in order.  There's like there's this child in here. He's sitting at his desk. I don't know if you got y'all saw him to start but maybe this is exactly how he wants his room. He wants the starfish in his cupboard or his dresser. He wants the ice cream cake on here and he wants his  Playing cards in his lamp. Maybe he has some sort of ordering. So sorting is nothing unless you give it some sort of ordering.  This is a surprisingly fast topic studied in computer science as you probably have imagined how to best store a set of objects.  And we're going to look at a few different sorting algorithms today and talk about what are their advantages and disadvantages. Let me get my  I thought I started the clicker.  Okay, here we go.  Get your clickers out. Now, which of the following collections of elements is listed in sorted order.  Frequency is CB.  How are we doing here? A lot of you are saying all.  Some of you were saying fee be sort of seems like the most natural way to sort them right B is ass is sorting them in.  ascending order  right  good.  Does anybody have any comments?  the least populous  Okay. Well, let's go to see then first to see is what?  Descending order so it is sorted in such a way, right? I mean  It still is sorted but it's sorted with the order operation being, you know, the first one is greater than the next one is greater than it is. It just completely random out of order or is there some order to it?  Largest smallest second largest second smallest. Okay, that works.  In a tree like pattern, okay.  Sorted by the number of fours in the digits.  Okay.  The first one has one in the second three-year.  In some other order some things that are a little bit more rigorous so that basically you want to ordering so that when you sort it, there's no ambiguity. It's sorta. It's either sorted or not. Right? And if you do it by the fours, then that you need some other sorting mechanism for these three, right and then ones by threes or something like that man anybody else?  There's a particular order that I'm thinking of.  That's what somebody else said. Yeah, that's that definitely works. I mean that and that is, you know enough information to sort it in that order, but it's not like it's not really  I don't know what you'd call it a linear sorting order right you really want something where?  For example in the ascending order you want it so that this one is less than that is less than that is less than that and you have transitivity. So 10 is also less than 30 1040 so that sort of ordering.  What is it?  The times that they can be evenly divided by 5.  Play what do you mean evenly divided by 5 two times?  Okay.  25 is 5 Square pretty good. I never heard that one. Okay so number.  5 *  evenly  divided  I-5 anybody else  I could be I don't know.  okay, what I was thinking was  You all ready for this?  all depends on how you  Well 42 starts with an F 10 starts with a t t e n.  So all depends on what you how you define what you're ordering is.  Okay good.  Why would you want to sort there's a lot of different reasons but here's one that you know is very close to what I have to do. Maybe not So Much Anymore now, we have gradescope but before gradescope, we have a bunch of papers and if you had to input all the scores of papers, it's better to have them in some sort of sorted order so that you can easily input the scores right? Also, another nice thing about sorting is that it it collects all the duplicates. So if you want to find duplicates, you can sort it first and then look through the list and find them right because they're all going to get close to each other.  It's easier to access data when it's sorted because you know exactly where to find it. We're going to talk about this a little bit later when we start talking about searching algorithms. If you want to search for a particular value much easier or it it's much faster. If you know that you are list is already been sorted.  Okay. So how do you sort say you're organizing an event and have a bunch of cards with first names of people who will be attending your event. You want to sort the names alphabetically, so they're easier to distribute. How do you put them in order? So I'm going to change this up a bit and have it be  Instead of sorting names we're going to be sorting numbers. Those are easier to stored or easier to figure out. Okay. And what I want you to do is think about all these bullet point. The strategy is a strategy clear does the strategy always work and does the strategy scale well to longer list.  Okay, she'll find a group of 15 to 20 people and we're not going to do the names this time.  We're going to do numbers.  Okay, can you help me hand out some numbers?  Yeah, one for each person and then get yourself into a group and sort them but just don't put them together and sort them willy-nilly I want you to think about your strategy of sorting them.  Okay, so maybe like these first four rows or first three rows or just make sure you have like enough people so that the the the Sorting is is is non-trivial.  And think about it and what I want you to do read up here. I want you to have one person write up a clear English description of how did you sort these? What was your method something that somebody else could follow  2345 Carol just give you guys a stack and you can pass them on.  Did you guys get any yet?  Are you running out?  this one  Oh, there's not enough in each line.  Raise your hand if you still haven't gotten a number.  Are you?  Alright, does anybody have any extras?  Are you need some more here? Just getting from your neighbor there. Alright, so you guys need some.  O none of y'all got any.  alright, so  working group so like these sections, okay.  And does anybody understand what you're doing?  Okay.  Ready go.  Do you have any leftover?  How do you spell restaurant?  How's the weather?  Sorry.  Okay.  You guys all sort them.  Yes.  Are you still working on it? Okay.  Eric Walker  You guys already saw yours or your part of this group?  Okay. So those of you who have finished sorting, I want you to send one representative up to the board and write down your method and then you guys can join in when you're okay. So who's the representative from this group?  Okay. How about from this group?  Okay. How about from this this area?  Are you guys had a big group?  Okay, cool. And then from over there?  Okay, start start by writing your group name.  And then write down your algorithm.  What's your group name?  Your group name is seven.  Okay.  back left corner  black hole  song I like that. All right.  Hello neighbor algorithm.  It could be your group name could be the same as the name of your algorithm if you like.  Merge by like that.  Assumption, all right.  Back, right? Okay.  We did merge sort also.  Is that a different group? Okay.  combinatorics  I so right your algorithm.  merge sort but with hands  or I'm going to have to ask you to explain that when we get when we get done with this.  And that is your description of your algorithm.  The point here is to write down their description so that in such a way.  It's mostly to get you to practice explaining how algorithms work in words.  Bubblicious, okay, that's good. Okay good. Thank you. I might call on you to you. Hold on to him for now.  What time is it?  Okay, great. I might I may call on you again to if I need some clarification, but  it looks good.  You go back.  Osoyoos you ordered them in a different way  as in we all we did was we just added the sum of a number and then  Okay.  I guess I never said any particular ordering.  right  Right. I should have said something. So sorry. I should have said something. Sorry to you might need to rethink. I mean, I guess you're out of work, but you were supposed to order the numbers. Alphabetically. Did anybody do that?  Yeah, like in the other slide.  Nobody did that. What did you guys do ascending order now? I'm just playing that's that's what I expected a sentence.  Arthur he's doing an example.  Wow.  But you did it in a different interpretation. So you did not doing it in ascending order.  You did not do it and it's in ascending order.  What is not ascending order in terms of how the numbers are?  And why did you choose to do it that way?  I had an epiphany and then I'm going to say okay and then people started listening to you.  Call Becca.  Cuz like I don't want to do the same store or store or like collections or do you still need to sort them after you do it?  Okay. Thank you.  Oh, no, just hold on to him for now  Okay.  Talk about it. Just if you want to shout out if I'm if I'm explaining it wrong then let me know. Okay, so group 7 merge sort with hands distribute one card each person each person with a card finds another with cards place the big that is kind of like what we did the first day of class.  Yeah. Okay, cool.  Great.  Place the biggest bottom card on the table repeat until no cards are left, but you need to like sort them as you go, right.  Okay, black hole some outer the name assumption. So this group actually.  Ordered the cards not in ascending order of the integers but instead of ascending order of the sums of all the digits. So I guess 7 + 7 + 7 is 21 so that'll be bigger than 1 + 3 which is 4  Okay, so this is how how they ordered it, but there's nothing on here telling me how did you sort it?  Okay, so they just had to figure it out.  Okay, I like that. It works for small values. Okay. Merge me.  We did merge sort also, okay starting from the beginning of each set compare elements from two sets and put the smaller item in front then move on to the next. Okay. Did I say that right?  There's a bunch of stuff here.  Anyone anyone want to elaborate?  I don't know if I could follow this.  Who's who's group merger me?  oh-so  you should be split up into two sets.  okay, and then you can come and then you  okay.  I say and you keep on merging the sets that way.  Okay, good. That's like emerge sort. Okay, torex.  Short amounts for roads individually from highest to lowest then combining compared to determine final order my question is how did you sort this?  is this just figure it out just like  This is fine because you know, this is good. What you're doing is you're you're splitting the tasks between kind of more than one group. Right? And then a lot of these have the sense that if you can sort a bunch of smaller list, it's easier for for you to get the whole this sorted right kind of the theme.  okay, this one is just a  An example and an example is often a really nice way to really understand an algorithm right? But also it would be nice to have some sort of description to so that you know how so that you know how to do it in general. Right? Did you guys just use bubble sort?  Is it like this?  So then right and then you keep on doing that and what would happen is the twelve gets kind of bubbled up to the top and so on we're going to actually talk about this one took one number then inserted the next number using binary search search by halves for next open spot sorted in ascending order. Okay. So this is like a insertion sort.  And this one also uses insertion sort to sort are numbers given a sort of stack of n numbers except the next number.  Search one by one.  Where do I insert the next card insert the next card there now? You have a sort of stack of number and + 1 numbers?  wow, unsorted short  Okay, so these are all great and thank you for doing this activity with me. I do see kind of a theme at least with some of them where it says kind of Stuart Little groups and then put them together. So now put all the cards together ready. I'm going to time y'all ready go.  Yeah, there might be too many, huh?  I never done this before so I don't know how long this is supposed to take.  Why you're working on that? I'm about to take a picture of this so that we can post it on Piazza. So you all have you can see it and I'll set my thing up you think this is going to work?  Okay, and as you're doing it, I want to stop want you to think about these.  These props. Where are they?  Okay, so we had the strategies is the strategy clear. I'm talking about the strategies on the board where they clear a little clearer than others.  Does the strategy always work? Well, I think most of them would work all the time and this is kind of  What we're going to look at today and next week.  Is does the strategy scale well to longer list, which of those strategies would you prefer to do if you're going to start the entire?  the entire set of all cards  and what does that mean? How do we quantify it? How do we how do we say that one? Algorithm is more efficient for bigger lists or for smaller list.  Write the complexity and that's where we're going to use this Big O notation, right and that's cuz that's really going to tell you the time it takes how does that scale? How does that change as you change the size of the input?  Okay.  How is it you think you were going to finish soon or should we?  It's there's a lot, huh?  Wow, you guys are fast.  So, how do you sort two sorted lists?  merge  right  will definitely talk about that.  Okay, I'm going to I'm going to keep on going through some of these slides as you all finish up. The general questions were going to ask about algorithms.  and you can think about them as what how why and when  okay. So what is the problem we're solving the problem specification in this case. It was given a bunch of random numbers. How do you put them in a sending order?  How do you solve the problem is to that's the algorithm description. How do you go about doing it? You need a step-by-step unambiguous set of instructions in order to start with the input and get the desired output.  Why do they step solve the problem? This is the correctness proof. We're going to show why is your algorithm work? And why does it work in all possible inputs?  When do we get an answer? This is going to be the complexity. How many operations do you expect to do before you get your  result  so that's what these these four things are and we're going to kind of talk about all of them as we look at different algorithms.  So this is the Sorting specification giving a list we want to rearrange them so that they're in ascending order. The values can be any type of for Simplicity will use integers with ascending order.  Okay, that's what this might take a while, huh?  Okay, so that's the what and for what really the main things you need are.  input  And desired I desired output.  Okay. The next thing is how these were your approaches? These are all the things that are on the board algorithm descriptions.  and  We're going to look at some in particular. So the first one we're going to look at is called selection sort we're going to look at this one in a little bit more detail.  You can think about it as how to organize your DVD collection.  Although does anybody use DVDs anymore?  No, right. Okay. Well, anyhow, if you used to use DVDs, then the idea is go through and find the smallest value and put it into the front find the smallest of there or the find the smallest of the remaining ones put it next to that and keep on going.  Put another way.  Use find men smallest element out of the last k-elements swap this element with the first and then swap it with the second and so on.  Okay, so we'll talk about this one in more detail.  Okay, we're going to think about describing algorithms in different layers.  Okay. So the first one we started out with this is kind of like a high-level description. It gives you kind of a sense of what the algorithm is doing. The steps are not completely fleshed-out. But at least you know what it's supposed to try to do. So here is like a mid-level description where it's sort of in a code form kind of but we use we use terms like interchange and minimum instead of actually showing you how to do it. Right? This is nice because it's a little bit easier to understand exactly how to do it and I'm assuming a lot I'm assuming that you everybody knows how to find the minimum of a list. But if I assume that then this should be pretty clear.  Iterate from 1 2 N -1 set a.m. To be the minimum interchange a inam and then that should work.  Okay, how's it going over there?  Okay, you can you can take a break.  Yeah, I don't know if it's worth it.  You're the you're the only one working.  Oh wow.  You going to show up now? I have to check.  Okay, just hand them over. I'm sorry that you were you were.  I am sorry that you were given that task. I think I underestimated. How complicated it is to sort, right?  The very end is not fun, right? There's a lot in here how many students are in here right now over a hundred, right?  There's so many different combinations. You could have put this in right?  Well, you guys did pretty good.  Did y'all find any repeats?  Yeah.  I made these today if you couldn't smell the ink on them already.  I just tried to put some random numbers down, but I guess I failed out of order 47.  Okay. Anyhow.  I'll use those for next quarter.  Okay, so this is selection sort and if we want to go kind of one level deeper into the like a lower lower level be kind of more like a source code or like a code you give to a computer where you actually write out how to find the minimum Frank so  for our purposes we can just kind of  Turn this into set a.m. To be the minimum of a I threw a  and that what it was.  Okay, so let's look at an example How would how would you sort this using selection sort?  Okay, so the idea is first find the smallest number and then interchange it with the number in the first position. So the smallest number is 100 interchange that with 15.  Okay, here's another example.  You can kind of see so find the smallest number 17 interchange it with the first. Okay, and now I'm 17 is in its position, right? You don't ever have to move it anymore.  Can I find the next smallest number which is 20 and interchange it with the second now 17 and 20 are fixed. The next smallest number is 31 interchange with I'm sorry 26 interchange with 93. So these are all set and as you go you can see that you're starting to  Put the elements in sorted order.  one by one  Now, why do we only do it? Why don't we only stopped to their right?  Turns out that you only have to go this far because these are the smallest elements. So you always know that the final element is bigger will look into this into more detail.  was that  we could have yeah we could have but it could have been the case that sent these were switched so we would have had to flip them.  kind of depends on any possible ordering  Okay, bubble sort so in this one. That's what you all did you compare the cards the the consecutive cards and if you ever have two cards that are out of order then you order them.  And what you do is you just do that a bunch of times and every time you do it the biggest card the biggest number will bubble to the top. And so then the second biggest number above it to the second most in the third and fourth and so on.  Best of this is bubble sort.  you have a loop that goes from 1 to n -1 and then a loop that goes from 1 to n minus i k so the first Loop  the first live does  first Loop where is equal to 1 J goes from 1 2 N -1  Thanks. Are you Bubble Up the entire length of the list?  And then I is equal to 2. So then you Bubble Up only all the way almost all the way to the entire line and so on and then you keep on going and as you do the each biggest number bubbles to the top 10 example  Are you guys can do this at home? Let's just here's a here's one that's already worked out.  Okay, so you compare 3 and 6 they're in there there in ascending order. So you leave them you go to the next to 6 and 1 they're out of order. So you swap them right then go to the next to 6 and 4 they're out of order. So you swap them. Then you go to the next to 6 and 2 they're out of order. So you swap them value is the biggest the biggest will always bubble up to the top. That's kind of what makes the algorithm work.  Continue run through it again. And you see that for bubbles up to the top and then three and then two and then one you don't have to do one because it's already in its position.  Okay questions about that.  All right.  Next one insertion sort that's what these guys did or here's another what kind of idea you pass the cards from right to left each individual inserting their own car to the correct position as they relayed the pile kind of like what you all did hear.  Okay, and other words take an element of a and find out where it belongs relative to the element before it.  Shift everything back to make room and put the element is proper place. Now that this element has been inserted where it belongs do the same for the next element.  And here's sort of a mid-level description.  And notice that I'm giving sort of a sentence instead of actual code just saying for Jay from 2 to n.  Right. Why did I start at 2? Why don't I start at 1?  Write the first card in your list will always be sorted a sorted list in itself right to start with the second card and compare it to the first put those if you know find its position and so on find where aj belongs in the list a 1/2 AJ -1 right and then put it in its place.  Here's a much more complicated or lower lower lower level where you actually go through and first find out where it goes and then you make room for it and put it where it needs to be.  okay, so this is  find where it goes.  make room  and insert  Okay. Do I have an example of this? Okay, good. Yeah, so here's your original list.  The first element is already in sorted order. So then you go to the next element which is 2 and you put it in its place, which is before the four.  Next element is one you put it in its place among these everything before it to put it in its place which is going to be in between here and so on so you just basically inserting each element into the list that comes before it and if you've done it correctly the list that will come before it is already in sorted order, right? So you're you're starting it as you.  okay bucket sort  if there's a way to separate out the numbers or the names or something in it in like different buckets than what you can do is.  Distribute them into those buckets and then sort each bucket. Right then you can just put the stacks on top of each other, right? Because all the A's are going to go on top of all the bees on top of the season song for these integers. Maybe what you could do is sort them by number of digits write all the two digit numbers go over here all the three digit numbers all the four digit numbers you sort each pile and you put one pile on top of the other.  How do you sort them within the piles? Well, you can use maybe one of these other sorting methods or if there are very few. You could just kind of figure it out.  Okay.  So another one merge sort we split into two groups organized each of the groups then get back together and figure out how to enter leave the groups in order.  They saw this kind of leaves a lot to the imagination, but we can maybe see it a little bit better if we look at the code.  No.  This is sort of this is a little bit different than the other ones. It's sort of it. It's a recursive algorithm and it's kind of magic how that works. So, let's go through it.  If the lift has just one element then return it because it's already sorted otherwise divided into two lists sort each list and then merge them together. Okay, how do you merge them together? We're going to talk about that in a little bit more detail. But the idea is you just if they're already sorted. You just compare the lowest the lowest cards of each stack and you pick the lower one, right and you just keep on doing that and then that will build the sorted list.  The magic comes in. How did we sort those two piles?  What is it?  With recursion Yeah, you sort it by using the algorithm that you're trying to sort them with a stuff kind of like this weird.  Recursive idea. We're going to talk about it in more detail for a bit. Later.  Okay, good now.  Some other ones BOGO sort. Has anybody heard that?  How does that work?  You throw the cards in the air and then you hope that they land in the correct order.  And then what if they don't land in the correct order?  You do it again, right?  How long is that going to take?  A long time the expected run time as what?  Factorial because if you think about the cards, there are n factorial different ways to order them.  Okay, quick start. Does anybody know how that works?  Yeah, you kind of pick an element to to use of the partition and you separate everything that's less than that element and everything that's greater than that element and then you sort each side and put it together.  And how do you store each side and you do it recursively?  Hey, how about binary search tree traversal?  Did you guys do binary search trees in 30 or 12 or 15 or 8 or l or?  Well, okay. So this one is basically you you build a binary binary search tree and then you kind of pluck everything off or you kind of read them in order and they're going to be in sorted order if you do it that way.  Okay, we'll come back to these. Why are there so many algorithms. Well mostly for practice.  We're home so that you could do well on the homework and the exams and maybe there's a job interview that I'll ask you some sort of sorting question. So you should know what they are. They're really good models for what we're going to be doing in this class, which is teaching about runtime analysis and loop invariants there like a really nice example to show that kind of stuff some algorithms are better than others. What does that mean? How does one how is one better than another?  Well, here's a table of a bunch of algorithms Racine and what are their run times?  Okay, so selection store you find the minimum and put it in the front in the worst-case. I should be in the best case. There's going to be big O big O Negative N squared in the worst case is going to be Big O of N squared. So it's basically Big O of N squared big fat event Square in all cases.  Okay, bubble sort in the best case we can get it to run in big Omega of end-time. What what would need to be true about the input for that to be for that to happen?  It's already sorted.  Okay, and so you can put like a a break in the code and check to see if it's already sorted because remember how bubble sort works is you just compare every consecutive pair of integers, right? If they're already in sorted order then you didn't do any swaps. So if you didn't do any swaps, then it's done and you can and you can be done and this can happen in the beginning or it can happen in the middle. Or maybe it happens in the end. But this is this is nice that kind of gives you a away to quit if it's already short.  In the worst-case though. It's going to take in squared and this is usually the  The metric that we measure everything with is how bad does it do in the worst-case because we kind of have to expect the worst.  Okay, and so and I'm actually on average if all possible permutations are equally random or equally possible.  Then it'll take pencil fixative and square.  Okay insertion sort this one also can take linear time big Omega of end in the best-case and that's also if it's already in sorted order because it would be very fast to figure out where to put the next element.  Okay, so then merge sort is is the one that sort of stands out especially because of this it's worth case run time is end login, which is actually the best you can do for sorting algorithms.  that use comparisons  play some Richard is great merch store is faster than all of these in the worst-case.  questions about that  what it  You still have to do but you know, she's buying something on here to try. It needs to be moved. Then it needs to move somewhere else. You still have to call.  Yeah.  Write a mic right? Did you hear what he said?  So he's saying it might cost a lot but having to actually move makes space for it, but that's a good point in that. It'll probably cut down on the on the searching cost.  good point  like why is the average actually equal to the worst case?  so  so how would it how is it defined is defined to be.  You basically run the algorithm on every single possible permutation and then you show that and then you take the average of all of the run times.  And run * meaning really really for sorting algorithms the best measure for how long they take is number of comparisons.  So the number of comparisons is big state of N squared for average case.  Yes.  Now you still have to do it because there's no check to see if it's sorted yet.  I suppose you could check it first and then if it's not sorted run merch store.  No, just bien.  Biggest to check to check to see if something sorted will take linear time.  Yeah, so yeah, and maybe you could I don't know maybe you can do a mixture of these things and say well if it's very close to sorted by some measure. Maybe I'll just use bubble sort to kind of fixed the the rest of them.  But if it's all kind of crazy random then merchsource probably the best cuz it's it's really shuffled.  Okay, let's move on.  Okay, we're going to go from how how do you do it? What does the algorithm description to why why does algorithm work? Okay, and so for loot-based algorithms the strategy for these proofs of correctness is using a loop invariant. It's basically something that doesn't change after every iteration of the loop. What stays the same Loop invariant invariant means  not in means not and variant means change right Loop not change.  So there's a bunch of loop invariants. What you need to do is figure out what's the right one to pick that will get you to the correctness. You really want to make progress and you can kind of see that happening in a lot of these algorithms like the the selection sort, you know, you're kind of like building the sorted list one by one by chip picking the minimum element over and over.  Okay. So how do we do a loop invariant proof? It's a three-step proof. First is to get a loop invariant appropriate Loop invariant.  state of precisely  Okay, next is to prove that it's invariant and you have to do this using induction.  And that's be true after any number of iterations then 3 use the invariants to prove correctness. This is just kind of like a very short two sentence line basically saying that since the loop invariant is true after every iteration then it must be true after the last iteration and after that it should imply that the algorithm is correct.  Okay, so we're going to start on this proof for selection sort were going to use that as our example.  Kate this is how it works. This is the example that we've seen.  And the loop invariant that we're going to use has something to do with how how many elements are in sorted order after each iteration after the first iteration one element is in sorted order right after the second order after the 33 and so in general after the teeth interation T elements are in sorted order.  Okay, here's all this stuff again. We already saw this.  Okay.  So, let me just write it here.  after the teeth  iteration  And actually there's going to be to Loop invariants that we're going to use one. Is that a 1 through 80?  Are in sorted order.  + 2  what else is true about a 1 through 80?  True about 17 17 2017 through 26. What is true about these?  They're increasing order. So that's the first the first living variant but what other invariant is there? What is also true about these in every iteration?  true about the first T elements  They're sorted that's the first iteration. That's the first living variant. What's another loop invariant?  there was  yep. The T smallest.  the elements A1 280 are all smaller than the elements 80 + 1 through a n  I kind of get this break at each one of these you're separating out the smaller number from the bigger numbers.  Peso to is that a 1 through 80.  are smallest  compared to 80 plus compared to the whole list, but another way to say it. Is that a 1 through 80 are smaller than 80 + 1 through a.m.  right  Okay, so  we're going to end here and we're going to look at this on Tuesday and do the proof and prove that this Loop invariant is true. You're going to see that we need both of these Loop invariants to prove one another we need both of them and then  Wait, one more thing one more thing before you all go. Sorry. The last thing is that  if I can prove this, why does that mean my algorithm will work?  Okay good. So this is supposed to be true after every iteration. It's good to be true after the last iteration. And in the last iteration we have that a one through a n or all sorted which is what we want. So that's how we use the loop invariant to show the correctness of the algorithm. Okay. Thank you. Sorry to  Give you a false sense of ending.  No. "
}