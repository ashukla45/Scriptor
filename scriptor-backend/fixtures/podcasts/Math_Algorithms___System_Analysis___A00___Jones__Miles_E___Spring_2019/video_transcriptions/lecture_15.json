{
    "Blurbs": {
        "2 1 0 we put the ones in positions 852 + 0 and this weekend Okay, so see you all tonight. ": [
            4776.7,
            4792.4,
            97
        ],
        "3. Okay. So the three column +32-342-310-0523 is 10. So that's the biggest one that we can get, right. So we have our is equal to our -5 choose 3. which is 11 - 10 which is 1 K is equal to K - 1 which is To so now we do it with one and two. And you guys might be able to figure out what is the largest ": [
            4657.4,
            4699.5,
            94
        ],
        "60 stars or 60 kind of pieces to go in there. So it would be 60 stars and four bars. So what would it be 64 choose 4? Are there any questions about that? 60 soldiers 5 castles what else did we do? Integer functions, right? A 1 + a 2 + a 3 + a 4 + a 5 is equal to 60. You just kind of these are ": [
            3400.1,
            3451.8,
            72
        ],
        "81 and K is going to be for. Okay, so our shoot. Are is 81 K is for okay. So the first thing you do is you find the largest. excuse for value Okay, how do we do that? We look here. Okay. I'm sorry the largest excuse for Value that is less than 81. Okay, how do we do that? Where's my thing? Okay. So we going to the ": [
            4496.3,
            4546.9,
            91
        ],
        "Alright, does anybody have any questions before we begin? We have an exam tonight, right? Yes, so we're just going to go through a few topics that we've covered that will be on the exam. So that's what I have planned for today. And then I'll take any questions that you all might have about that. How's that sound? Good. Okay. So let's start with like just some basic runtimes ": [
            96.0,
            128.0,
            0
        ],
        "But please don't worry about this. All you have to worry about is that you can't use the master steering for a tight upper bound here. You can get a loose upper Bound by saying and login is bounded above by. And squared or maybe even an end to the 1.1 write something like that, then you can get a loose upper bound and then you can do that same ": [
            3016.6,
            3037.3,
            62
        ],
        "He might I might start something like this after T. Iterations something something something something. Okay, ready go. Oh you wanted to be before? what to do after And then when she has zero, that means it's before the loop starts. Halloween what time is it? Okay, what do you all say? After Tia durations, what is true? Or what's what can you say about what is a loop invariant? ": [
            1519.1,
            1632.3,
            34
        ],
        "I maybe this is just the same one that we did before doesn't matter. Okay. So whenever we give you a ranking type algorithm will give you the fix density binary string and will also give you an end K. These are really important also have if you don't have these then you don't know what your ranking you don't know what list you're trying to put it in right ": [
            4137.3,
            4160.7,
            84
        ],
        "Mercer. It really is the best of the Sorting algorithms we've seen because we get this in login runtime any questions, We saw this this was like a divide-and-conquer. We saw how to calculate the run time using the master theorem. Okay, how about searching? Well? We have linear search and binary search now. It's hard to compare them because they work on different types of data linear search can ": [
            199.7,
            233.1,
            3
        ],
        "Okay, good found is true. If and only if V is in the First Tee elements a 1 through 18 any questions about that? Okay good. Okay, so now proved the loop invariant which is after Teeter ations found his true. If and only if V is in a 1 through 18 now, what's the induction variable here? Could be here. Remember remember the difference? Recursive algorithms you were curse ": [
            1647.3,
            1702.2,
            35
        ],
        "Okay, so we're doing induction on N, right? How are you doing Dakshin you start with the smallest size end that it's true for in this case the smaller size and that is true for is. Has Eagles won? any questions was that Avion case we need when you do induction you want to prove that it's true for all and greater than or equal to some bass case. In ": [
            913.3,
            961.1,
            19
        ],
        "Recursive algorithms are nice because they generally have the bass cases kind of written in there out there like usually the first line or something like that of the algorithm. So they're just right there just have to State them and make sure that they work. Okay, then for your induction step. You know, you have the induction hypothesis. It may be strong and maybe regular it depends on the ": [
            366.5,
            394.7,
            8
        ],
        "We're going with recursive first, so The standard approach you need to State what you claim? The algorithm is going to do. What is it going to return? What is it going to do to the list? What values are you going to get? What is algorithm supposed to do and this is important because you're going to use that information to prove that it does what it's supposed to ": [
            303.3,
            331.1,
            6
        ],
        "after n iterations particularly when T is equal to n We have that found is true. If and only if the key is in the entire list, and this is where the algorithm terminates and so this is exactly what we want. So the linear search algorithm is correct. Alright, let's move on to the next topic. Master theorem did everybody write this on their cheat sheet? Okay, good moving ": [
            2217.8,
            2252.8,
            48
        ],
        "also, they are all. Theta of N squared run time in the average case so They're they're not bad. I guess insertion sort and bubble sort can can work quickly if the if the list is kind of already close to being sorted, which is a nice feature, right? Otherwise, it just beats everybody in in all in all of these categories. I guess except for the linear time thing ": [
            164.1,
            199.7,
            2
        ],
        "always have to go through the entire thing. So it's a little bit different. It's efficiency kind of separate those things. Okay, identify the relationship between the variables that remains true throughout the algorithm. This is the loop invariant. So I want you all to think about it for a few minutes to talk it over with your neighbor. What is the loop invariant we should use for this algorithm? ": [
            1489.1,
            1515.8,
            33
        ],
        "and we're equal to 1 then I'm assuming it's true for a list of size 0 but this other than doesn't work for a list of size 0. this is the inductive hypothesis here this thing in red And I guess you can I don't know. I like to say this is part of it. The actual hypothesis is a I guess it starts here assume the whole thing assume ": [
            1252.9,
            1305.2,
            26
        ],
        "and width K1. So we're going to give you an Inkay here also going to give a position and a number of onesies que queso set are to be p&l to BK and you do this kind of iterative thing where you subtract off these binomial coefficients from our And then you subtract off one from K. So how does this look Let's do an example. Are going to be ": [
            4467.2,
            4496.3,
            90
        ],
        "and you really want to know how many of each category are there, or you can think about maybe these are the names of the castles and you want to know how many soldiers are in each cancel, right? If you have 60 soldiers or another way to think about it is you have five categories. So you need for dividers to divide them up. Right and then you need ": [
            3378.9,
            3400.1,
            71
        ],
        "are no restrictions. Okay, so let's try whatever you like. What do you want to be the stars and bars? What do you want to be the castles in the soldiers? What do you want to be the integers and the variables? It's just kind of depends on which way you like to kind of reframe the question, but I I suggest you reframe it in a certain way so ": [
            3265.9,
            3292.3,
            69
        ],
        "as well get started at 0. Bovi always exists because part of the input Well now they're empty set does not have any elements. So. What's up, this is the statement of the loop invariant it says found is true. If and only if V is in the empty set is in the empty set. This statement is always false. This can never be true therefore since it's if and ": [
            1827.0,
            1870.9,
            38
        ],
        "at least 23 Brix right If I don't have at most 22, that means I have at least 23. Yeah. No, it would be at least 22. Yeah, it'll be at most 21. Just doing like a different problem. When was the first thing you do? How many feet is 38 m? ouu split up into four groups instead of five Will that work? So that would be it would ": [
            3794.2,
            3896.8,
            79
        ],
        "be a stronger statement than just the statement of correctness. We saw an example of that with selection sort. Remember we had to use to Loop invariants. We had to say, you know, the list from A 1 through 18 was all sorted and they were all the smallest elements because we needed both of those two kind of proved the induction. Okay, prove the loop invariant by induction on ": [
            1371.4,
            1394.7,
            29
        ],
        "be less than 3. So this is also a bottom-heavy case so big O of n to the log base 2 of 3, which is Big O of like end to the 1.59 or something. Okay good. You can just leave it as best if you like. Yes. Okay. How about next one? Can't use Master theorem. I know you always have to figure it out. Yeah. And so it ": [
            2585.6,
            2641.2,
            52
        ],
        "be. 20 2 + 4 choose 4 plus and it'll be 38. 38 + 4 choose 4 Call + 3 choose 3. Well, there's one way to find out right. Try generally do figure it out. And then and then try to argue that they're their equal, right? So what is it 64 choose 4. or minus 41 choose 4 that's 534 106 Okay, then what's the other one? 26 ": [
            3896.8,
            3974.9,
            80
        ],
        "can do. Tight upper bound is an upper bound where you can't get any better. Yeah, you can stay a tight upper bound is what is related to Theta Ensure? Okay. How about this last one? Is 1 beers. 2D has one so now we have that is less than b to the D. Right one is less than 2 to the 1 and so in this case we have ": [
            3082.2,
            3126.6,
            64
        ],
        "choose 4 Plus 30 No 41 choose 3 No. I want to think about why I write. Haygood What happens if you multiply them? like these ones you get a hundred and fifty-nine. million 367 1000 Okay, let's move on. okay, lexicographic ordering queso were mainly going to be talking about lexicographic ordering with binary strings, which is really quite fortunate for everybody because all you have to do is ": [
            3976.3,
            4078.0,
            81
        ],
        "class and then last week or was it the week before we did the stars and bars that these two things. Okay, and if you're interested in knowing more about this twelvefold way, there's these other things. There's also this thing here that has to do with something called the stirling numbers of the second kind. We have Stirling numbers of the same kind showing up. I think here again ": [
            3177.5,
            3201.6,
            66
        ],
        "do and you're going to do it using induction kind of just the standard way to go about it. What is what problem is the algorithm trying to solve? Play the next thing State the statement being prove by induction right for every input exercise. And algorithm is correct in this is correct in quotes is kind of what you stated. Algorithm should be doing. Okay. Thank you your proof. ": [
            331.1,
            363.2,
            7
        ],
        "equal to 80 + 1. trick questions Okay, good. So now we Now we the last part of loop invariant proof is to use the loop invariant to show that the algorithm is correct. So we have shown by induction for all tea greater than or equal to 0 that after T adorations found his true. If and only if V is in a 1 through 80, so in particular ": [
            2176.6,
            2217.8,
            47
        ],
        "four column right one is less than 81 for lesson 81 10 20 30 556. So 84 is bigger than 81. So 56 is the biggest one that's less than 81. right oh, this is the right This is okay. This is 8 choose 4 write this is the chews for column. Okay, so we have this is 4 choose 4 as 1/5 choose for his 5624 is 15. +724-235-824-7924 ": [
            4546.9,
            4620.8,
            92
        ],
        "give it a binary string a fixed density binary string then it will rank it for you. It'll tell you what its position is in lexicographic ordering. Okay, then we also have a nun ranking algorithm which is kind of just doing the opposite where you give it the position in the lexicographic ordering and it gives you the actual fix density binary string. Okay, so let's do an example. ": [
            4109.8,
            4135.4,
            83
        ],
        "going to be all the different pieces. They all have to sum up to 64. Which way did you organize them? Okay. Let's look at Part B. There must be at least 20 to break pieces. Okay, so if you have them all laid out there, right and you know that you have to have at least 22 brick pieces, then you can just take those pieces first, right? Right ": [
            3451.8,
            3504.7,
            73
        ],
        "greater than 2 squared right? And so this is the pictures of greater than 2 squared So this is the bottom heavy case. right I guess this is this totnes this bottom case here bottom-heavy. And so we have that tea event is equal to Big O of n to the log base 2 of 6. Anybody know what that is? and to the Have I have a calculator on ": [
            2443.5,
            2506.0,
            50
        ],
        "here? 2.58 Okay good. sex Okay, next one. Can I use the master theorem on this next one? Yes. Okay. What's a 3B MD 1.5. So now it's 3 is greater than 2 to the 1.5. right is it? Yes. right because this is This is 2 * \u221a 2 + \u221a 2 is around 1.4. And 2 * 1.5 is equal to 3 * 2 * 1.4 has to ": [
            2506.0,
            2585.6,
            51
        ],
        "if it's part of the master theorem, then you can say no and then you can just move on. Okay. How about this one? Can we use the master theorem? A is for B is 2 and D is too. Okay. So now for is equal to 2 squared. So now we have the steady-state case the middle State the middle case. So, it's Big O of to the D. ": [
            2732.2,
            2768.4,
            55
        ],
        "in a 1 through 80 + 1 good Okay, what about if it's not found or if it's not appear, it doesn't appear in a 1/2 a t so by the induction hypothesis. At this point after T. Iterations found will be equal to false. Okay, that's by the induction hypothesis based on this. Now we have to sub cases. Okay is the equal to 80 + 1 or is ": [
            2073.5,
            2107.3,
            44
        ],
        "in the in the base case for any booze one. We wanted to work for all possible V values. It so if we can if we can establish that it works for all va-10 equals 1 then we established then we use our induction. We established that it works for all V on All In Okay, so I know this might have been kind of a a funny way of ": [
            1047.5,
            1074.1,
            21
        ],
        "in the list a1280 right which is just the empty list. Say it again. So you can see how we're going to say that for sure, but you need to relate it back to the loop invariant. Sure, you can start it at to use to equal to one but then you're going to have to prove that. It's true 40 is equal to 0 also. So if you may ": [
            1769.4,
            1827.0,
            37
        ],
        "induction. Cuz remember regular induction is you assume that it's true 4 + -1 and show that it's true for n right and if it's if it's in this one, then you could do that. If however the recursive call is based on sizes that are less than strictly less than -1. Then you need some sort of some form of strong induction where you're going to to assume more ": [
            659.1,
            687.7,
            14
        ],
        "inductive hypotheses write in order to show that it's true. Yes. If it's just yet, but just decreases by exactly one then that's when you use regular. Okay, good now. Standard approach is induction or strong induction. In this case. We're going to use regular induction, right? We're going to just use this. Carefully State what it means for the program to be correct? What what does it mean for ": [
            687.7,
            728.2,
            15
        ],
        "is equal to one and you've already gone through this first case when you return false cuz you're at the end of the list and then otherwise you return the recursive call on a 1/2 a + -1. So which kind of induction do we need here? How do I resize? Is this matter? Okay good. So regular induction any questions or comments? okay, so this input the original input ": [
            530.2,
            596.6,
            12
        ],
        "is of size n right The recursive call is a size. What? + -1 so regular regular induction when recursive call or let's say when Yeah, one recursive call is on an input. that is one last then the original so notice that he went from a size to a size and minus one. So that means that the input size decreased by only one there for you as regular ": [
            596.6,
            659.1,
            13
        ],
        "isn't 12060 hu4 is the biggest one. so we do our - 8 choose 4 is a r is equal to our -8 choose 4 which is 81 - 70 + K is equal to K - 1/4 equal 2/3 Okay. So now we we do the same thing with 70 + 3. No, sorry. subtract 70 Which is what 11, right we do the same thing with 11 and ": [
            4620.8,
            4657.4,
            93
        ],
        "it not equal to 80 + 1 if it is? Right, then in the t+ first iteration you'll set the the founder able to true and it will be true and it'll be good. If it's not then it won't be such a true and it'll remain false which is what we want. Best cheapest first generation will set found to be true as required because V now is in ": [
            2107.3,
            2143.2,
            45
        ],
        "just compare them compare their numerical values. Okay. So one one number will come before the other number in lexicographic ordering if it's value is less than the other one. Cancel this is just what I'm saying here today is less than be as binary numbers than a is before B lexicographically. Okay. Now if you guys recall we found out we have a nice ranking algorithm, which if you ": [
            4078.0,
            4109.8,
            82
        ],
        "just look at the middle element and find it right there. And in that case, yeah. Orin you could be kind of stupid about implementing it and have it go all the way through the entire recursion Tree in which case it would take login. It's kind of leave. Way to do it. Okay. So let's talk about correctness proofs. We're going to look at recursive algorithms and iterative algorithms. ": [
            270.3,
            303.3,
            5
        ],
        "know it is always been going to be greater. She's got to be a constant. How to use the master theorem now you could you could bound it and get a get a upper bound using the master theorem, but it wouldn't be a tight upper bound. write for example if you had see you then Is equal to 2 T of n / 2 + Big O of n ": [
            2814.5,
            2854.7,
            57
        ],
        "like in this case I would I would. I would assume you know how to figure this out without a calculator. Any other questions? No, no calculators. Oh, yeah. You can square both sides. Because we're both sides right then you have not three squared is 9 to square root of 2 squared is 4 * 2 which is eight. That's better. No, no. No, you just you just have ": [
            2641.2,
            2695.9,
            53
        ],
        "list a and we should say for all And greater than or equal to. We want to prove that is true for all of these end. Okay, and then you just do your proof by induction? What are the base cases here? That's not what I wanted to do. All right. So you're saying that what is D more than one of the above? Which two are you talking about? ": [
            810.5,
            890.8,
            18
        ],
        "log in? Right. Now this is not a this is not a polynomial right? And so it's not you can't use the master theorem hear. What you could do is you could say well this is bounded above by and squared and so you can get this really kind of Loose upper bound but you can't get a tight upper Bound by using the master. Theorem. You're going to have ": [
            2854.7,
            2882.1,
            58
        ],
        "login good questions about that. Okay, how about this next one? Ma can't do that secant is unbounded. a function that we can found it and we can stay there like for sure like a to the are dab it's looking like for sure stay there like a is like greater than it needs to be if you can see if I fucking this like we can down so we ": [
            2769.9,
            2814.5,
            56
        ],
        "loop invariant is true. And that usually means that you set T is equal to 0. Any other questions? Okay. Now, let's prove it. So the induction step right here the induction hypothesis. Let T be some in this case. Yahoo TV some non-negative integer assume that the loop invariant hold after T iterations, right? This is the inductive hypothesis. We want to show that V is in a 1 ": [
            1953.6,
            1999.6,
            41
        ],
        "means for the program to be correct RLS of a 1/2 a n, v is true if and only if V is an element in the list a4a is equal to Okay. Now number to State the statement being prove by induction for every list of size n and every Target v r l s a 1/2 a n, v is true if and only if V is element in ": [
            774.9,
            810.5,
            17
        ],
        "n + N - 1 to prove n + 1 you need strong induction? Okay, and then do induction. Okay, let's do an example of a recursive algorithm. This is recursive linear search. Okay. So what is it going to do? It's basically going to ask if your target value V is equal to the last blast element if it is when you return true. And I guess if n ": [
            489.8,
            530.2,
            11
        ],
        "now put them aside. Okay now out of the remaining however many 38 pieces. You need to figure out where to put them. pick from the remaining Or I'd say like let's say pick 38. pieces Okay, so now it's like it's like think about it this way if you had five castles and you know that you need at least 22 of them to be in Castle one right ": [
            3504.7,
            3555.5,
            74
        ],
        "of one? And so you can just replace co-sign with big data of one and now one is a polynomial. So then you can just use it that way. David Beador that and if you had both and then he would be fun and then into the deep end. This is greater than it has to be sturdy will be greater than a and so you'd be able to use ": [
            2939.1,
            2972.9,
            60
        ],
        "of sorting algorithms. Okay, we mainly talked mostly about selection story. You know, we looked at it we did it's run time. We did the proof of correctness. We did some examples, but we talked a little bit about bubble sort and insertion sort and these these three I kind of like the group together. Because they all have a big O of N squared upper bound on worst-case runtime ": [
            128.0,
            164.1,
            1
        ],
        "on the size on the number of iterations. Okay, so let's do it. Let's prove it. What is the base case? T equals zero, so one way to kind of remember how to do this is when you say except equal zero just write out the loop invariant with zero in place of tea so they would say after 0 iterations Found is true. If and only if V is ": [
            1702.2,
            1769.4,
            36
        ],
        "on. Why don't you guys spend a few minutes with your partner with your neighbor? Try to figure out what is the the Titus big'o class that you can get using the master theorem, or else tell me that the master theorem does not apply. Okay, go. Okay, let's do this together. 8 is equal to 6. B is equal to 2 D is equal to 2 so 6 is ": [
            2252.8,
            2443.5,
            49
        ],
        "only if this has to be false, right? I think I have it on the next slide animation. 40 is equal to zero. The loop invariant is claiming that found a sequel to true. If and only if he is in the empty list, since there are no elements in the empty list for we are trying to show reduces to found is not equal to true and then that's ": [
            1870.9,
            1899.5,
            39
        ],
        "out, right we can kind of throw that element away. Then you recurse on the rest of the list and it will return true. If and only if V is part of this list any questions. What cuz I'm assuming that it's true. I'm assuming that if I if I make 10 greater than one I'm assuming that it's true for a list of size N - 1 so suppose ": [
            1205.1,
            1252.9,
            25
        ],
        "problem and you just want to show that it works for any input of size. And so you usually just say let I don't know. Suppose we have some arbitrary input of size and do some stuff to it. Usually the recursive algorithms will rehearse on a smaller version which is exactly what you want. So then you can just say that the reduction be the induction hypothesis is correct ": [
            394.7,
            425.0,
            9
        ],
        "put them in there. Now you have 38 soldiers left. How are you going to put them in the castles? Well, you just forget about those 22 that you already put in there and just distribute the 38. and however, many ways you can For now, it would be 38 + 4 choose 4. Okay, are there any questions about this one? Turn of a simplified concept of how we're ": [
            3555.5,
            3592.7,
            75
        ],
        "saying it. There's one base case, but that bass case has two cases. Okay case one child is the goal. We want a 1 V to be true. If and only if B is an element in the list case one a one is equal to be in that case in line 1 it returns true case two is a 1 is not equal to be that means in line ": [
            1074.1,
            1099.5,
            22
        ],
        "since the loop is variant is true. Then after the algorithm terminates the algorithm should be Okay, let someone go through. player search without being recursive. Okay. So now this is just a loop you start out with found being equal to false. and you Loop through and you say if for each eye from 1 to end if AI is ever equal 2 V then turn found equal to ": [
            1425.0,
            1457.8,
            31
        ],
        "size and -1 that are LS of a 1/2 a good now from the pseudocode. You see that RLS this thing depends on whether V is equal to an if true and we're good right because we wanted to return true if it's in the list but equal to and then it's in the list. Okay. Otherwise it's not equal to a n so we know that that element is ": [
            1171.7,
            1205.1,
            24
        ],
        "something there's something called The Bell numbers that are here that show up all over the place and then just bottom row is all kind of integer partitions. So there's a lot of interesting things in there, but we're just not going to cover them. That's B's to these three, but these three is what we covered the first few weeks. Okay, so let's think about this problem. Let's say ": [
            3201.6,
            3240.1,
            67
        ],
        "that it's true assume for some every list of size and -1 this thing is true. How did where do we use it? We only used it in case 2. Okay, let's do another type of proof of correctness of iterative algorithm. Okay. So the standard approach here is to prove it by loop invariant. It's a little bit trickier in my opinion then recursive algorithms because now you have ": [
            1305.2,
            1343.2,
            27
        ],
        "that you can kind of wrap your head around it. Okay, so talk it over with your neighbors for a few minutes and then we'll we'll talk about it. This is stars and bars. Is all the stuff that we did was that last week? Oh, yeah. Yeah, there will be on the midterm. It's the same thing. Okay. Okay, so you have five sort of? Castles are categories. Right ": [
            3292.3,
            3378.9,
            70
        ],
        "the algorithm works for that smaller instance. when you require multiple base cases, that's that's not the that's not the reason for strong induction. But it usually is an indicator. Does anybody know the reason when you use strong induction? Okay. I said the the recursive call is less than -1. Or the size decreases by more than one. question you need to use what? Do you need to use ": [
            425.0,
            489.8,
            10
        ],
        "the biggest number choose one that is less than or equal to 0 its 0 choose 1. Sor is equal to r - 0 choose one which is equal to 0 - 0 + K is equal to K - 1 which is 0 Okay, and then you just read off these values 0 to 5 and 8. So that means if I have 8 7 6 5 4 3 ": [
            4741.5,
            4776.7,
            96
        ],
        "the number of times we've gone through the loop. So this is another big change difference than recursive algorithms recursive algorithms you the induction variable is the size of the input this one the size of the input is fixed and the recursive the inductive variable is the number of iterations through the loop. Okay, and then step 3 this is usually just a few lines that just says Okay, ": [
            1394.7,
            1425.0,
            30
        ],
        "the program to be correct? Return true if and only if V is in the set. K-State the statement being prove by induction for any input X of size n algorithm X is correct or in other words algorithm acts will return true. If and only if B is in the input set. Okay, then you do your proof. Okay, so, let's see how it works. carefully State what it ": [
            728.2,
            774.9,
            16
        ],
        "the set or the list a 1 through 80 + 1 right because it's actually equal to 80 + 1 and here we won't change the value of sound so found is equal to false. Envy is not in a 1 through 80 + 1. Right, and how did I know if he is not in here because V is not in a 1/2 a t and V is not ": [
            2143.2,
            2176.6,
            46
        ],
        "the the first case has less than it was beloved. And you know it. Right, but then if a is less than betta Daddy then it's big old into the D. But what is d? That's why it's kind of messed up. It turns out if you're interested that the tight upper bound is actually Big O of n log squared and Cuz actually like little bit bigger than login. ": [
            2972.9,
            3015.8,
            61
        ],
        "the top heavy case, right? And so we have t of n is Big O of n to the D is an n Okay, any questions about that? Okay, good. I so let's move on we have the twelvefold way. Remember all of these things that we did. So in the first few weeks we talked mainly about these three squares. write this was like the first few weeks Of ": [
            3126.6,
            3177.5,
            65
        ],
        "thing, but that would still be a Lucifer bound because it would be a lot bigger than the right if you actually like try to get some d right that is like a concrete number, but this one question. You will get those. Yes. This is a mess. No, the formal definition is is that this upper back? There's no better upper bound. It's the best upper bound that you ": [
            3037.3,
            3082.2,
            63
        ],
        "this case. It's all n greater than or equal to 1/3 * 10 equals 1. It could. Yes. This is there's one base case for that has two cases. We're only God. Can we just like? I would normally just right like brawl. Right. We're not interrupting on V, right. all kind of meat I'll be just means all possible inputs. But we're actually inducting on N. So in fact ": [
            961.1,
            1047.5,
            20
        ],
        "through 80 + 1 if and only if found is equal to True after the next iteration, so consider the two cases case one. Is that V appears in a 1 through 80 in case 2 is that V doesn't appear in A 1 through 80. Okay any questions about this so far? All right. So let's go through case one. So in case one by the induction hypothesis found ": [
            1999.6,
            2035.7,
            42
        ],
        "to 20 choose any number from 0 to 6 Okay, so okay, so let's let's Let's just look at the example. I gave you right it was eight shoes for rent. That was the first one so I go down to rotate and I go over 1 2 3 4 hu470 Okay. And then the next one was what 6 to 3. So I go six choose. 112-3623 is 30 ": [
            4295.8,
            4336.2,
            87
        ],
        "to come up with a loop invariant which is not always easy to figure out. Okay. So first thing is to State the loop invariant identify the relationship between the variables that remains true throughout the algorithm that's going to help you prove that the algorithm is true at the end. Right, it must comply the correctness of algorithm after after the algorithm terminates actually, sometimes it may need to ": [
            1343.2,
            1371.4,
            28
        ],
        "to do is take no restrictions. minus at least 23, so it's not quite part part B. At least 23 bricks. Okay, so no restrictions is 60 + 4 choose 4 - now this is 37 + 4 choose 4. 64 choose 4 - 41 choose 4 Any questions about that? Sure. Tanner questions Right because okay. So the the complement of this right the the negation of this. is ": [
            3695.4,
            3793.2,
            78
        ],
        "to do like some more analysis by looking at the recursion tree. turns out that the upper bound the tight upper Bound for this is tickets analog squared in What if it was like Figo of N2 the like? Are they going to look like? And like the acting Valium like cosigner and there's something something something that's like more bounded. Yeah, I guess with cosine cosine is Big Theta ": [
            2882.1,
            2939.1,
            59
        ],
        "to figure out that 3 is bigger than 2 square 2 2. Oh this one. We're just asking. Can you use Master theorem? So yeah, if you wanted to that you would have to do some sort of unraveling or guessing check and you'd find out that it's what I'm sorry. If I asked you to figure it out, then you have to figure it out. If I asked you ": [
            2695.9,
            2732.2,
            54
        ],
        "to or turn false. So it works any questions. Okay. good next one next where's my? Okay. Okay, proof by induction on input size input list size an induction step. Let N be a non-negative integer. and assume for each list a of size n - 1 Say this should be. Sorry, this is a typo here. let be strictly greater than and assumed that for each list a of ": [
            1099.5,
            1171.7,
            23
        ],
        "together. So we have a choose for which is 70. Plus 20 + 3 + 1 which is 94. Is there any questions about this? That's what I was going to just say. is that Here, let me see something. Did you get it today? We're going to give you this on the exam. Okay, so you can see you can. you can calculate all the any number from 1 ": [
            4225.8,
            4295.8,
            86
        ],
        "true and then at the end just returned found now this one is does algorithm Is not as advanced as the one we saw before. This one you're going to have to go through the entire Loop, right? Whereas the one we saw before a few weeks ago. It would it will end early. If you find the if you find that value this one won't end early. This one ": [
            1457.8,
            1489.1,
            32
        ],
        "value choose to that's less than or equal to one. Is to to choose to is less than or equal to one. Okay, so we have our is equal to our -2 choose 2. Has to choose two as one and that's one minus one. less than or equal to is equal to zero and then K is equal to K - 1 which is 1 Right, and now what's ": [
            4699.5,
            4741.5,
            95
        ],
        "wait a minute. This is this is like there's a typo on this. Well, I'm glad we looked at it. I should be 20. Okay. 623 s 20. No, no calculators. oh, wow, that's embarrassing what we just whatever if you use the number on calculator, then you get the points. Just go by what they have on here. Okay. Yeah, if the mistake comes from you to the table, ": [
            4338.3,
            4419.5,
            88
        ],
        "we're kind of taking the stars and bars and applying it to this thing. Just put those people aside and then feel everything. What do you mean? and women that's what we're going to do for this one. That's this one here. When is that for this problem? It's just you need to have at least 22 bricks or just take those out and put those aside and then deal ": [
            3592.7,
            3647.7,
            76
        ],
        "when I guess you could just you could count the string, but we could we will give you this information. Okay, so does anybody remember how to do this? Okay, so what do I do? Number them from starting from what? Starting from 8 right going down. And then what? Number the number the ones from 4 down to one. right, and then you get these binomial coefficients to add ": [
            4160.7,
            4225.8,
            85
        ],
        "when we stats when we reference the actual pseudocode and we say in line one found is equal to false before you enter the loop there for the base case is true. any questions no comment. I don't remember what we did exactly. but for a loop invariant question You generally want to show what happens before before the loop is executed you wanted we want to show that the ": [
            1899.5,
            1953.6,
            40
        ],
        "will be equal to True, right? If V appears in a 1 through 80, then we'll know that it would have already been set to true. And therefore V is in a 1 through 80 + 1. Sound is set to True know where in the algorithm do we ever reset it to fall? So they'll stay true in the next iteration. And then found his true and the appears. ": [
            2035.7,
            2071.1,
            43
        ],
        "with the rest. Okay, let's let's look a little bit trickier. Okay, so at most 22 brick pieces. Okay, so you definitely you can you can have 20 brick pieces or 9 brick pieces or 18 brick pieces, but you can't have more than 22 so that means you can't have 23 or more brick pieces. Yeah, pretty much be a little a little careful careful. So what you want ": [
            3647.7,
            3695.4,
            77
        ],
        "work on any data any list and binary search only works when the list is sorted. So of course if the list is sorted you want to use binary search because of this nice data login run time. But if the list is not sorted and it's much faster to just use linear search rather than sorting it and then using binary search. Yeah, cuz the binary search you can ": [
            233.1,
            270.3,
            4
        ],
        "you have a bunch of Lego pieces and they come in five different objects a brick a plate a tile Inaba in a tube pieces of the same type are identical suppose. You have a huge collection of Lego pieces that contains many objects of various shapes and you want to gather 60-piece how many ways are there to collect 60 Lego pieces if okay. Let's start with a there ": [
            3240.1,
            3265.9,
            68
        ],
        "you'll get the points but will tell everybody to change this to a twenty one I know is wrong. I'm going to look over it again and try to make sure that it's all together. Wow. I blame that one on qualms. Okay. So before we go though none ranking. Okay. So on ranking is we're going to be given a position of a bit string that is of length ": [
            4419.5,
            4467.2,
            89
        ]
    },
    "File Name": "Math_Algorithms___System_Analysis___A00___Jones__Miles_E___Spring_2019-lecture_15.flac",
    "Full Transcript": "Alright, does anybody have any questions before we begin?  We have an exam tonight, right?  Yes, so we're just going to go through a few topics that we've covered that will be on the exam. So that's what I have planned for today. And then I'll take any questions that you all might have about that. How's that sound?  Good. Okay. So let's start with like just some basic runtimes of sorting algorithms.  Okay, we mainly talked mostly about selection story. You know, we looked at it we did it's run time. We did the proof of correctness.  We did some examples, but we talked a little bit about bubble sort and insertion sort and these these three I kind of like the group together.  Because they all have a big O of N squared upper bound on worst-case runtime also, they are all.  Theta of N squared run time in the average case so  They're they're not bad. I guess insertion sort and bubble sort can can work quickly if the if the list is kind of already close to being sorted, which is a nice feature, right? Otherwise, it just beats everybody in in all in all of these categories. I guess except for the linear time thing Mercer. It really is the best of the Sorting algorithms we've seen because we get this in login runtime any questions,  We saw this this was like a divide-and-conquer. We saw how to calculate the run time using the master theorem.  Okay, how about searching? Well?  We have linear search and binary search now. It's hard to compare them because they work on different types of data linear search can work on any data any list and binary search only works when the list is sorted. So of course if the list is sorted you want to use binary search because of this nice data login run time.  But if the list is not sorted and it's much faster to just use linear search rather than sorting it and then using binary search.  Yeah, cuz the binary search you can just look at the middle element and find it right there. And in that case, yeah.  Orin you could be kind of stupid about implementing it and have it go all the way through the entire recursion Tree in which case it would take login. It's kind of leave.  Way to do it.  Okay.  So let's talk about correctness proofs. We're going to look at recursive algorithms and iterative algorithms. We're going with recursive first, so  The standard approach you need to State what you claim? The algorithm is going to do. What is it going to return? What is it going to do to the list? What values are you going to get? What is algorithm supposed to do and this is important because you're going to use that information to prove that it does what it's supposed to do and you're going to do it using induction kind of just the standard way to go about it. What is what problem is the algorithm trying to solve?  Play the next thing State the statement being prove by induction right for every input exercise. And algorithm is correct in this is correct in quotes is kind of what you stated. Algorithm should be doing.  Okay.  Thank you your proof.  Recursive algorithms are nice because they generally have the bass cases kind of written in there out there like usually the first line or something like that of the algorithm. So they're just right there just have to State them and make sure that they work.  Okay, then for your induction step.  You know, you have the induction hypothesis. It may be strong and maybe regular it depends on the problem and  you just want to show that it works for any input of size. And so you usually just say let I don't know.  Suppose we have some arbitrary input of size and do some stuff to it. Usually the recursive algorithms will rehearse on a smaller version which is exactly what you want. So then you can just say that the reduction be the induction hypothesis is correct the algorithm works for that smaller instance.  when you require multiple base cases, that's that's not the  that's not the reason for strong induction.  But it usually is an indicator.  Does anybody know the reason when you use strong induction?  Okay. I said the the recursive call is less than -1.  Or the size decreases by more than one.  question  you need to use what?  Do you need to use n + N - 1 to prove n + 1 you need strong induction?  Okay, and then do induction.  Okay, let's do an example of a recursive algorithm. This is recursive linear search.  Okay. So what is it going to do? It's basically going to ask if your target value V is equal to the last blast element if it is when you return true.  And I guess if n is equal to one and you've already gone through this first case when you return false cuz you're at the end of the list and then otherwise you return the recursive call on a 1/2 a + -1.  So which kind of induction do we need here?  How do I resize?  Is this matter? Okay good. So regular induction any questions or comments?  okay, so this input the original input is of size n  right  The recursive call is a size. What?  + -1  so  regular regular induction  when recursive call  or let's say when  Yeah, one recursive call is on an input.  that is  one last  then the original  so notice that he went from a size to a size and minus one. So that means that the input size decreased by only one there for you as regular induction. Cuz remember regular induction is you assume that it's true 4 + -1 and show that it's true for n right and if it's if it's in this one, then you could do that.  If however the recursive call is based on sizes that are less than strictly less than -1. Then you need some sort of some form of strong induction where you're going to to assume more inductive hypotheses write in order to show that it's true.  Yes.  If it's just yet, but just decreases by exactly one then that's when you use regular.  Okay, good now.  Standard approach is induction or strong induction. In this case. We're going to use regular induction, right? We're going to just use this.  Carefully State what it means for the program to be correct? What what does it mean for the program to be correct?  Return true if and only if V is in the set.  K-State the statement being prove by induction for any input X of size n algorithm X is correct or in other words algorithm acts will return true. If and only if B is in the input set.  Okay, then you do your proof. Okay, so, let's see how it works.  carefully State what it means for the program to be correct RLS of a 1/2 a n, v is true if and only if V is an element in the list a4a is equal to  Okay. Now number to State the statement being prove by induction for every list of size n and every Target v r l s a 1/2 a n, v is true if and only if V is element in list a and we should say  for all  And greater than or equal to.  We want to prove that is true for all of these end.  Okay, and then you just do your proof by induction?  What are the base cases here?  That's not what I wanted to do.  All right. So you're saying that what is D more than one of the above? Which two are you talking about?  Okay, so we're doing induction on N, right?  How are you doing Dakshin you start with the smallest size end that it's true for in this case the smaller size and that is true for is.  Has Eagles won?  any questions  was that  Avion case we need  when you do induction you want to prove that it's true for all and greater than or equal to some bass case. In this case. It's all n greater than or equal to 1/3 * 10 equals 1.  It could.  Yes.  This is there's one base case for that has two cases.  We're only God. Can we just like?  I would normally just right like brawl.  Right. We're not interrupting on V, right.  all kind of meat  I'll be just means all possible inputs.  But we're actually inducting on N. So in fact in the in the base case for any booze one. We wanted to work for all possible V values.  It so if we can if we can establish that it works for all va-10 equals 1 then we established then we use our induction. We established that it works for all V on All In  Okay, so I know this might have been kind of a a funny way of saying it.  There's one base case, but that bass case has two cases.  Okay case one child is the goal. We want a 1 V to be true. If and only if B is an element in the list case one a one is equal to be in that case in line 1 it returns true case two is a 1 is not equal to be that means in line to or turn false. So it works any questions.  Okay.  good next one next  where's my?  Okay.  Okay, proof by induction on input size input list size an induction step. Let N be a non-negative integer.  and assume for each list a of size n - 1  Say this should be.  Sorry, this is a typo here.  let be strictly greater than  and assumed that for each list a of size and -1 that are LS of a 1/2 a good now from the pseudocode. You see that RLS this thing depends on whether V is equal to an if true and we're good right because we wanted to return true if it's in the list but equal to and then it's in the list.  Okay.  Otherwise it's not equal to a n so we know that that element is out, right we can kind of throw that element away. Then you recurse on the rest of the list and it will return true. If and only if V is part of this list any questions.  What cuz I'm assuming that it's true.  I'm assuming that if I if I make 10 greater than one I'm assuming that it's true for a list of size N - 1  so suppose and we're equal to 1 then I'm assuming it's true for a list of size 0 but this other than doesn't work for a list of size 0.  this is the inductive hypothesis here this thing in red  And I guess you can I don't know. I like to say this is part of it.  The actual hypothesis is a I guess it starts here assume the whole thing assume that it's true assume for some every list of size and -1 this thing is true.  How did where do we use it? We only used it in case 2.  Okay, let's do another type of proof of correctness of iterative algorithm. Okay. So the standard approach here is to prove it by loop invariant. It's a little bit trickier in my opinion then recursive algorithms because now you have to come up with a loop invariant which is not always easy to figure out.  Okay. So first thing is to State the loop invariant identify the relationship between the variables that remains true throughout the algorithm that's going to help you prove that the algorithm is true at the end.  Right, it must comply the correctness of algorithm after after the algorithm terminates actually, sometimes it may need to be a stronger statement than just the statement of correctness. We saw an example of that with selection sort. Remember we had to use to Loop invariants. We had to say, you know, the list from A 1 through 18 was all sorted and they were all the smallest elements because we needed both of those two kind of proved the induction.  Okay, prove the loop invariant by induction on the number of times we've gone through the loop. So this is another big change difference than recursive algorithms recursive algorithms you the induction variable is the size of the input this one the size of the input is fixed and the recursive the inductive variable is the number of iterations through the loop.  Okay, and then step 3 this is usually just a few lines that just says Okay, since the loop is variant is true. Then after the algorithm terminates the algorithm should be  Okay, let someone go through.  player search  without being recursive. Okay. So now this is just a loop you start out with found being equal to false.  and you Loop through and you say if for each eye from 1 to end if AI is ever equal 2 V then turn found equal to true and then at the end just returned found now this one is  does algorithm  Is not as advanced as the one we saw before.  This one you're going to have to go through the entire Loop, right? Whereas the one we saw before a few weeks ago. It would it will end early. If you find the if you find that value this one won't end early. This one always have to go through the entire thing. So it's a little bit different. It's efficiency kind of separate those things.  Okay, identify the relationship between the variables that remains true throughout the algorithm. This is the loop invariant. So I want you all to think about it for a few minutes to talk it over with your neighbor. What is the loop invariant we should use for this algorithm?  He might I might start something like this after T. Iterations something something something something. Okay, ready go.  Oh you wanted to be before?  what to do after  And then when she has zero, that means it's before the loop starts.  Halloween  what time is it?  Okay, what do you all say?  After Tia durations, what is true?  Or what's what can you say about what is a loop invariant?  Okay, good found is true. If and only if V is in the First Tee elements a 1 through 18 any questions about that?  Okay good.  Okay, so now proved the loop invariant which is after Teeter ations found his true. If and only if V is in a 1 through 18 now, what's the induction variable here?  Could be here. Remember remember the difference?  Recursive algorithms you were curse on the size on the number of iterations.  Okay, so let's do it. Let's prove it. What is the base case?  T equals zero, so one way to kind of remember how to do this is when you say except equal zero just write out the loop invariant with zero in place of tea so they would say  after 0 iterations  Found is true.  If and only if  V is in the list a1280 right which is just the empty list.  Say it again.  So you can see how we're going to say that for sure, but you need to relate it back to the loop invariant.  Sure, you can start it at to use to equal to one but then you're going to have to prove that. It's true 40 is equal to 0 also.  So if you may as well get started at 0.  Bovi always exists because part of the input  Well now they're empty set does not have any elements. So.  What's up, this is the statement of the loop invariant it says found is true. If and only if V is in the empty set is in the empty set. This statement is always false. This can never be true therefore since it's if and only if this has to be false, right?  I think I have it on the next slide animation.  40 is equal to zero. The loop invariant is claiming that found a sequel to true. If and only if he is in the empty list, since there are no elements in the empty list for we are trying to show reduces to found is not equal to true and then that's when we stats when we reference the actual pseudocode and we say in line one found is equal to false before you enter the loop there for the base case is true.  any questions  no comment.  I don't remember what we did exactly.  but for a loop invariant question  You generally want to show what happens before before the loop is executed you wanted we want to show that the loop invariant is true.  And that usually means that you set T is equal to 0.  Any other questions?  Okay.  Now, let's prove it. So the induction step right here the induction hypothesis. Let T be some in this case.  Yahoo TV some non-negative integer assume that the loop invariant hold after T iterations, right? This is the inductive hypothesis. We want to show that V is in a 1 through 80 + 1  if and only if found is equal to True after the next iteration, so consider the two cases case one. Is that V appears in a 1 through 80 in case 2 is that V doesn't appear in A 1 through 80.  Okay any questions about this so far?  All right. So let's go through case one.  So in case one by the induction hypothesis found will be equal to True, right? If V appears in a 1 through 80, then we'll know that it would have already been set to true.  And therefore V is in a 1 through 80 + 1.  Sound is set to True know where in the algorithm do we ever reset it to fall? So they'll stay true in the next iteration.  And then found his true and the appears.  in a 1 through 80 + 1 good  Okay, what about if it's not found or if it's not appear, it doesn't appear in a 1/2 a t so by the induction hypothesis.  At this point after T. Iterations found will be equal to false. Okay, that's by the induction hypothesis based on this.  Now we have to sub cases.  Okay is the equal to 80 + 1 or is it not equal to 80 + 1 if it is?  Right, then in the t+ first iteration you'll set the the founder able to true and it will be true and it'll be good.  If it's not then it won't be such a true and it'll remain false which is what we want.  Best cheapest first generation will set found to be true as required because  V now is in the set or the list a 1 through 80 + 1  right because it's actually equal to 80 + 1 and here we won't change the value of sound so found is equal to false.  Envy is not in a 1 through 80 + 1.  Right, and how did I know if he is not in here because V is not in a 1/2 a t and V is not equal to 80 + 1.  trick questions  Okay, good. So now we  Now we the last part of loop invariant proof is to use the loop invariant to show that the algorithm is correct. So we have shown by induction for all tea greater than or equal to 0 that after T adorations found his true. If and only if V is in a 1 through 80, so in particular after n iterations  particularly when T is equal to n  We have that found is true. If and only if the key is in the entire list, and this is where the algorithm terminates and so this is exactly what we want. So the linear search algorithm is correct.  Alright, let's move on to the next topic.  Master theorem  did everybody write this on their cheat sheet?  Okay, good moving on.  Why don't you guys spend a few minutes with your partner with your neighbor?  Try to figure out what is the the Titus big'o class that you can get using the master theorem, or else tell me that the master theorem does not apply. Okay, go.  Okay, let's do this together.  8 is equal to 6.  B is equal to 2  D is equal to 2  so  6 is greater than 2 squared right? And so this is the  pictures of greater than 2 squared  So this is the bottom heavy case.  right  I guess this is this totnes this bottom case here bottom-heavy.  And so we have that tea event is equal to Big O of n to the log base 2 of 6.  Anybody know what that is?  and to the  Have I have a calculator on here?  2.58  Okay good.  sex  Okay, next one. Can I use the master theorem on this next one?  Yes. Okay. What's a  3B  MD  1.5. So now it's 3 is greater than 2 to the 1.5.  right  is it?  Yes.  right because this is  This is 2 * \u221a 2 + \u221a 2 is around 1.4.  And 2 * 1.5 is equal to 3 * 2 * 1.4 has to be less than 3.  So this is also a bottom-heavy case so big O of n to the log base 2 of 3, which is Big O of like end to the 1.59 or something.  Okay good.  You can just leave it as best if you like. Yes. Okay. How about next one?  Can't use Master theorem.  I know you always have to figure it out.  Yeah.  And so it like in this case I would I would.  I would assume you know how to figure this out without a calculator.  Any other questions?  No, no calculators.  Oh, yeah.  You can square both sides.  Because we're both sides right then you have not three squared is 9 to square root of 2 squared is 4 * 2 which is eight.  That's better.  No, no. No, you just you just have to figure out that 3 is bigger than 2 square 2 2.  Oh this one. We're just asking. Can you use Master theorem? So yeah, if you wanted to that you would have to do some sort of unraveling or guessing check and you'd find out that it's what  I'm sorry.  If I asked you to figure it out, then you have to figure it out. If I asked you if it's part of the master theorem, then you can say no and then you can just move on.  Okay. How about this one? Can we use the master theorem?  A is for B is 2 and D is too. Okay. So now for is equal to 2 squared. So now we have the steady-state case the middle State the middle case. So, it's Big O of to the D.  login  good questions about that.  Okay, how about this next one?  Ma  can't do that secant is unbounded.  a function that we can found it and we can stay there like for sure like a to the  are dab  it's looking like for sure stay there like a is like greater than it needs to be if you can see if I fucking this like we can down so we know it is always been going to be greater.  She's got to be a constant.  How to use the master theorem now you could you could bound it and get a get a upper bound using the master theorem, but it wouldn't be a tight upper bound.  write for example  if you had see you then  Is equal to 2 T of n / 2 + Big O of n log in?  Right. Now this is not a this is not a polynomial right? And so it's not you can't use the master theorem hear. What you could do is you could say well this is bounded above by and squared and so you can get this really kind of  Loose upper bound but you can't get a tight upper Bound by using the master. Theorem. You're going to have to do like some more analysis by looking at the recursion tree.  turns out that the upper bound the tight upper Bound for this is  tickets analog squared in  What if it was like Figo of N2 the like?  Are they going to look like?  And like the acting Valium like cosigner and there's something something something that's like more bounded.  Yeah, I guess with cosine cosine is Big Theta of one? And so you can just replace co-sign with big data of one and now one is a polynomial. So then you can just use it that way.  David Beador that and if you had both and then he would be fun and then into the deep end. This is greater than it has to be sturdy will be greater than a and so you'd be able to use the the first case has less than it was beloved.  And you know it.  Right, but then if a is less than betta Daddy then it's big old into the D. But what is d?  That's why it's kind of messed up.  It turns out if you're interested that the tight upper bound is actually Big O of n log squared and  Cuz actually like little bit bigger than login.  But please don't worry about this. All you have to worry about is that you can't use the master steering for a tight upper bound here.  You can get a loose upper Bound by saying and login is bounded above by.  And squared or maybe even an end to the 1.1 write something like that, then you can get a loose upper bound and then you can do that same thing, but that would still be a Lucifer bound because it would be a lot bigger than the right if you actually like try to get some d right that is like a concrete number, but this one question.  You will get those.  Yes.  This is a mess.  No, the formal definition is is that this upper back? There's no better upper bound.  It's the best upper bound that you can do.  Tight upper bound is an upper bound where you can't get any better.  Yeah, you can stay a tight upper bound is what is related to Theta Ensure?  Okay. How about this last one?  Is 1 beers.  2D has one so now we have that is less than b to the D. Right one is less than 2 to the 1 and so in this case we have the top heavy case, right? And so we have t of n is Big O of n to the D is an n  Okay, any questions about that?  Okay, good. I so let's move on we have the twelvefold way. Remember all of these things that we did. So in the first few weeks we talked mainly about these three squares.  write this was like the first  few weeks  Of class and then last week or was it the week before we did the stars and bars that these two things. Okay, and if you're interested in knowing more about this twelvefold way, there's these other things.  There's also this thing here that has to do with something called the stirling numbers of the second kind. We have Stirling numbers of the same kind showing up. I think here again something there's something called The Bell numbers that are here that show up all over the place and then just bottom row is all kind of integer partitions. So there's a lot of interesting things in there, but we're just not going to cover them.  That's B's to these three, but these three is what we covered the first few weeks.  Okay, so let's think about this problem. Let's say you have a bunch of Lego pieces and they come in five different objects a brick a plate a tile Inaba in a tube pieces of the same type are identical suppose. You have a huge collection of Lego pieces that contains many objects of various shapes and you want to gather 60-piece how many ways are there to collect 60 Lego pieces if okay. Let's start with a there are no restrictions.  Okay, so let's try whatever you like. What do you want to be the stars and bars? What do you want to be the castles in the soldiers? What do you want to be the integers and the variables? It's just kind of depends on which way you like to kind of reframe the question, but I I suggest you reframe it in a certain way so that you can kind of wrap your head around it. Okay, so talk it over with your neighbors for a few minutes and then we'll we'll talk about it.  This is stars and bars.  Is all the stuff that we did was that last week?  Oh, yeah. Yeah, there will be on the midterm.  It's the same thing.  Okay.  Okay, so you have five sort of?  Castles are categories. Right and you really want to know how many of each category are there, or you can think about maybe these are the names of the castles and you want to know how many soldiers are in each cancel, right? If you have 60 soldiers or another way to think about it is you have five categories. So you need for dividers to divide them up. Right and then you need 60 stars or 60 kind of pieces to go in there. So it would be 60 stars and four bars.  So what would it be 64 choose 4?  Are there any questions about that?  60 soldiers  5 castles  what else did we do?  Integer functions, right?  A 1 + a 2 + a 3 + a 4 + a 5 is equal to 60.  You just kind of these are going to be all the different pieces. They all have to sum up to 64. Which way did you organize them?  Okay.  Let's look at Part B.  There must be at least 20 to break pieces.  Okay, so  if you have them all laid out there, right and you know that you have to have at least 22 brick pieces, then you can just take those pieces first, right?  Right now put them aside.  Okay now out of the remaining however many 38 pieces.  You need to figure out where to put them.  pick from  the remaining  Or I'd say like let's say pick 38.  pieces  Okay, so now it's like it's like think about it this way if you had five castles and you know that you need at least 22 of them to be in Castle one right put them in there. Now you have 38 soldiers left. How are you going to put them in the castles? Well, you just forget about those 22 that you already put in there and just distribute the 38.  and however, many ways you can  For now, it would be 38 + 4 choose 4.  Okay, are there any questions about this one?  Turn of a simplified concept of how we're we're kind of taking the stars and bars and applying it to this thing. Just put those people aside and then feel everything.  What do you mean?  and women  that's what we're going to do for this one. That's this one here.  When is that for this problem? It's just you need to have at least 22 bricks or just take those out and put those aside and then deal with the rest. Okay, let's let's look a little bit trickier.  Okay, so  at most 22 brick pieces. Okay, so you definitely you can you can have 20 brick pieces or 9 brick pieces or 18 brick pieces, but you can't have more than 22 so that means you can't have 23 or more brick pieces.  Yeah, pretty much be a little a little careful careful.  So what you want to do is take no restrictions.  minus  at least 23, so it's not quite part part B.  At least 23 bricks.  Okay, so no restrictions is 60 + 4 choose 4 - now this is 37 + 4 choose 4.  64 choose 4 - 41 choose 4  Any questions about that?  Sure.  Tanner questions  Right because okay. So the the complement of this right the the negation of this.  is  at least  23 Brix  right  If I don't have at most 22, that means I have at least 23.  Yeah.  No, it would be at least 22. Yeah, it'll be at most 21.  Just doing like a different problem.  When was the first thing you do?  How many feet is 38 m?  ouu split up into four groups instead of five  Will that work?  So that would be it would be.  20  2 + 4 choose 4 plus  and it'll be 38.  38 + 4 choose 4  Call + 3 choose 3.  Well, there's one way to find out right.  Try generally do figure it out. And then and then try to argue that they're their equal, right?  So what is it 64 choose 4.  or  minus  41 choose 4  that's  534 106  Okay, then what's the other one?  26  choose  4  Plus  30 No 41  choose  3  No.  I want to think about why I write.  Haygood  What happens if you multiply them?  like these ones  you get a hundred and fifty-nine.  million  367  1000  Okay, let's move on.  okay, lexicographic ordering  queso  were mainly going to be talking about lexicographic ordering with binary strings, which is really quite fortunate for everybody because all you have to do is just compare them compare their numerical values. Okay. So one one number will come before the other number in lexicographic ordering if it's value is less than the other one.  Cancel this is just what I'm saying here today is less than be as binary numbers than a is before B lexicographically.  Okay. Now if you guys recall we found out we have a nice ranking algorithm, which if you give it a binary string a fixed density binary string then it will rank it for you. It'll tell you what its position is in lexicographic ordering. Okay, then we also have a nun ranking algorithm which is kind of just doing the opposite where you give it the position in the lexicographic ordering and it gives you the actual fix density binary string.  Okay, so let's do an example.  I maybe this is just the same one that we did before doesn't matter. Okay. So whenever we give you a ranking type algorithm will give you the fix density binary string and will also give you an end K. These are really important also have if you don't have these then you don't know what your ranking you don't know what list you're trying to put it in right when I guess you could just you could count the string, but we could we will give you this information.  Okay, so does anybody remember how to do this?  Okay, so what do I do?  Number them from starting from what?  Starting from 8 right going down.  And then what?  Number the number the ones from 4 down to one.  right, and then you get  these binomial coefficients to add together.  So we have a choose for which is 70.  Plus  20 + 3 + 1 which is 94. Is there any questions about this?  That's what I was going to just say.  is that  Here, let me see something.  Did you get it today?  We're going to give you this on the exam.  Okay, so you can see you can.  you can calculate all the any number from 1 to 20 choose any number from 0 to 6 Okay, so  okay, so let's let's  Let's just look at the example. I gave you right it was eight shoes for rent. That was the first one so I go down to rotate and I go over 1 2 3 4 hu470  Okay.  And then the next one was what 6 to 3. So I go six choose. 112-3623 is  30  wait a minute. This is  this is like there's a typo on this.  Well, I'm glad we looked at it.  I should be 20.  Okay. 623 s 20.  No, no calculators.  oh, wow, that's embarrassing what we just  whatever if you use the number on calculator, then you get the points.  Just go by what they have on here.  Okay.  Yeah, if the mistake comes from you to the table, you'll get the points but will tell everybody to change this to a twenty one I know is wrong.  I'm going to look over it again and try to make sure that it's all together.  Wow.  I blame that one on qualms.  Okay. So before we go though none ranking.  Okay. So on ranking is we're going to be given a position of a bit string that is of length and width K1. So we're going to give you an Inkay here also going to give a position and a number of onesies que queso set are to be p&l to BK and you do this kind of iterative thing where you subtract off these binomial coefficients from our  And then you subtract off one from K. So how does this look Let's do an example.  Are going to be 81 and K is going to be for. Okay, so our shoot.  Are is 81 K is for okay. So the first thing you do is you find the largest.  excuse for  value  Okay, how do we do that?  We look here. Okay.  I'm sorry the largest excuse for Value that is less than 81.  Okay, how do we do that? Where's my thing?  Okay. So we going to the four column right one is less than 81 for lesson 81 10 20 30 556. So 84 is bigger than 81. So 56 is the biggest one that's less than 81.  right  oh, this is the  right  This is okay. This is  8 choose 4  write this is the chews for column.  Okay, so we have this is 4 choose 4 as 1/5 choose for his 5624 is 15. +724-235-824-7924 isn't 12060 hu4 is the biggest one.  so we do our - 8 choose 4 is a r is equal to our -8 choose 4 which is 81 - 70 + K is equal to K - 1/4 equal 2/3  Okay. So now we we do the same thing with 70 + 3. No, sorry.  subtract 70  Which is what 11, right we do the same thing with 11 and 3.  Okay. So the three column +32-342-310-0523 is 10. So that's the biggest one that we can get, right.  So we have our is equal to our -5 choose 3.  which is 11 - 10 which is 1 K is equal to K - 1 which is  To so now we do it with one and two.  And you guys might be able to figure out what is the largest value choose to that's less than or equal to one.  Is to to choose to is less than or equal to one.  Okay, so we have our is equal to our -2 choose 2.  Has to choose two as one and that's one minus one.  less than or equal to  is equal to zero and then K is equal to K - 1 which is 1  Right, and now what's the biggest number choose one that is less than or equal to 0 its 0 choose 1.  Sor is equal to r - 0 choose one which is equal to 0 - 0 + K is equal to K - 1 which is 0  Okay, and then you just read off these values 0 to 5 and 8. So that means if I have  8 7 6 5 4 3 2 1 0 we put the ones in positions 852 + 0  and this weekend  Okay, so see you all tonight. "
}