{
    "Blurbs": {
        "- 1 x v Plus elog e okay, so the thing that kind of Dominates here is the Big O of B squared. Facebook better than what we had before, right? questions about that so in the worst case you have half of your vertices are of 1 L and a half of them around of another leader. So when you Union them you have to update half of the ": [
            1762.1,
            1809.3,
            44
        ],
        "1? questions about that cuz remember you're only Union in things when you're putting an edge into your output and Since your output is a tree you only have to put Envy -1 edges. was that b - 1 so that comes from this. Is that we're going to run this Loop? Until ex has the size V minus one because when when that when it happens when that happens, ": [
            1357.6,
            1400.6,
            33
        ],
        "I just want you to strive with the data structure will do not actually how to do it. But what are the sort of things that are necessary to look for? Okay. Ready go. And just the kind of help you along the way these are sort of the questions. I want you to think about. How do we know which Edge has the lightest Edge for one? And for ": [
            435.5,
            460.8,
            10
        ],
        "I put their ranks next to them. And if you noticed that their ranks actually correspond to The height of the tree that's below that vertex. And this is what the computer will store it will just or two arrays. One of them is going to be the rank array and the other is a parent array. So all those kind of things will be constant time if you want ": [
            2164.7,
            2189.0,
            56
        ],
        "Okay, so Okay, so here are the subroutines again and I just kind of summarize what we found so makes it basically creates a set with one element find you out put the name of the set that you belongs to and Union merges the sets containing you and me and then this is the run time. Okay good. So the first Disjoint set data structure. That's what this stands ": [
            1435.6,
            1472.0,
            35
        ],
        "Okay, so Up to Wednesday's lecture. No last Wednesday. Yeah. You know. Are the cheat sheet? And I'll write it on the thing now, it's working. how to do this Oh, man. I think I'll be okay. Figure out a better way to do this. Okay, let's see, I guess before we begin. Let's talk about the cheat sheet. You are allowed. 1 cited sheet of handwritten notes for the ": [
            6.7,
            116.0,
            0
        ],
        "Okay. So version 2 is Union by rank or you may have seen it as Union find I think you guys did it in 1/100 in the idea here is that each one of these disjoint sets is a tree and in each tree has a route, right and the route is going to be the leader of the set now they so how does that help us out? How ": [
            2057.7,
            2081.6,
            52
        ],
        "She's just running fine twice and then when you when you point one to the other that just takes constant time. Okay, so let's build some trees here. Okay, so we first start with all just all the vertices by themselves. And let's just put their ranks right here. Okay, so let's start this off. Well, remember that we have all of the edges in increasing order. So just go ": [
            2463.2,
            2508.1,
            65
        ],
        "So Union them. So then we have a b c a e f e. Okay, so then let's say we do this one next. Weconnect D&G. So the first thing we ask is find D and the result is a use find G. The result is e there different leaders. So that means they're in different sets. And now I have to update all of one sets leaders to the ": [
            1938.3,
            1974.7,
            49
        ],
        "So this bound here is it's sort of a it's not a very tight upper bound, right so we can make it a little bit tighter by being a little bit more careful about what our structures are going to be. Okay. So actually you're starting with a very with an empty graph and you're starting to add weights at edges as you go, right and this graph will never ": [
            762.2,
            789.5,
            17
        ],
        "So you're going to see that find you actually takes constant time. Yeah. This one is going to be like heavy on the union think that's really going to think the thing is going to take the most time. No, because you're going to have to work with everyone that has the same meter SP. And where it's it's good you're going to see that it's like a lot like ": [
            1622.7,
            1648.3,
            40
        ],
        "They sort the edges and increasing order then for every Edge going in the order. You just keep on putting it in until all the edges are in the same set. And the idea here is you're going to use these routines which are find. Remember what fine does it tells you the name of the set that it belongs to so if the name of the set of V ": [
            1052.7,
            1077.9,
            26
        ],
        "We're going to implement it in two different ways. Okay. So what can it do is basically it can manage a a set of objects into disjoint subsets. And so what can it do is basically For each object you can ask what the name of it set is that it belongs to and you can Union two sets. stop Let's think about how would we go about using disjoint ": [
            850.9,
            885.5,
            20
        ],
        "a few minutes. See if you can figure out what is in the worst-case. How many times am I going to call find you? Talk it over with your neighbor? Okeechobee radar What's the number one hit by yesterday that I have to go in at? Okay, what you guys come up with? 2 * e Wright at the very worst, you're going to have to call this line e ": [
            1213.2,
            1307.6,
            31
        ],
        "a lot of anticipation for the correctness proof of prims algorithm. We're not going to get to it today. But just wait and we'll we'll do it on what's today. Maybe we might not do it on Wednesday, but we'll start talking about it. The reason that we haven't done it yet is because I want to present to you a Amor sort of structural structured way to prove greedy ": [
            177.4,
            209.6,
            2
        ],
        "about be? So the leader of B is a the leader of Eazy-E. They both have the same rank. So then you point one to the other in increment was just let's just draw it out again. I guess I'll just keep a as the root. these ones are cerasum I got any questions about that move. And then you guys can finish off the rest. It's just a kind ": [
            2611.1,
            2670.5,
            69
        ],
        "algorithms. And with that you can prove almost any greedy algorithm using the sort of step by step process to all of you guys who are kind of struggling through how to prove these algorithms that you're doing on the homework. The crews are going to the proofs are now going to be more structured because we're going to be building algorithms that have similar structures. Okay. So let's look ": [
            209.6,
            234.2,
            3
        ],
        "an eraser. This is constant. This is good. How long does it take to Union? Right. So in the worst case is Big O of Big Love V in the worst-case, right? Okay. So then the total time of of the leader will be well, let's just pull up this something here. We have v x Big O of 1 + 2 x e x Big Love 1 + V ": [
            1717.5,
            1762.1,
            43
        ],
        "at another algorithm prims algorithm is actually a greedy algorithm and we'll talk about what that means today in more detail, but we're going to do a much more direct greedy Choice. Okay. So we're trying to find the minimum spanning tree. So let's just pick the first greedy Choice with the first choice of an edge to make this the minimum spanning tree queso. The first edge of going ": [
            234.2,
            259.4,
            4
        ],
        "by that so the first one we're going to start with a D that's equal to 1. A & D both have the same rank. So it doesn't matter. Which one do you point to the other? I guess it does if you're following the pseudocode, but it doesn't really make too much of a difference is let's say that let's say a is the route now Okay, good. Alright, ": [
            2508.1,
            2537.7,
            66
        ],
        "by wait, right? If you sort of by weight from smallest to largest, then you can just go into the list and keep on pulling them off right and then for each one test it and that will take Time Square time there any questions about that implementation? It's not the best but it does it does the job. Okay. What is this one that I put? Oh, right. Okay. ": [
            721.4,
            762.2,
            16
        ],
        "dense the graph is right is B squared better than elog be on Wednesday will look at how to make this a little bit faster under a certain circumstance and then we'll go on to how to prove these correct. ": [
            2931.2,
            2948.0,
            78
        ],
        "does that make it any better? The idea here is that we're going to keep these tree short so that in order to find the leader. You just have to go up the tree until you find the route and if the trees are short enough then that operation will be quick. So let's look at how it works. So the vertices on the trees are the elements of the ": [
            2081.6,
            2115.6,
            53
        ],
        "doesn't actually tell you anything about the structure of the tree. It just gives you a an idea of how long the tree is that's hanging from that vertex and that's going to be important in order to keep the heights of the trees short as usual as you'll see. Okay, so here's kind of an idea of maybe how it would look so here is a bunch of vertices. ": [
            2139.0,
            2164.7,
            55
        ],
        "for disjoint. Set data structure. The reason why I'm going to call the leader, okay, and this is how it works. For each vertex. You keep an array called leader. And the leader is one of the One representative from the set guy. So each set has a representative and that's the name of the set. I want you guys to think about how would you implement this and how ": [
            1472.0,
            1508.0,
            36
        ],
        "get bigger than a tree and a tree has at most and -1 edges. So really every time you run Graph Search on that graph. It really only takes big O of n time write the number of the number of vertices because the graph is going to be very sparse all the time. So that that gives us a tighter bound of n + n * m which is ": [
            789.5,
            816.7,
            18
        ],
        "graph and an edge, you can tell me if it's in a cycle, right? Okay, good. Let's let's think about that first and then we'll try to move our way into more and more efficient ways to do it. Okay. So how do we tell if adding an edge will create a cycle? Well, you can just the naive way to do is just do what you did in homework ": [
            634.6,
            657.9,
            13
        ],
        "half of the vertices to make them all the same thing. Yeah, and so B / 2 is Big O of B. That's not it. That's not a dumb question. How do you know which leader to choose and sort of doesn't really matter. I guess if you want you can always if you have Union UV Maybe you take that as I can as like the order matters and ": [
            1810.7,
            1841.6,
            45
        ],
        "has a representative from the set and that represented is the is the name. It's the leader. Got a random. Yeah, it's random, but it needs to be the same for everybody in the set. Yeah, I mean maybe you could say that the leader is the first letter in the alphabet in the set. or something Yes. What the leader is and how do you know what the actual ": [
            1542.5,
            1593.8,
            38
        ],
        "has height. k + 1 so there you have it. That's it. That's just Okay, so that's good. Let's do one more little proof here that has to do with how many vertices can you expect to have in a tree of rank? K k so I claimed that any node of rank K has at least two the caver to season it and it was just do it by ": [
            2775.4,
            2804.1,
            73
        ],
        "here? And why is a taller tree? What's going to be the best direction that I go? Should I make sure I point the root of x to y or should I point the root of y 2x? Which one should be the parent? Why right because if if the Y tree is actually bigger than if I'd Point x2y like that. I really haven't made the tree any any ": [
            2285.7,
            2315.1,
            60
        ],
        "how it looks like in your book so you can use that as a reference. Okay, so we're going to make make the set of each vertex by itself. That's this one. pick a set vertex by itself and then we're going to initialize this except this is going to be our output. It's just going to be at the end is going to be a a collection of edges. ": [
            1021.2,
            1052.7,
            25
        ],
        "induction again a root of rank 0 has one vertex. Oh, that's good. So now let's suppose any root of rank has at least two to the cave vertices. consider a route with Kate of rank k + 1 how did it get to be K plus one is when you Union to rank a vertices and if both of those have at least two to the K and when ": [
            2804.1,
            2826.9,
            74
        ],
        "is Big O of the squared. I want to just kind of give you a sense of of how it's going to work for just a few iterations. Okay, so we have a b c d e f g. Okay, so they also this is the leader of Ray. They all start off as their own leader. And then you go through the edges in order. So ad is equal ": [
            1870.9,
            1906.2,
            47
        ],
        "is how we're going to implement this algorithm? Okay, so maybe we'll do this example in a minute. So you're sort of a very high level. description start with a graph with only the vertices repeatedly add the next light is as it does not form recycle and then I guess That was kind of enough right? Because once you're done any Edgewood for my cycle Okay, so let's go ": [
            380.1,
            409.4,
            8
        ],
        "is the same as the name of the set of you than they're connected if they're not then add the edge 2X and Union the two sets. Okay, so backed up some facts about the trees that might help us later on. Okay. So what is a tree we're talking about undirected graphs? It's a it's a undirected connected graph with no Cycles. So a few things that you can ": [
            1077.9,
            1105.8,
            27
        ],
        "it gets the job done. You don't really even have to think too hard about how to implement it right. You just take whatever you did from homework 1 and just do it every time you put in a new Edge. Oh, did we go over this? Oh, yeah. Sorry. Okay. We have the answer to both of these questions. To the first question is answered by sorting the edges ": [
            696.2,
            721.4,
            15
        ],
        "kind of a little bit lower. Well, this is sort of the same thing. Given your graph with positive Edge weight start with only the vertices repeat until the graph is connected. Add the latest age does not criticize us. What I want you guys to do now is talk about what kind of things would we need in a date of structure to implement crystals. Okay, I just love ": [
            409.4,
            435.5,
            9
        ],
        "let's plug in the values here. Make set is going to be now Big O of 1. Find and Union are both log of V. And sorting is elog V. So that means our run time we get is Big O of elog V. Okay, so that's that's better than what is that better than what we had before it's sort of like the same trade-off with how sparse or ": [
            2899.4,
            2931.2,
            77
        ],
        "long each one of these would take? Okay. Let me know if you have questions if you have questions on how it works, but just think about it as like at the beginning every vertex is its own leader. And then as you start Union in things you have to update their array values to be the actual name of the set ready go. Yasso every set every disjoint set ": [
            1508.0,
            1542.5,
            37
        ],
        "making a set for each vertex. That's just going to take constant time for pervert X, right? Let's just assigning the vertex to its its own leader. Peso 01 pervert X. How long does it take to do find? Wall, like individually for a particular vertex. How long does it take to cognac it takes two. Ask for what is this leaders just constant time right? Cuz this is just ": [
            1680.9,
            1717.5,
            42
        ],
        "maybe the next one you do is this one BC so then you put B and C together. thanks for this gives you a good idea of how to how to transfer transfer the figuring out of something creates a cycle into keeping track of vertices by which set there in okay. So this is a this is sort of like a mid-level code. This is actually very close to ": [
            992.8,
            1021.2,
            24
        ],
        "of give you an idea of how it works. Oh, I should feel this in right now. Okay. Yeah, and then okay, so just have a few more minutes here. I just want to do a few proofs on properties of these ranks. Okay. So first of all, the ranks actually correspond to the heights of the trees, let's just proved it real fast. Okay. So the base case of ": [
            2670.5,
            2705.7,
            70
        ],
        "one you put that one vertex does give these names. Right, once you put that one vertex are there. Will you say that A and B are both connected? Okay. Well, yeah, we'll talk about that in a minute and the other ideas are comments. So you could run browser. Okay, good. You guys are already did this right in your homework, right? You can if I give you a ": [
            596.9,
            634.6,
            12
        ],
        "one, right? That's going to take a big O of M. time so you actually need to test it for every Edge. Right, cuz every time you put it a gin and you have to run the scrap search. So this is on the order of Big O of M squared time where and his number of edges Okay, so sort of like a naive way to do it. It's ": [
            657.9,
            696.2,
            14
        ],
        "other set. So let's just say there all day. c a a a f And so on. K questions You got to update them so that they're all the same leader because the the the strength of this is that I can call up the leader value and constant time. So now if you ask me are Are D&G connected I can just say OK Dee's leaders. Agee's leaders are ": [
            1974.7,
            2026.5,
            50
        ],
        "parent of the route is it sell this let's just say that follow parents until you get to route. I put Because the route is the name of the set. Okay, and then we have Union and its little bit more complicated. But let's just go through it really fast. So the first thing you do is you find the root of x you find the root of Y. And ": [
            2221.8,
            2255.3,
            58
        ],
        "put everybody in a set by itself. and so on right then and you and you order the weights or the or the edges by weight or the first Edge, we're going to put it in as let's say we put in EG Okay, we put in that edge. We Union the set that he belongs to to the set that she belongs to okay. So now we have a ": [
            929.3,
            959.0,
            22
        ],
        "quiz the quiz coverage quiz one will cover. What was the lecture on Wednesday? That was the one two three four, five six, seven eight. No cuz we had at holiday 7. one through seven lectors any questions Yeah, just a sheet of paper. Okay. So let's continue along this thing with the minimum spanning trees. We saw prim's algorithm last time and I know that everybody is is holding ": [
            116.0,
            177.4,
            1
        ],
        "ranks are equal then then actually increments the rank of the new route by one and it points the smaller to the bigger does the only way that rent can increase or decrease? Okay. So what are the run times here will make set is big old one / / vertex and find really it depends on the height of the tree right question. That's a typo. Yeah, I think. ": [
            2364.7,
            2415.2,
            63
        ],
        "right so log and is the highest you can possibly have if you have an vertices in your tree with this down. That means all of those operations will only take login time because all those operations are basically you start from whatever vertex you are at and you follow the parents up to the roof. okay, so maybe maybe we'll maybe we'll do one more thing here. Sorry. So ": [
            2860.9,
            2899.4,
            76
        ],
        "ruler? The positions that are rated holding movie. Yeah, how do you know what the actual f? Yeah, so the vertices are always just let's just say they're ordered in alphabetical order. So like yeah, there's like a fixed order of the vertices. So if I want like what's the leader of vertex W then I just go down to like the 20th. Thing and I can pull it up. ": [
            1593.8,
            1622.7,
            39
        ],
        "run time. We must keep the heights of the trees short. Intro to do this you look at the ranks. That's why we're keeping track of that value is so that we can we can know the height of the tree very quickly you can you can ask for that and comes the time. So if one is bigger than the other you point it to the parent if the ": [
            2344.3,
            2364.7,
            62
        ],
        "say about trees is that every time you remove an edge from a tree you'll get a disconnected graph. Also every tree on N vertices always has and -1 edges that's going to be helpful to because we know exactly how many how big that's that output set will be And then three in a tree there's always only one path between two nodes and how do you one way ": [
            1105.8,
            1136.0,
            28
        ],
        "set egg. And we do it again with A&D so we don't have a by itself anymore. We have a d. And so on. So maybe the next Edge that we see is this too in that sense or we're going to do next is Union the set that she belongs to end the set that she belongs to and then you get this big set. Haydee G and then ": [
            959.0,
            992.8,
            23
        ],
        "set. I need to bring to a parent that eventually points to the root the root points to itself. That's how you know, it's the leader and the route is the convenient name. Okay, so we're going to look at them as trees. But how does the computer hold the information? It just actually holds it in two different arrays the parent array and the rank array. Now the rain ": [
            2115.6,
            2139.0,
            54
        ],
        "sets when we were doing this algorithm? I can't wait. Let me just look at this real fast. I think it's a good place to do the example. Okay. Priceline Okay, so let's look at what this looks like just using sets right? We're kind of abstracting it and then we'll go down to how to how do you implement it? Okay. So the first thing you do is you ": [
            885.5,
            929.3,
            21
        ],
        "shoes Toriko if Frank X is bigger than rank why you want to make The parent of Ry RX so that one's right. Otherwise, this one's wrong. otherwise RX should be r y actor equal then it doesn't really matter. Okay. Thank you for that. Okay, so fine depends on the height of the tree containing X, right and you Union is just basically the same run time as fine. ": [
            2417.3,
            2463.2,
            64
        ],
        "so you say okay. I'm going to set all of use vertices to the leader of v and you can just always do it that way. Or you could always say make everybody have the leader. That's the first letter in the alphabet of the set or anything like that. Either way. It's going to take time to update whichever way you you choose. Okay, so this is good. This ": [
            1841.6,
            1870.9,
            46
        ],
        "still not great. But at least you know, you get a better sense. You get a more tighter worst case scenario. Okay. All right. So let's talk about the disjoint sets data structure. So this is is another way to implement it and just like priority queue. We're going to think about the disjoint set data structure as a concept and think about a few different ways to implement it. ": [
            816.7,
            850.9,
            19
        ],
        "taller. You just added one extra Edge. What's the only way that the tree can actually get taller? Right. If you add two trees of the same size then you know, you don't really have a choice. I mean you can you can choose either one, but the height of the tree is going to increase by only one Edge The Edge that connects the two fruits. Talk to Savon ": [
            2315.1,
            2344.3,
            61
        ],
        "the next lightest Edge is this three-year right But there's also this three. Would it be wise for me to pick that one? No, because it creates a cycle. So now we have to kind of tweaked or definition of what are greedy choice is don't just keep on picking the lightest Edge without looking right pick only the lightest Edge if it doesn't make a cycle fit the smallest ": [
            293.7,
            325.7,
            6
        ],
        "the next one is eg. So let's take off these my screen. EG would be I guess he like this. And g0 okay. Next one is a b or take that one now. He has ranked 08 has rank one. So there's no there's no choice here. You just let a be the parent of be like that Okay, that's good. Alright AC is too so same thing. AC sorry ": [
            2537.7,
            2580.1,
            67
        ],
        "then what you what you want to do is point the root of x to the root of Y or the root of life to the root of x and which way are you going to do it? You want to do it in such a way that minimizes the height of the tree? so let's say that I have the root of x here. And the root of why ": [
            2255.3,
            2285.7,
            59
        ],
        "to get that path is to just run DFS on the tree? Okay. So let's see that I make that I make this same thing again. Oh, yeah. So now instead of saying do this over and over again until the the set is connected really. All we have to do is put a bow non how big X can get? Okay. So just do this until X is equal ": [
            1136.0,
            1164.1,
            29
        ],
        "to one. So you Union a d so that means in the in this iteration you said both of these leaders to a I could have chosen D2. It doesn't really matter. You just needs to be the same. And all these guys stay the same. The next one is eg? That's one. Basically, what we're going to do is say find is he find G is G there different. ": [
            1906.2,
            1938.3,
            48
        ],
        "to pick is the lightest Thanks, so that's one. Okay, so I'm first going to pick one. All right. So in a greedy algorithm you just keep on picking the quote on quote greedy choice. So I'm going to pick the next lightest Ash which is going to be well, I have a choice here. So let's just pick both of them. Okay. okay, so then we keep on going ": [
            259.4,
            293.7,
            5
        ],
        "to the number of vertices minus one that's going to help us with the runtime analysis also. Okay, so This makes a Vortec this makes it make sense of makes a Vertex into a set for each vertex. So this is v x how long it takes to do make set. Okay. This thing sorts all the edges. right now how many times am I going to call find? Take ": [
            1164.1,
            1213.2,
            30
        ],
        "to update the information. Okay, so These are these are just right out of the book make the set. All you do is set the parent to be itself and set the rank to be zero case. It'll just take constant time per for Texas. That's good. I find this basically just means you follow your parents up to the route and you know, you're at the route because the ": [
            2189.0,
            2221.8,
            57
        ],
        "two, how do we know that that particular Edge does not create a cycle? You want this chair? This is for my jacket. Has anybody have any ideas they like to share? Seattle priority queue for the lightest Edge. Okay, that's fine. Where is it next to? disconnected Okay, there's going to be a problem there though. What happens if you have a graph like this? Okay. So the first ": [
            460.8,
            596.9,
            11
        ],
        "vertex by itself has rank 0 the height of a tree is zero. So that's fine. So let's suppose that every vertex of rank K has a tree of heike rank hanging from it. Okay. So now if I have a vertex of rank Kate plus one, the only way that it could have been Kate plus one is if it were K before and then you Union did it ": [
            2705.7,
            2728.9,
            71
        ],
        "weight Edge. with the restriction that it does not create a cycle. Okay good. So that means so I'll pick a 4 but not this for I'll pick this for here. Actually, that's all I need. When do you know you're done? Well, we'll talk about that two more kind of rules about trees. Okay, so we pick those all okay. so I want you guys to think about what ": [
            325.7,
            380.1,
            7
        ],
        "what we did for. The binary Heat versus the array like one of them is really like fast to look up but then it takes a long time to update. Whereas the other day to structure. We're going to look at today. It's fast and both things. Right, but it's log fast. It's not constant fast. So that's the sort of the idea questions. Okay, let's take a look. So ": [
            1648.3,
            1680.9,
            41
        ],
        "with another tree of hike k And so when that happens you get the height K plus one extra Edge. Strong little picture about that. I think they'll be helpful. Hey, so if I have this tree of heike. And this tree is also a hike k. Right. When I point this over there, then I have the height of that Edge Plus the whole K. So now this vertex ": [
            2728.9,
            2775.4,
            72
        ],
        "wrong one see Hey like that. Okay, and then BC. So what happens when you do BC when you look at that edge is you you find the the leader of B, which is a you find a liter of C is also a so they both have the same leader. So you just take away that edge and you don't you don't put it in exit out. Okay, how ": [
            2580.1,
            2611.1,
            68
        ],
        "x Rank and then you have to call fine for each one. Any questions about that? 2 x e x find well, the very best actually will be v x Because this algorithm. Once you've gotten your tree, so could be like the first V edges would would make your whole tree. Okay, you're so good. How many times are you going to run Union? What is that V - ": [
            1307.6,
            1357.6,
            32
        ],
        "yes, they're connected cuz it's the same. So for that reason you want to update them all. Okay, let's move on to another data structure. This is just what we did and we tried to for better. Why continue what we want to optimize it for other uses as well. So and I think that it's kind of fun to kind of keep on trying to get better and better. ": [
            2026.5,
            2057.7,
            51
        ],
        "you Union them, the result has at least to the K plus one. So this actually gives us a bound on how high the tree can be. Thanks. This is kind of the last thing will do so suppose. They are and vertices right I a route of rank login. Has at least and vertices in its tree a root of any higher rank has at least more than an ": [
            2826.9,
            2860.9,
            75
        ],
        "you know that your graph is a tree. Yeah, exactly. That's just because find is the is there twice? Is this big o a t e x find? Okay good. So just like we did with dijkstra's now we kind of have like a scaffolding of where we can kind of hang different subroutines and we know how fast is going to run based on how fast those subroutines are. ": [
            1400.6,
            1435.6,
            34
        ]
    },
    "File Name": "Design___Analysis_of_Algorithm___A00___Jones__Miles_E___Winter_2019-lecture_9.flac",
    "Full Transcript": "Okay, so Up to Wednesday's lecture. No last Wednesday. Yeah.  You know.  Are the cheat sheet?  And I'll write it on the thing now, it's working.  how to do this  Oh, man.  I think I'll be okay.  Figure out a better way to do this.  Okay, let's see, I guess before we begin. Let's talk about the cheat sheet.  You are allowed.  1  cited  sheet  of handwritten  notes  for the quiz  the quiz coverage quiz one will cover. What was the lecture on Wednesday? That was the one two three four, five six, seven eight. No cuz we had at holiday 7.  one through seven  lectors  any questions  Yeah, just a sheet of paper.  Okay. So let's continue along this thing with the minimum spanning trees. We saw prim's algorithm last time and I know that everybody is is holding a lot of anticipation for the correctness proof of prims algorithm. We're not going to get to it today. But just wait and we'll we'll do it on what's today.  Maybe we might not do it on Wednesday, but we'll start talking about it. The reason that we haven't done it yet is because I want to present to you a Amor sort of structural structured way to prove greedy algorithms. And with that you can prove almost any greedy algorithm using the sort of step by step process to all of you guys who are kind of struggling through how to prove these algorithms that you're doing on the homework. The crews are going to the proofs are now going to be more structured because we're going to be building algorithms that have similar structures.  Okay.  So let's look at another algorithm prims algorithm is actually a greedy algorithm and we'll talk about what that means today in more detail, but we're going to do a much more direct greedy Choice. Okay. So we're trying to find the minimum spanning tree. So let's just pick the first greedy Choice with the first choice of an edge to make this the minimum spanning tree queso. The first edge of going to pick is the lightest  Thanks, so that's one. Okay, so I'm first going to pick one.  All right. So in a greedy algorithm you just keep on picking the quote on quote greedy choice. So I'm going to pick the next lightest Ash which is going to be well, I have a choice here.  So let's just pick both of them.  Okay.  okay, so then we keep on going the next lightest Edge is  this three-year  right  But there's also this three.  Would it be wise for me to pick that one?  No, because it creates a cycle. So now we have to kind of tweaked or definition of what are greedy choice is don't just keep on picking the lightest Edge without looking right pick only the lightest Edge if it doesn't make a cycle fit the smallest weight Edge.  with  the restriction  that  it does not create a cycle. Okay good. So that means so I'll pick a 4 but not this for I'll pick this for here. Actually, that's all I need.  When do you know you're done? Well, we'll talk about that two more kind of rules about trees. Okay, so we pick those all okay.  so I want you guys to  think about  what is how we're going to implement this algorithm? Okay, so maybe we'll do this example in a minute. So you're sort of a very high level.  description start with a graph with only the vertices repeatedly add the next light is as it does not form recycle and then I guess  That was kind of enough right? Because once you're done any Edgewood for my cycle  Okay, so let's go kind of a little bit lower.  Well, this is sort of the same thing.  Given your graph with positive Edge weight start with only the vertices repeat until the graph is connected.  Add the latest age does not criticize us. What I want you guys to do now is talk about what kind of things would we need in a date of structure to implement crystals.  Okay, I just love I just want you to strive with the data structure will do not actually how to do it. But what are the sort of things that are necessary to look for? Okay. Ready go.  And just the kind of help you along the way these are sort of the questions. I want you to think about. How do we know which Edge has the lightest Edge for one? And for two, how do we know that that particular Edge does not create a cycle?  You want this chair? This is for my jacket.  Has anybody have any ideas they like to share?  Seattle priority queue for the lightest Edge. Okay, that's fine.  Where is it next to?  disconnected  Okay, there's going to be a problem there though.  What happens if you have a graph like this?  Okay. So the first one you put that one vertex does give these names.  Right, once you put that one vertex are there. Will you say that A and B are both connected?  Okay. Well, yeah, we'll talk about that in a minute and the other  ideas are comments.  So you could run browser.  Okay, good. You guys are already did this right in your homework, right? You can if I give you a graph and an edge, you can tell me if it's in a cycle, right?  Okay, good. Let's let's think about that first and then we'll try to move our way into more and more efficient ways to do it.  Okay. So how do we tell if adding an edge will create a cycle? Well, you can just the naive way to do is just do what you did in homework one, right? That's going to take a big O of M.  time  so you actually need to test it for every Edge.  Right, cuz every time you put it a gin and you have to run the scrap search. So this is on the order of  Big O of M squared time where  and his number  of edges  Okay, so sort of like a naive way to do it. It's it gets the job done. You don't really even have to think too hard about how to implement it right. You just take whatever you did from homework 1 and just do it every time you put in a new Edge.  Oh, did we go over this? Oh, yeah. Sorry. Okay. We have the answer to both of these questions.  To the first question is answered by sorting the edges by wait, right? If you sort of by weight from smallest to largest, then you can just go into the list and keep on pulling them off right and then for each one test it and that will take Time Square time there any questions about that implementation?  It's not the best but it does it does the job.  Okay.  What is this one that I put?  Oh, right. Okay. So this bound here is it's sort of a it's not a very tight upper bound, right so we can make it a little bit tighter by being a little bit more careful about what our structures are going to be. Okay. So actually you're starting with a very with an empty graph and you're starting to add weights at edges as you go, right and this graph will never get bigger than a tree and a tree has at most and -1 edges. So really every time you run Graph Search on that graph.  It really only takes big O of n time write the number of the number of vertices because the graph is going to be very sparse all the time.  So that that gives us a tighter bound of n + n * m which is still not great. But at least you know, you get a better sense.  You get a more tighter worst case scenario.  Okay.  All right. So let's talk about the disjoint sets data structure. So this is is another way to implement it and just like priority queue. We're going to think about the disjoint set data structure as a concept and think about a few different ways to implement it. We're going to implement it in two different ways. Okay. So what can it do is basically it can manage a a set of objects into disjoint subsets. And so what can it do is basically  For each object you can ask what the name of it set is that it belongs to and you can Union two sets.  stop  Let's think about how would we go about using disjoint sets when we were doing this algorithm?  I can't wait. Let me just look at this real fast.  I think it's a good place to do the example.  Okay.  Priceline  Okay, so let's look at what this looks like just using sets right? We're kind of abstracting it and then we'll go down to how to how do you implement it?  Okay. So the first thing you do is you put everybody in a set by itself.  and so on right then and you and you order the weights or the or the edges by weight or the first Edge, we're going to put it in as let's say we put in EG  Okay, we put in that edge. We Union the set that he belongs to to the set that she belongs to okay. So now we have a set egg.  And we do it again with A&D so we don't have a by itself anymore. We have a d.  And so on.  So maybe the next Edge that we see is this too in that sense or we're going to do next is Union the set that she belongs to end the set that she belongs to and then you get this big set.  Haydee  G and then maybe the next one you do is this one BC so then you put B and C together.  thanks for this gives you a good idea of how to how to transfer transfer the figuring out of something creates a cycle into keeping track of vertices by which set there in  okay.  So this is a this is sort of like a mid-level code. This is actually very close to how it looks like in your book so you can use that as a reference.  Okay, so we're going to make make the set of each vertex by itself. That's this one.  pick  a set  vertex by itself  and then we're going to initialize this except this is going to be our output. It's just going to be at the end is going to be a a collection of edges. They sort the edges and increasing order then for every Edge going in the order.  You just keep on putting it in until all the edges are in the same set. And the idea here is you're going to use these routines which are find.  Remember what fine does it tells you the name of the set that it belongs to so if the name of the set of V is the same as the name of the set of you than they're connected if they're not then add the edge 2X and Union the two sets.  Okay, so backed up some facts about the trees that might help us later on.  Okay. So what is a tree we're talking about undirected graphs? It's a it's a undirected connected graph with no Cycles. So a few things that you can say about trees is that every time you remove an edge from a tree you'll get a disconnected graph. Also every tree on N vertices always has and -1 edges that's going to be helpful to because we know exactly how many how big that's that output set will be  And then three in a tree there's always only one path between two nodes and how do you one way to get that path is to just run DFS on the tree?  Okay. So let's see that I make that I make this same thing again.  Oh, yeah. So now instead of saying do this over and over again until the the set is connected really. All we have to do is put a bow non how big X can get? Okay. So just do this until X is equal to the number of vertices minus one that's going to help us with the runtime analysis also.  Okay, so  This makes a Vortec this makes it make sense of makes a Vertex into a set for each vertex. So this is v x how long it takes to do make set.  Okay.  This thing sorts all the edges.  right  now  how many times am I going to call find?  Take a few minutes. See if you can figure out what is in the worst-case. How many times am I going to call find you? Talk it over with your neighbor?  Okeechobee radar  What's the number one hit by yesterday that I have to go in at?  Okay, what you guys come up with?  2 * e Wright  at the very worst, you're going to have to call this line e x  Rank and then you have to call fine for each one.  Any questions about that?  2 x e x find  well, the very best actually will be v x  Because this algorithm. Once you've gotten your tree, so could be like the first V edges would would make your whole tree.  Okay, you're so good. How many times are you going to run Union?  What is that V - 1?  questions about that  cuz remember you're only Union in things when you're putting an edge into your output and  Since your output is a tree you only have to put Envy -1 edges.  was that  b - 1  so that comes from this.  Is that we're going to run this Loop?  Until ex has the size V minus one because when when that when it happens when that happens, you know that your graph is a tree.  Yeah, exactly.  That's just because find is the is there twice?  Is this big o a t e x find?  Okay good. So just like we did with dijkstra's now we kind of have like a scaffolding of where we can kind of hang different subroutines and we know how fast is going to run based on how fast those subroutines are. Okay, so  Okay, so here are the subroutines again and I just kind of summarize what we found so makes it basically creates a set with one element find you out put the name of the set that you belongs to and Union merges the sets containing you and me and then this is the run time.  Okay good. So the first  Disjoint set data structure. That's what this stands for disjoint.  Set data structure.  The reason why I'm going to call the leader, okay, and this is how it works.  For each vertex. You keep an array called leader. And the leader is one of the  One representative from the set guy. So each set has a representative and that's the name of the set. I want you guys to think about how would you implement this and how long each one of these would take? Okay. Let me know if you have questions if you have questions on how it works, but just think about it as like at the beginning every vertex is its own leader. And then as you start Union in things you have to update their array values to be the actual name of the set ready go.  Yasso every set every disjoint set has a representative from the set and that represented is the is the name. It's the leader.  Got a random. Yeah, it's random, but it needs to be the same for everybody in the set.  Yeah, I mean maybe you could say that the leader is the first letter in the alphabet in the set.  or something  Yes.  What the leader is and how do you know what the actual ruler?  The positions that are rated holding movie.  Yeah, how do you know what the actual f?  Yeah, so the vertices are always just let's just say they're ordered in alphabetical order. So like yeah, there's like a fixed order of the vertices. So if I want like what's the leader of vertex W then I just go down to like the 20th.  Thing and I can pull it up. So you're going to see that find you actually takes constant time. Yeah.  This one is going to be like heavy on the union think that's really going to think the thing is going to take the most time.  No, because you're going to have to work with everyone that has the same meter SP.  And where it's it's good you're going to see that it's like a lot like what we did for.  The binary Heat versus the array like one of them is really like fast to look up but then it takes a long time to update. Whereas the other day to structure. We're going to look at today. It's fast and both things.  Right, but it's log fast. It's not constant fast. So that's the sort of the idea questions.  Okay, let's take a look. So making a set for each vertex. That's just going to take constant time for pervert X, right?  Let's just assigning the vertex to its its own leader. Peso 01 pervert X.  How long does it take to do find?  Wall, like individually for a particular vertex. How long does it take to  cognac it takes two.  Ask for what is this leaders just constant time right? Cuz this is just an eraser. This is constant. This is good. How long does it take to Union?  Right. So in the worst case is Big O of  Big Love  V  in the worst-case, right?  Okay. So then the total time of of the leader will be well, let's just pull up this something here. We have v x Big O of 1 + 2 x e x Big Love 1 + V - 1  x v  Plus  elog e  okay, so the thing that kind of  Dominates here is the Big O of B squared.  Facebook better than what we had before, right?  questions about that  so in the worst case you have  half of your vertices are of  1 L and a half of them around of another leader. So when you Union them you have to update half of the  half of the vertices  to make them all the same thing. Yeah, and so  B / 2 is Big O of B.  That's not it. That's not a dumb question. How do you know which leader to choose and sort of doesn't really matter. I guess if you want you can always if you have Union UV  Maybe you take that as I can as like the order matters and so you say okay. I'm going to set all of use vertices to the leader of v and you can just always do it that way.  Or you could always say make everybody have the leader. That's the first letter in the alphabet of the set or anything like that. Either way. It's going to take time to update whichever way you you choose.  Okay, so this is good. This is Big O of the squared.  I want to just kind of give you a sense of of how it's going to work for just a few iterations.  Okay, so we have a b c d e f g.  Okay, so they also this is the leader of Ray.  They all start off as their own leader.  And then you go through the edges in order. So ad is equal to one.  So you Union a d  so that means in the in this iteration you said both of these leaders to a  I could have chosen D2. It doesn't really matter. You just needs to be the same.  And all these guys stay the same.  The next one is eg? That's one.  Basically, what we're going to do is say find is he find G is G there different. So Union them.  So then we have a b c a e f e.  Okay, so then let's say we do this one next.  Weconnect D&G. So the first thing we ask is find D and the result is a use find G. The result is e there different leaders. So that means they're in different sets. And now I have to update all of one sets leaders to the other set.  So let's just say there all day.  c a a a f  And so on.  K questions  You got to update them so that they're all the same leader because the the the strength of this is that I can call up the leader value and constant time. So now if you ask me are  Are D&G connected I can just say OK Dee's leaders. Agee's leaders are yes, they're connected cuz it's the same. So for that reason you want to update them all.  Okay, let's move on to another data structure.  This is just what we did and we tried to for better. Why continue what we want to optimize it for other uses as well. So and I think that it's kind of fun to kind of keep on trying to get better and better. Okay. So version 2 is Union by rank or you may have seen it as Union find I think you guys did it in 1/100 in the idea here is that each one of these disjoint sets is a tree and in each tree has a route, right and the route is going to be the leader of the set now they so how does that help us out? How does that make it any better?  The idea here is that we're going to keep these tree short so that in order to find the leader. You just have to go up the tree until you find the route and if the trees are short enough then that operation will be quick.  So let's look at how it works.  So the vertices on the trees are the elements of the set. I need to bring to a parent that eventually points to the root the root points to itself. That's how you know, it's the leader and the route is the convenient name.  Okay, so we're going to look at them as trees. But how does the computer hold the information? It just actually holds it in two different arrays the parent array and the rank array. Now the rain doesn't actually tell you anything about the structure of the tree. It just gives you a an idea of how long the tree is that's hanging from that vertex and that's going to be important in order to keep the heights of the trees short as usual as you'll see.  Okay, so here's kind of an idea of maybe how it would look so here is a bunch of vertices. I put their ranks next to them. And if you noticed that their ranks actually correspond to  The height of the tree that's below that vertex.  And this is what the computer will store it will just or two arrays. One of them is going to be the rank array and the other is a parent array. So all those kind of things will be constant time if you want to update the information.  Okay, so  These are these are just right out of the book make the set. All you do is set the parent to be itself and set the rank to be zero case. It'll just take constant time per for Texas. That's good. I find this basically just means you follow your parents up to the route and you know, you're at the route because the parent of the route is it sell this let's just say that  follow parents  until  you get to route.  I put  Because the route is the name of the set. Okay, and then we have Union and its little bit more complicated. But let's just go through it really fast. So the first thing you do is you find the root of x you find the root of Y. And then what you what you want to do is point the root of x to the root of Y or the root of life to the root of x and which way are you going to do it? You want to do it in such a way that minimizes the height of the tree?  so let's say  that I have the root of x here.  And the root of why here?  And why is a taller tree?  What's going to be the best direction that I go? Should I make sure I point the root of x to y or should I point the root of y 2x?  Which one should be the parent?  Why right because if if the Y tree is actually bigger than if I'd Point x2y like that. I really haven't made the tree any any taller.  You just added one extra Edge.  What's the only way that the tree can actually get taller?  Right. If you add two trees of the same size then you know, you don't really have a choice. I mean you can you can choose either one, but the height of the tree is going to increase by only one Edge The Edge that connects the two fruits.  Talk to Savon run time. We must keep the heights of the trees short.  Intro to do this you look at the ranks. That's why we're keeping track of that value is so that we can we can know the height of the tree very quickly you can you can ask for that and comes the time.  So if one is bigger than the other you point it to the parent if the ranks are equal then then actually increments the rank of the new route by one and it points the smaller to the bigger does the only way that rent can increase or decrease?  Okay. So what are the run times here will make set is big old one / / vertex and find really it depends on the height of the tree right question.  That's a typo.  Yeah, I think.  shoes  Toriko if Frank X is bigger than rank why you want to make  The parent of Ry RX so that one's right. Otherwise, this one's wrong.  otherwise  RX should be r y  actor equal then it doesn't really matter.  Okay. Thank you for that.  Okay, so fine depends on the height of the tree containing X, right and you Union is just basically the same run time as fine. She's just running fine twice and then when you when you point one to the other that just takes constant time.  Okay, so let's build some trees here.  Okay, so we first start with all just all the vertices by themselves.  And let's just put their ranks right here.  Okay, so let's start this off. Well, remember that we have all of the edges in increasing order. So just go by that so the first one we're going to start with a D that's equal to 1.  A & D both have the same rank. So it doesn't matter. Which one do you point to the other? I guess it does if you're following the pseudocode, but it doesn't really make too much of a difference is let's say that let's say a is the  route now  Okay, good. Alright, the next one is eg. So let's take off these my screen.  EG would be I guess he like this.  And g0 okay. Next one is a b or take that one now. He has ranked 08 has rank one. So there's no there's no choice here. You just let a be the parent of be  like that  Okay, that's good. Alright AC is too so same thing.  AC sorry wrong one  see  Hey like that.  Okay, and then BC.  So what happens when you do BC when you look at that edge is you you find the the leader of B, which is a you find a liter of C is also a so they both have the same leader. So you just take away that edge and you don't you don't put it in exit out.  Okay, how about be?  So the leader of B is a the leader of Eazy-E. They both have the same rank. So then you point one to the other in increment was just let's just draw it out again. I guess I'll just keep a as the root.  these ones are  cerasum  I got any questions about that move.  And then you guys can finish off the rest.  It's just a kind of give you an idea of how it works.  Oh, I should feel this in right now.  Okay. Yeah, and then  okay, so just have a few more minutes here. I just want to do a few proofs on properties of these ranks. Okay. So first of all, the ranks actually correspond to the heights of the trees, let's just proved it real fast. Okay. So the base case of vertex by itself has rank 0 the height of a tree is zero. So that's fine. So let's suppose that every vertex of rank K has a tree of heike rank hanging from it. Okay. So now if I have a vertex of rank Kate plus one, the only way that it could have been Kate plus one is if it were K before and then you Union did it with another tree of hike k  And so when that happens you get the height K plus one extra Edge.  Strong little picture about that. I think they'll be helpful.  Hey, so if I have this tree of heike.  And this tree is also a hike k.  Right. When I point this over there, then I have the height of that Edge Plus the whole K. So now this vertex has height.  k + 1  so there you have it. That's it. That's just  Okay, so that's good. Let's do one more little proof here that has to do with how many vertices can you expect to have in a tree of rank? K k so I claimed that any node of rank K has at least two the caver to season it and it was just do it by induction again a root of rank 0 has one vertex. Oh, that's good. So now let's suppose any root of rank has at least two to the cave vertices.  consider a route with Kate of rank k + 1 how did it get to be K plus one is when you Union to rank a vertices and if both of those have at least two to the K and when you Union them, the result has at least  to the K plus one.  So this actually gives us a bound on how high the tree can be.  Thanks. This is kind of the last thing will do so suppose. They are and vertices right I a route of rank login.  Has at least and vertices in its tree a root of any higher rank has at least more than an right so log and is the highest you can possibly have if you have an vertices in your tree with this down. That means all of those operations will only take login time because all those operations are basically you start from whatever vertex you are at and you follow the parents up to the roof.  okay, so maybe  maybe we'll  maybe we'll do one more thing here. Sorry. So let's plug in the values here.  Make set is going to be now Big O of 1.  Find and Union are both log of V.  And sorting is elog V. So that means our run time we get is Big O of elog V.  Okay, so that's that's better than what is that better than what we had before it's sort of like the same trade-off with how sparse or dense the graph is right is B squared better than elog be on Wednesday will look at how to make this a little bit faster under a certain circumstance and then we'll go on to how to prove these correct. "
}