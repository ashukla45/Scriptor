{
    "Blurbs": {
        "I take from I to chat VI to BJ. Okay. So now this is where you kind of have to figure out how to use the other sub problems to your advantage. Okay. So if it is part that means that there's a path. From vbi to VT and there's a path. from VT to Vijay and the only intermediate vertices that I'm using in here. Right are the vertices ": [
            1074.0,
            1115.9,
            23
        ],
        "I wanted to I wanted to know every the shortest path between every pair. Yeah, it's just kind of like just fill up that cross section until you move on to the next one and it doesn't really matter what order you do it in because all of those are just based off the cross section from before. Okay. So how much time does it take? Well, it's basically a ": [
            1698.0,
            1734.0,
            38
        ],
        "I wanted to introduce it to you. So after the dynamic programming, there's no more design type Concepts that I'm expecting you to learn. It's more just we're going to briefly go through a few Concepts from chapter 7 and then Next week. We'll talk about P vs. NP. What are the consequences how to kind of show a certain problem is NP complete Define all those things and those ": [
            223.7,
            263.3,
            4
        ],
        "Improvement by this residual flow. Okay, and this is this is basically what I told you how to change the graph into a residual graph. Okay, so this is that and then this is our residual graph. Now what I claim, which is kind of like the insight into why this algorithm works is any flow from your original graph plus a flow from the residual graph will be a ": [
            2721.9,
            2752.9,
            69
        ],
        "Introduce it to you so that if you see it in the future you kind of know what it is. And I know how to recognize when you can use a linear linear Programming type algorithm to solve it. Then we're going to look at one linear programming algorithm in particular that has to do with network flows, which can solve a whole bunch of problems. So that's another reason. ": [
            200.5,
            223.7,
            3
        ],
        "Okay, so good afternoon. Everyone have a few announcements before we start. if you haven't seen already then I posted some practice problems. For you guys to study the for the final and we're going to have a review session that goes basically over those practice problems. Anything else you guys want to talk about that's going to be on Thursday. Let me just take notes right on here so ": [
            76.4,
            110.3,
            0
        ],
        "Okay. So this is the problem Network flow. Okay, what you're given is a graph with non Negative Edge weights a directed graph. And there's those are called the capacity of the edges. Then you're given two vertices a source and a sink and what you want to do is figure out how to assign values to each Edge that creates a flow and I'll tell you what a flow ": [
            2385.4,
            2415.2,
            58
        ],
        "So what is this in general vij zero? That's the length of the shortest path from VI to Vijay using nothing as intermediate vertices the WhatsApp app with no intermediate vertices. is 1 well, that's certainly true. I guess we could say that FW of I I would be. Trivial, but let's think about if I was not equal to J. They're connected by an edge. Right? And so the ": [
            739.6,
            782.3,
            16
        ],
        "a hint it has something to do with this. Okay, good showcase one VT is included. in the shortest path VT is not included. You guys beginning to see sort of like a theme for these cases often times. It's kind of like the the last object in your in your list. And you started just ask the question. Is it is it in is it supposed to be part ": [
            930.3,
            979.4,
            20
        ],
        "a linear function on. Kind of Define inside. What's a linear function in two Dimensions? It's a plane, right? So where will you find the maximum in that? closed sub region On the edges actually at the corners, right because remember that. No. It's right here. Okay, so well if you don't remember if you remember it, this is this is what linear programming is based on is that you're ": [
            2155.1,
            2199.9,
            51
        ],
        "a problem that you could solve with the Simplex method because it falls into all the categories where has linear constraints linear objective, but we're going to solve it in a more direct way that that doesn't use matrices are all okay, so don't worry about that. And then we're going to see that this particular problem is useful for other problems a lot of other problems reduced to it. ": [
            2360.9,
            2384.6,
            57
        ],
        "about it as like your Solutions are some like terrain right in two dimensions. And you are trying to find the maximum. So you're really trying to kind of climb a hill. And so what you do, how do you climb a hill? You just keep on going up and then once you get to a point where there's no up anymore, you've got to the top of the hill, ": [
            1942.4,
            1967.9,
            45
        ],
        "at a time filling your base case use that to fill in the next cross section and then overwrite your base case cross-section and just keep on going like this and then you only have to use up to and squared amount of space. free used cross section 42 N squared space any questions No, it wouldn't it would find I should have said that it finds all shortest simple ": [
            1772.1,
            1816.0,
            40
        ],
        "bar. Okay, so I'm kind of running out of time here, but I guess maybe on Monday. I'll show you one application of this and then we'll jump into PNP and kind of finish it up from there. And on Friday next Friday will probably just do like a quick overview and summary of the whole class and take it from there. Okay. Have a nice weekend. linear programming where ": [
            2931.8,
            2971.3,
            75
        ],
        "be but we're going to use this other parameter to help us to help us order the problem and get this dynamic programming algorithm to to work. So using only the vertices V1 through VT as intermediate vertices. Okay. So what I want you guys to do is take a few minutes come up with the bass cases. Ready go. Chevy Tahoe And remember when tea is equal to 0 ": [
            530.4,
            591.8,
            14
        ],
        "be going in this direction. Caelike from zero up to end. Okay, so then a cross-section of this Cube? right I need to fill in that entire cross-section until I move on to the next cross-section, right? And the reason I know that is because this this T value is dependent on T -1 values. Thanks. So if that's tea, 20-1 is right here say T minus one in this ": [
            1564.8,
            1605.3,
            34
        ],
        "better flow for your original graph basil. You can only improve your flow. So the idea is find a path make the residual graph Now find another path make the residual graph and keep on updating the graph to this residual graph until there's no more pads left. Okay, so this is kind of the key observation the additive Ade. If f is a flow in the original a prime ": [
            2752.9,
            2785.6,
            70
        ],
        "big O of NM time right? So you could run bellman-ford from every single vertex and get an X & M which is Big O of NM and square. That's perfectly fine. But the Floyd warshall algorithm accomplishes this in Big O of n cubed time. So if you have a very dense algorithm, this will cut back some of that run time. I noticed that this doesn't depend on ": [
            411.7,
            437.8,
            10
        ],
        "but in most cases particularly Right, but it's better than exponential. exactly, so This is kind of my last. Spiel about linear programming and then we'll go into a specific example and you'll kind of see a little bit more Hands-On on how this kind of thing works. So I'm just like you said, how do you find those corners? And how do you deal with those Corners as you ": [
            2260.2,
            2300.0,
            54
        ],
        "can't use BT at the intermediate vertex. So the only other intermediate vertices that are available to me are one through T minus one kind of the Okay, so that's it. FW of ijt is FW of i t t - 1 + f w of TJ T -1 and since I don't know which case is smaller. You just take the minimum of those two. Cancel this what this ": [
            1362.6,
            1403.1,
            29
        ],
        "constraints basically mean that you're kind of cutting off your solution space into some smaller Subspace and since they're linear you can think about it as it's like the the form of that Subspace is like a polygon or a polyhedron, right? It's it's basically like a some sort of three dimensional object or to be multi-dimensional object where the faces are flat night either playing or hyperplanes or something ": [
            2078.3,
            2109.4,
            49
        ],
        "do a bunch of Matrix manipulations fairly simple extremely annoying and tedious for for me and you to do but for a computer it's very simple. And so there's this Simplex algorithm, which is basically the one I'm talking about where you kind of go through the corners and find where that maximum is and It's it's a little complicated to implement but people implement it and it it's not ": [
            2300.0,
            2329.9,
            55
        ],
        "done that's going to be the maximum flow. Okay, better than zero any path of non zero edges how much better but we can send the minimum capacity along that path. Okay. So here's the path. Here's the flow that corresponds to that top hat. Okay for the next thing we're going to do is make a residual graph the way you do that is however much flow you're sending ": [
            2655.5,
            2680.6,
            67
        ],
        "flows all those those clothes that we had before you just add them all up. Why do we get stuck we end when there's no path? That means that if we let s be the set of all vertices reachable, then T is not an S and Basically, you can you can talk about all of the vertices that are unreachable from s right and kind of separate those two ": [
            2860.6,
            2897.7,
            73
        ],
        "for how we're going to proceed. Okay, so the array values it's going to be a three dimensional array. So we're going to have three parameters I J & T. And this is going to hold this array values going to hold the up this sorry. This is wrong. This should be the length. The shortest path from VI to VGA right? That's kind of what we expected it to ": [
            497.8,
            530.4,
            13
        ],
        "from 1 to T minus one? And the intermediate vertices I'm using here are the vertices from 1 to T minus one also and really if you think about it. if this is the shortest path from VI to Vijay, then that would those two sub past would have to be the shortest path from VI to VT and from VT to feed Jay Wright and you add them together, ": [
            1115.9,
            1141.9,
            24
        ],
        "going to find the optimum at the corners and there's no local Optimum anymore because it's a linear function remember linear functions don't have local Optimum. Optimum kind of happens at the boundary of your space in in in more detail actually happens at the corners queso linear programming is really cool. What it does is it picks a corner at random and then it looks at all of the ": [
            2199.9,
            2229.2,
            52
        ],
        "gone through a cycle to get to beat right we'll have to gone through it all ready to get back to it. And we're trying to avoid these negative Cycles. Okay. How about the other one? the right one t j T minus one remember the we're looking we're looking for how to find the shortest path using only these vertices as intermediate vertices, right? So I know that I ": [
            1318.7,
            1362.6,
            28
        ],
        "is a flow in the residual graph, then their sum is a flow in the original graph. So, let's see how that works. Let's pick another pack. Okay. So let's pick this bottom path. The smallest Edge is one. So that's going to be the flow of that path. And now let's create the residual graph by reversing all of those. Okay, you can kind of see that we're eliminating ": [
            2785.6,
            2812.0,
            71
        ],
        "is in a minute solution format is an assignment of non negative values to the E-Check. So the constraints are that in every vertex. The amount of flow going in has to equal the amount of flow going out except for the source in the sink. Basically have infinite. Infinity ins and outs Okay, and the other constraint is at the flow along an edge cannot exceed its capacity. The ": [
            2415.2,
            2448.2,
            59
        ],
        "is. Does going through VT improve the length that's kind of the idea. Okay question. 32j because that's the path. I guess. Let's go back to the definition of FW. Ijt it's the length of the shortest path from vertex. I to vertex J using only the vertices V12 VT and so I put this T minus one here because I know that VT is not going to be in ": [
            1403.1,
            1451.0,
            30
        ],
        "just going to go from cross-section to cross-section and then fill up the eyes and Jason and any order you want you may as well just fill them up in like this this very orderly fashion, but it doesn't really matter put in your thing. And then the output is just going to be FW of ijn for all inj right? This is kind of like that last cross-section cuz ": [
            1674.9,
            1698.0,
            37
        ],
        "know at what rate? Can you send for each diameter has a different rate? Okay, so this is actually a maximum flow. I'm up. We'll kind of Explorer how to get to there. But if you can see I'm going to send two units along the two edged and only three along to 8, it's fine because 8 is going to be like this big huge pipe, but I'm only ": [
            2478.7,
            2506.2,
            61
        ],
        "know, your your country's currency that you start with and you might have a bank account with some of that. So that's a good place to start. But if you're just trying to figure out what is the best currency exchange from any point a to any point B, then you can use the Floyd warshall algorithm. You could also think about other reasons why you would want to use ": [
            329.1,
            351.5,
            7
        ],
        "like that. Okay, so that's all well and good. right We get some multi-dimensional polyhedron. But think about this the objective function is also linear. Do you guys remember from calculus how to find the optimal value of a linear function? in a in a polygon Muggs Riverdale of a linear function is 0 or is Right, but what about in two Dimensions if you have some polygons and there's ": [
            2109.4,
            2155.1,
            50
        ],
        "might be even able to detect one ought to think about that. You might be able to trip to. To change the surround and Protect One. Maybe doing one more cross section. I don't know how to think about it. Okay, let's move on to kind of the next topic next chapter chapter 7 we're going to we're going to Breeze through it. I'm not going to spend a lot ": [
            1852.5,
            1880.3,
            42
        ],
        "minimum of the two cases. The first case was FW of i j t minus one. And the other case was the sum f w of i t t - 1 + f w of T J T minus one. Okay. Now let's talk about ordering of the sub problems. Okay, this is this a ray is going to be like a three dimensional array. It's going to be like ": [
            1495.2,
            1534.5,
            32
        ],
        "negative cycles and the way to avoid that right is how you call the sub problem? Okay. So what are these ones on the left side eye. tea and T minus one but because this. T minus one means that I'm only considering the vertices 130 - 1 as intermediate vertices. I don't want to consider VT as an intermediate vertex cuz that means I I would have had to ": [
            1278.2,
            1318.7,
            27
        ],
        "neighbors of the corners whichever one increases the objective function it will go to that one and you'll always be able to get to an Optimum because the optimum corner is the only The only maximum there's no local maximum anymore. There's a there's a few kind of weird edge cases where maybe you're like on a ridge. So the optimum is the maximum is on like a an edge ": [
            2229.2,
            2260.2,
            53
        ],
        "not always true. Okay, so that's kind of just the basics of hill climbing linear programming is a special case of hill climbing and So the way that it works is your problem needs to have a very particular form. The form needs to be that all the constraints and the objective functions all have to be linear. And so think about your solution space as some multidimensional space. Linear ": [
            2041.8,
            2078.3,
            48
        ],
        "objective is to maximize the total flow from s to T. Let's look at an example. Okay, so think about this as like a network of tunnels or pipes for water or something and you want to know how much water you could send from stt. Where these are the capacities of those pipes? Maybe there's like the did I can go diameter of the pipes and you want to ": [
            2448.2,
            2478.7,
            60
        ],
        "of the subset or is it supposed to not be right? I know they don't all work like that. But this one is a nice way to do it. Okay, let me give myself a little bit more room here. Sorry. Okay, let's see. Let's figure out what these cases mean. So let's do case to First. VT is not part. of shortest path from VI to Vijay Then in ": [
            979.4,
            1031.7,
            21
        ],
        "of time and on the details. I just kind of want to give you a sense of what that chapter is about and a few of the key Concepts. Okay idea of hill climbing and this is more of a general algorithmic strategy. You also can hear about it as gradient descent or gradient descent interior Point method it basically the idea is you pick some random solution that follows ": [
            1880.3,
            1916.9,
            43
        ],
        "pads all shortest simple pads. No, it doesn't it doesn't give you negative Cycles doesn't show you where they are. No, but bellman-ford is you have to give it a starting place. This one gives you all shortest paths from all pairs. So that's kind of the the advantage. I guess you could use bellman-ford from a starting place and see if he find it a negative cycle or you ": [
            1816.0,
            1852.5,
            41
        ],
        "questions about the exam or homework or anything. okay, so today basically what I want to do today is to do one more dynamic programming example and then we're going to start talking about linear programming and we're not going to go super deep into this concept. It's not going to be something that I expect you to know how to design linear programs. It's more for me to just ": [
            158.1,
            198.4,
            2
        ],
        "right? So this is this is really useful and it's it's not always going to give you the optimum because there might be local Optimum right and bigger Optimum, right? So It's useful for approximation algorithms. And sometimes they're not guaranteed to give you the best answer but they are guaranteed to give you kind of a local maximum or Optimum. Okay, so that's kind of think about what is ": [
            1967.9,
            2007.6,
            46
        ],
        "sending three down it right once I get to see. Those three kind of split up to two and one and you can kind of see that for each one of these intermediate vertices the flow in is going to equal to flow out. And so I'm sending out a total of 5 from s and I'm receiving a total of 5 from T. Any questions about the set up ": [
            2506.2,
            2535.2,
            62
        ],
        "sets of vertices and the sum of all the edges that is in that cut right that's going to be your maximum flow. So for example, I can actually reach all of these vertices from s right and these are all the vertices I can't reach s from s so the cut here is 5 because it's the sum of all the edges and that's going to be the network ": [
            2897.7,
            2931.8,
            74
        ],
        "shortest path would have to just be the length of the edge, right? That kind of makes sense. The Edge is a pact with no intermediate vertices. shooter Okay, so let's stay. So that's those are going to be all of our base cases. The next thing we need to do is figure out how to build a recursion. Okay. So what kind of information do we have? We have ": [
            782.3,
            834.2,
            17
        ],
        "so What is the length of this path in terms of my array? FW of Maybe I want to give you guys a few minutes to talk it through fill in the three indices here and fill in the three indices here. Okay, ready go. I didn't even supposed to vote which vertices are on the right side of which produces only right? So remember I guess I didn't write ": [
            1141.9,
            1229.1,
            25
        ],
        "some of the path Pathways right as we go. Okay. Does anybody see any other pads? Maybe going up that way. It still works. Okay. Let's get rid of those. Are there any pads left? Yes, right, maybe this one. Now update that Okay. Now are there any pads left know right was one indicator is that she doesn't have any incoming? I just stopped and all of those residual ": [
            2812.0,
            2860.6,
            72
        ],
        "the consequence of these local Optimum? You could so like I said, you can stop you can kind of think about it as this two-dimensional. Sharpest but really in in most problems are going to be like a very multi-dimensional surface that we can't imagine but it still kind of follows the same local Optimum local max local men ideas. Okay, so balglobal optimum's are always Optima. The reverse is ": [
            2007.6,
            2041.8,
            47
        ],
        "the constraints and you're trying to optimize it right and so in order to optimize it you kind of just look around to the local neighbors and go toward the neighbor that increases the or that gets a better solution might either increases it or decreases it depending on if you're trying to find the maximum or minimum. And then you just kind of follow this path. You can think ": [
            1916.9,
            1942.4,
            44
        ],
        "the in the shortest path from VT to Vijay Yeah, cuz if it were then that means that there would be a cycle and we're trying to find shortest path avoiding Cycles shortest simple path. I guess I should say that. Okay. So, let me just do one more slide here. Okay, so we have let me just rewrite it at w of i j t is equal to the ": [
            1451.0,
            1495.2,
            31
        ],
        "the most so whenever you're ordering the sub problems, you just have to make sure that your outer loop is the teas. I kind of make sense. Okay, so here's a Yours algorithm make sure that okay so first. make all your bass cases, I guess you could say i j 0 is infinity if VI IV Jay Is not an edge. And then start with T. Right cuz that's ": [
            1627.5,
            1674.9,
            36
        ],
        "the number of edges now. It just depends on the number of vertices. Okay, so let's set this up together as a dynamic programming problem. Okay. So what are the types of subproblems going to be now? It's kind of easy to to think about the some problems have something to do with the shortest path between two vertices, but we're going to use this same sort of idea that ": [
            437.8,
            470.9,
            11
        ],
        "the other vertices even in the presence of negative edges and on top of that it was able to detect negative Cycles. And we saw that maybe it was a good tool if you wanted to do like a currency Arbitrage, but in order to use it, you have to pick a currency to start with and that's probably cuz usually probably a good idea because you usually have you ": [
            296.1,
            329.1,
            6
        ],
        "the presence of negative edges. Okay, so this is this is our goal. So at the very least we have to we have to use + sqrt amount of time right because that's of the amount of information that we're trying to fill up the certainly this has to be big Omega events squared. Now you could run bellman-ford and if you remember Bellman Ford takes. I'm in Ford takes ": [
            377.5,
            411.7,
            9
        ],
        "the problem. Okay. Why is Network closed so important you can think about some applications traffic Network routing piping all these kind of things. There's a concept called Min cut, which will talk about in a minute and That's also useful to know. Another thing is that a lot of problems reduced to it, which will see example of one of them and it's a special case of linear programming ": [
            2535.2,
            2570.0,
            63
        ],
        "the shortest paths from VI to Vijay that go through this set. Straight Like That case one in case 2 Hey, what what's the kind of like a simple way that we could divide the Divide all those those pads from vi2 VJ. How can we divide them into two? Sort of subsets dependent on like a very simple rule. if water connected by an edge Okay, I'll give you ": [
            863.3,
            930.3,
            19
        ],
        "the whole. Figure but remember we're trying to find the shortest path from VI to Vijay using only the vertices one through TV1 through VT. Now you just you just got to order them in one way and stick to that order. But then think about it. vi2 VT I'm only considering the vertices one through T. Minus one in that right. Yeah, yes. They're trying to like avoid those ": [
            1229.1,
            1278.2,
            26
        ],
        "these three these three parameters, right and you can kind of think about them as represented by these three different vertices k v i v J & V T. So what is a question that we can ask these? What are the cases that we can split up? All of these shorts pads? We can split them up into several different cases. What are going to be those cases? All ": [
            834.2,
            863.3,
            18
        ],
        "this big cube, right or big like rectangle rectangular prism and we're going to be feeling I guess it will be a cube because it's going to be in by and by an right or end of the number of vertices. It's going to be feeling it right now. Let's let's kind of think about a a cross-section of that Cube. Okay, and let's suppose that t is going to ": [
            1534.5,
            1564.8,
            33
        ],
        "this case w i g a t is going to be equal to what? 2 - 1 write f w of i j t minus one. If you don't if it's better to not use it, then you just you just go down to the smaller set of the vertices one through T. -1 as your intermediate for a text. Okay case one. BTW is part. of the shortest path ": [
            1031.7,
            1068.9,
            22
        ],
        "this right? Maybe this would give you the shortest path from any pair of cities and so you can build like a Like a matrix like, you know the Matrix in the bottom corner of your Atlas, that's like all the shortest path to all the cities. That's essentially kind of what this is doing all though. This is a Little Bit Stronger because it you it also works in ": [
            351.5,
            377.5,
            8
        ],
        "to represent. Can we make it better by this other question? Is there any flow in a residual Network? So I'll show you what a residual network is. Okay. So the first thing we need to do is start with a flow. It doesn't have to be the maximum flow just have to be a flow. How can I get like a flow really easily? What's one kind of quick ": [
            2596.3,
            2616.4,
            65
        ],
        "triple for Loop each of size end. Right? So it's going to take Big O of n cubed time. How about space? How much space is going to take up? Also and cureight you're filling up this big and by ncube. Is there anybody see a way to reduce the amount of space? But you can just kind of over right across section and only only keep two cross sections ": [
            1734.0,
            1772.1,
            39
        ],
        "types of questions will come up on the exam in like the true-false short answer type things. Okay. Okay, so let's get started. We're going to start off with the Floyd warshall algorithm. Okay, so if you recall last time we did the Bellman Ford algorithm. And what was nice about Bellman Ford was it gave us a efficient way to find the shortest path from one vertex to all ": [
            263.3,
            296.1,
            5
        ],
        "very hard for the computer to do doesn't take much time. And I mean I wanted to introduce this to you is if you ever get a problem that can use when your programming then you can find some Simplex method and you can solve it relatively efficiently. If you use some other some other person's algorithm that they've already made. Okay. Now the next example is an example of ": [
            2329.9,
            2360.9,
            56
        ],
        "way that we can get at least one non-trivial flow. Okay, just take any path, right? From source to sink. What about this one? Now what Flo am I going to put on there? The minimum of all of the edges, right? So 2K, we're going to start with that path and keep on improving it little by little until we can improve it anymore and then went once we're ": [
            2616.4,
            2655.5,
            66
        ],
        "we used in Bellman Ford and have some sort of restraint On The Edge on the path and Bellman Ford. We use like a budget of the number of edges with this we're going to think about the the past that go through certain edges the past that goes through certain vertices. Okay. Kind of weird. But once we defined it in this way, you'll kind of get a feel ": [
            470.9,
            497.8,
            12
        ],
        "we're saying that the the allowable intermediate vertices are is the empty set, right? No, no. Yes. Oh intermediate means that that vertex is found somewhere along the path from VI to Vijay. What's the temperature like today? diagonal Has anybody have any base cases? No, you can have a pack. You can have a path with no with no intermediate vertices. What is that called? No. So like, okay. ": [
            591.8,
            739.6,
            15
        ],
        "with a much more efficient solution than doing all the Matrix stuff. So if you have a linear Programming type problem, it might be able to reduce it to network fluff. Okay good. So we're going to look at the Ford Fulkerson method. It's basically a hill climbing solution because we're going to start with some random solution and try to improve it along the way. Stop will be able ": [
            2570.0,
            2596.3,
            64
        ],
        "would be The Ordering of the vertices does it really matter you just have to kind of pick up ordering and stick with it? So you're basically filling in that whole cross-section before you move on to the next one so you see why that's important kind of The Ordering of the eyes and Jazz doesn't really matter so much but the ordering of the teas is what really matters ": [
            1605.3,
            1627.5,
            35
        ],
        "you View flip that flow around and send it back and make a new Edge to send it back. Okay. So this whole thing is going to be a two coming back. This one is going to split the four into two going forward to going back. And this one's going to split the 3-1 going forward to going back. So basically the inside here is we can represent the ": [
            2680.6,
            2721.9,
            68
        ],
        "you can have access to it. Okay, so Thursday March 15 shoes me 14 I'm in Center. 101 from 8 p.m. Tonight 9:50 p.m. And will podcast it so I know not everybody can come so it will have it podcast it for you. I know that is very very close to the Final exam date, but you know just what we have to work with. anything else The other ": [
            110.3,
            158.1,
            1
        ],
        "you pick the perfect edges ": [
            2971.3,
            2973.3,
            76
        ]
    },
    "File Name": "Design___Analysis_of_Algorithm___A00___Jones__Miles_E___Winter_2019-lecture_25.flac",
    "Full Transcript": "Okay, so good afternoon. Everyone have a few announcements before we start.  if you haven't seen already then  I posted some practice problems.  For you guys to study the for the final and we're going to have a review session that goes basically over those practice problems. Anything else you guys want to talk about that's going to be on Thursday.  Let me just take notes right on here so you can have access to it.  Okay, so Thursday  March  15 shoes me 14  I'm in Center.  101 from 8 p.m.  Tonight 9:50 p.m.  And will podcast it so I know not everybody can come so it will have it podcast it for you. I know that is very  very close to the  Final exam date, but you know just what we have to work with.  anything else  The other questions about the exam or homework or anything.  okay, so today basically what I want to do today is to  do one more  dynamic programming example  and then we're going to start talking about linear programming and we're not going to go super deep into this concept. It's not going to be something that I expect you to know how to design linear programs. It's more for me to just  Introduce it to you so that if you see it in the future you kind of know what it is. And I know how to recognize when you can use a linear linear Programming type algorithm to solve it. Then we're going to look at one linear programming algorithm in particular that has to do with network flows, which can solve a whole bunch of problems. So that's another reason. I wanted to introduce it to you.  So after the dynamic programming, there's no more design type Concepts that I'm expecting you to learn. It's more just we're going to briefly go through a few Concepts from chapter 7 and then  Next week. We'll talk about P vs. NP. What are the consequences how to kind of show a certain problem is NP complete Define all those things and those types of questions will come up on the exam in like the true-false short answer type things. Okay.  Okay, so let's get started.  We're going to start off with the Floyd warshall algorithm. Okay, so if you recall last time we did the Bellman Ford algorithm. And what was nice about Bellman Ford was it gave us a efficient way to find the shortest path from one vertex to all the other vertices even in the presence of negative edges and on top of that it was able to detect negative Cycles.  And we saw that maybe it was a good tool if you wanted to do like a currency Arbitrage, but in order to use it, you have to pick a currency to start with and that's probably cuz usually probably a good idea because you usually have you know, your your country's currency that you start with and you might have a bank account with some of that. So that's a good place to start. But if you're just trying to figure out what is the best currency exchange from any point a to any point B, then you can use the Floyd warshall algorithm. You could also think about other reasons why you would want to use this right? Maybe this would give you the shortest path from any pair of cities and so you can build like a  Like a matrix like, you know the Matrix in the bottom corner of your Atlas, that's like all the shortest path to all the cities. That's essentially kind of what this is doing all though.  This is a Little Bit Stronger because it you it also works in the presence of negative edges.  Okay, so this is this is our goal.  So at the very least we have to we have to use + sqrt amount of time right because that's of the amount of information that we're trying to fill up the certainly this has to be big Omega events squared.  Now you could run bellman-ford and if you remember Bellman Ford takes.  I'm in Ford takes big O of NM time right? So you could run bellman-ford from every single vertex and get an X & M which is Big O of NM and square.  That's perfectly fine. But the Floyd warshall algorithm accomplishes this in Big O of n cubed time. So if you have a very dense algorithm, this will cut back some of that run time.  I noticed that this doesn't depend on the number of edges now. It just depends on the number of vertices.  Okay, so let's set this up together as a dynamic programming problem. Okay. So what are the types of subproblems going to be now?  It's kind of  easy to to think about the some problems have something to do with the shortest path between two vertices, but we're going to use this same sort of idea that we used in Bellman Ford and have some sort of restraint On The Edge on the path and Bellman Ford. We use like a budget of the number of edges with this we're going to think about the the past that go through certain edges the past that goes through certain vertices.  Okay. Kind of weird. But once we defined it in this way, you'll kind of get a feel for how we're going to proceed.  Okay, so the array values it's going to be a three dimensional array.  So we're going to have three parameters I J & T.  And this is going to hold this array values going to hold the up this sorry. This is wrong. This should be the length.  The shortest path from VI to VGA right? That's kind of what we expected it to be but we're going to use this other parameter to help us to help us order the problem and get this dynamic programming algorithm to to work.  So using only  the vertices V1 through VT as intermediate vertices.  Okay. So what I want you guys to do is take a few minutes come up with the bass cases.  Ready go.  Chevy Tahoe  And remember when tea is equal to 0 we're saying that the the allowable intermediate vertices are is the empty set, right?  No, no. Yes. Oh intermediate means that that vertex is found somewhere along the path from VI to Vijay.  What's the temperature like today?  diagonal  Has anybody have any base cases?  No, you can have a pack. You can have a path with no with no intermediate vertices. What is that called?  No.  So like, okay. So what is this in general vij zero? That's the length of the shortest path from VI to Vijay using nothing as intermediate vertices the WhatsApp app with no intermediate vertices.  is 1  well, that's certainly true. I guess we could say that FW of I I would be.  Trivial, but let's think about if I was not equal to J.  They're connected by an edge. Right? And so the shortest path would have to just be the length of the edge, right?  That kind of makes sense.  The Edge is a pact with no intermediate vertices.  shooter  Okay, so let's stay. So that's those are going to be all of our base cases. The next thing we need to do is figure out how to build a recursion.  Okay.  So what kind of information do we have? We have these three these three parameters, right and you can kind of think about them as represented by these three different vertices k v i v J & V T. So what is a question that we can ask these? What are the cases that we can split up? All of these shorts pads? We can split them up into several different cases. What are going to be those cases?  All the shortest paths from VI to Vijay that go through this set.  Straight Like That  case one  in case 2  Hey, what what's the kind of like a simple way that we could divide the Divide all those those pads from vi2 VJ. How can we divide them into two?  Sort of subsets dependent on like a very simple rule.  if water connected by an edge  Okay, I'll give you a hint it has something to do with this.  Okay, good showcase one VT is included.  in the shortest path  VT is not included.  You guys beginning to see sort of like a theme for these cases often times. It's kind of like the the last object in your in your list. And you started just ask the question. Is it is it in is it supposed to be part of the subset or is it supposed to not be right? I know they don't all work like that. But this one is a nice way to do it.  Okay, let me give myself a little bit more room here. Sorry.  Okay, let's see. Let's figure out what these cases mean. So let's do case to First.  VT is not part.  of shortest path  from VI to Vijay  Then in this case w i g a t is going to be equal to what?  2 - 1 write f w of i j t minus one.  If you don't if it's better to not use it, then you just you just go down to the smaller set of the vertices one through T. -1 as your intermediate for a text.  Okay case one.  BTW is part.  of the shortest path  I take from I to chat VI to BJ.  Okay. So now this is where you kind of have to figure out how to use the other sub problems to your advantage. Okay. So if it is part that means that there's a path.  From vbi to VT and there's a path.  from VT to Vijay  and  the only intermediate vertices that I'm using in here.  Right are the vertices from 1 to T minus one?  And the intermediate vertices I'm using here are the vertices from 1 to T minus one also and really if you think about it.  if this is the shortest path from VI to Vijay, then that would those two sub past would have to be the shortest path from VI to VT and from VT to feed Jay Wright and you add them together, so  What is the length of this path in terms of my array?  FW of  Maybe I want to give you guys a few minutes to talk it through fill in the three indices here and fill in the three indices here. Okay, ready go.  I didn't even supposed to vote which vertices are on the right side of which produces only right? So remember I guess I didn't write the whole.  Figure but remember we're trying to find the shortest path from VI to Vijay using only the vertices one through TV1 through VT. Now you just you just got to order them in one way and stick to that order.  But then think about it.  vi2 VT  I'm only considering the vertices one through T. Minus one in that right.  Yeah, yes. They're trying to like avoid those negative cycles and the way to avoid that right is  how you call the sub problem?  Okay. So what are these ones on the left side eye.  tea and  T minus one  but because this. T minus one means that I'm only considering the vertices 130 - 1 as intermediate vertices.  I don't want to consider VT as an intermediate vertex cuz that means I I would have had to gone through a cycle to get to beat right we'll have to gone through it all ready to get back to it. And we're trying to avoid these negative Cycles. Okay. How about the other one?  the right one  t j  T minus one  remember the  we're looking we're looking for how to find the shortest path using only these vertices as intermediate vertices, right? So I know that I can't use BT at the intermediate vertex. So the only other intermediate vertices that are available to me are one through T minus one kind of the  Okay, so that's it.  FW of ijt is FW of i t t - 1 + f w of TJ T -1 and since I don't know which case is smaller. You just take the minimum of those two.  Cancel this what this is.  Does going through VT improve the length that's kind of the idea.  Okay question.  32j because that's the path. I guess. Let's go back to the definition of FW. Ijt it's the length of the shortest path from vertex. I to vertex J using only the vertices V12 VT and so  I put this T minus one here because I know that VT is not going to be in the  in the shortest path from VT to Vijay  Yeah, cuz if it were then that means that there would be a cycle and we're trying to find shortest path avoiding Cycles shortest simple path. I guess I should say that.  Okay.  So, let me just do one more slide here.  Okay, so we have let me just rewrite it at w of i j t is equal to the minimum of the two cases. The first case was FW of i j t minus one.  And the other case was the sum f w of i t t - 1 + f w of T J T minus one.  Okay. Now let's talk about ordering of the sub problems.  Okay, this is this a ray is going to be like a three dimensional array. It's going to be like this big cube, right or big like rectangle rectangular prism and we're going to be feeling I guess it will be a cube because it's going to be in by and by an right or end of the number of vertices.  It's going to be feeling it right now. Let's let's kind of think about a a cross-section of that Cube.  Okay, and let's suppose that t is going to be going in this direction.  Caelike from zero up to end.  Okay, so then a cross-section of this Cube?  right  I need to fill in that entire cross-section until I move on to the next cross-section, right? And the reason I know that is because  this this T value is dependent on T -1 values.  Thanks. So if that's tea, 20-1 is right here say  T minus one in this would be  The Ordering of the vertices does it really matter you just have to kind of pick up ordering and stick with it? So you're basically filling in that whole cross-section before you move on to the next one so you see why that's important kind of The Ordering of the eyes and Jazz doesn't really matter so much but the ordering of the teas is what really matters the most so whenever you're ordering the sub problems, you just have to make sure that your outer loop is the teas.  I kind of make sense.  Okay, so here's a  Yours algorithm make sure that okay so first.  make all your  bass cases, I guess you could say i j 0 is infinity if  VI IV Jay  Is not an edge.  And then start with T. Right cuz that's just going to go from cross-section to cross-section and then fill up the eyes and Jason and any order you want you may as well just fill them up in like this this very orderly fashion, but it doesn't really matter put in your thing. And then the output is just going to be  FW of ijn for all inj right? This is kind of like that last cross-section cuz I wanted to I wanted to know every the shortest path between every pair.  Yeah, it's just kind of like just fill up that cross section until you move on to the next one and it doesn't really matter what order you do it in because all of those are just based off the cross section from before.  Okay. So how much time does it take? Well, it's basically a triple for Loop each of size end. Right? So it's going to take Big O of n cubed time.  How about space?  How much space is going to take up?  Also and cureight you're filling up this big and by ncube.  Is there anybody see a way to reduce the amount of space?  But you can just kind of over right across section and only only keep two cross sections at a time filling your base case use that to fill in the next cross section and then overwrite your base case cross-section and just keep on going like this and then you only have to use up to and squared amount of space.  free used cross section  42 N squared space  any questions  No, it wouldn't it would find I should have said that it finds all shortest simple pads all shortest simple pads.  No, it doesn't it doesn't give you negative Cycles doesn't show you where they are.  No, but bellman-ford is you have to give it a starting place. This one gives you all shortest paths from all pairs. So that's kind of the the advantage.  I guess you could use bellman-ford from a starting place and see if he find it a negative cycle or you might be even able to detect one ought to think about that. You might be able to trip to.  To change the surround and Protect One.  Maybe doing one more cross section.  I don't know how to think about it.  Okay, let's move on to kind of the next topic next chapter chapter 7 we're going to we're going to Breeze through it. I'm not going to spend a lot of time and on the details. I just kind of want to give you a sense of what that chapter is about and a few of the key Concepts. Okay idea of hill climbing and this is more of a general algorithmic strategy.  You also can hear about it as gradient descent or gradient descent interior Point method it basically the idea is you pick some random solution that follows the constraints and you're trying to optimize it right and so in order to optimize it you kind of just look around to the local neighbors and go toward the neighbor that increases the or that gets a better solution might either increases it or decreases it depending on if you're trying to find the maximum or minimum.  And then you just kind of follow this path. You can think about it as like your Solutions are some like terrain right in two dimensions.  And you are trying to find the maximum. So you're really trying to kind of climb a hill. And so what you do, how do you climb a hill? You just keep on going up and then once you get to a point where there's no up anymore, you've got to the top of the hill, right? So this is this is really useful and it's it's not always going to give you the optimum because there might be local Optimum right and bigger Optimum, right? So  It's useful for approximation algorithms. And sometimes they're not guaranteed to give you the best answer but they are guaranteed to give you kind of a local maximum or Optimum.  Okay, so  that's kind of think about what is the consequence of these local Optimum?  You could so like I said, you can stop you can kind of think about it as this two-dimensional.  Sharpest but really in in most problems are going to be like a very multi-dimensional surface that we can't imagine but it still kind of follows the same local Optimum local max local men ideas.  Okay, so  balglobal optimum's are always Optima. The reverse is not always true.  Okay, so that's kind of just the basics of hill climbing linear programming is a special case of hill climbing and  So the way that it works is your problem needs to have a very particular form. The form needs to be that all the constraints and the objective functions all have to be linear. And so think about your solution space as some multidimensional space.  Linear constraints basically mean that you're kind of cutting off your solution space into some smaller Subspace and since they're linear you can think about it as it's like the the form of that Subspace is like a polygon or a polyhedron, right? It's it's basically like a some sort of three dimensional object or to be multi-dimensional object where the faces are flat night either playing or hyperplanes or something like that.  Okay, so  that's all well and good.  right  We get some multi-dimensional polyhedron.  But think about this the objective function is also linear.  Do you guys remember from calculus how to find the optimal value of a linear function?  in a in a polygon  Muggs Riverdale of a linear function is 0 or is  Right, but what about in two Dimensions if you have some polygons and there's a linear function on.  Kind of Define inside. What's a linear function in two Dimensions? It's a plane, right?  So where will you find the maximum in that?  closed sub  region  On the edges actually at the corners, right because remember that.  No.  It's right here.  Okay, so well if you don't remember if you remember it, this is this is what linear programming is based on is that you're going to find the optimum at the corners and there's no local Optimum anymore because it's a linear function remember linear functions don't have local Optimum.  Optimum kind of happens at the boundary of your space in in in more detail actually happens at the corners queso linear programming is really cool. What it does is it picks a corner at random and then it looks at all of the neighbors of the corners whichever one increases the objective function it will go to that one and you'll always be able to get to an Optimum because the optimum corner is the only  The only maximum there's no local maximum anymore. There's a there's a few kind of weird edge cases where maybe you're like on a ridge. So the optimum is the maximum is on like a an edge but in most cases  particularly  Right, but it's better than exponential.  exactly, so  This is kind of my last.  Spiel about linear programming and then we'll go into a specific example and you'll kind of see a little bit more Hands-On on how this kind of thing works. So I'm just like you said, how do you find those corners? And how do you deal with those Corners as you do a bunch of Matrix manipulations fairly simple extremely annoying and tedious for for me and you to do but for a computer it's very simple. And so there's this Simplex algorithm, which is basically the one I'm talking about where you kind of go through the corners and find where that maximum is and  It's it's a little complicated to implement but people implement it and it it's not very hard for the computer to do doesn't take much time.  And I mean I wanted to introduce this to you is if you ever get a problem that can use when your programming then you can find some Simplex method and you can solve it relatively efficiently. If you use some other some other person's algorithm that they've already made.  Okay.  Now the next example is an example of a problem that you could solve with the Simplex method because it falls into all the categories where has linear constraints linear objective, but we're going to solve it in a more direct way that  that doesn't use matrices are all okay, so don't worry about that. And then we're going to see that this particular problem is useful for other problems a lot of other problems reduced to it.  Okay. So this is the problem Network flow. Okay, what you're given is a graph with non Negative Edge weights a directed graph.  And there's those are called the capacity of the edges. Then you're given two vertices a source and a sink and what you want to do is figure out how to assign values to each Edge that creates a flow and I'll tell you what a flow is in a minute solution format is an assignment of non negative values to the E-Check.  So the constraints are that in every vertex. The amount of flow going in has to equal the amount of flow going out except for the source in the sink.  Basically have infinite.  Infinity ins and outs  Okay, and the other constraint is at the flow along an edge cannot exceed its capacity.  The objective is to maximize the total flow from s to T.  Let's look at an example.  Okay, so think about this as like a network of tunnels or pipes for water or something and you want to know how much water you could send from stt. Where these are the capacities of those pipes? Maybe there's like the did I can go diameter of the pipes and you want to know at what rate? Can you send for each diameter has a different rate?  Okay, so  this is actually a maximum flow.  I'm up. We'll kind of Explorer how to get to there. But if you can see I'm going to send two units along the two edged and only three along to 8, it's fine because 8 is going to be like this big huge pipe, but I'm only sending three down it right once I get to see.  Those three kind of split up to two and one and you can kind of see that for each one of these intermediate vertices the flow in is going to equal to flow out.  And so I'm sending out a total of 5 from s and I'm receiving a total of 5 from T. Any questions about the  set up the problem.  Okay.  Why is Network closed so important you can think about some applications traffic Network routing piping all these kind of things. There's a concept called Min cut, which will talk about in a minute and  That's also useful to know.  Another thing is that a lot of problems reduced to it, which will see example of one of them and it's a special case of linear programming with a much more efficient solution than doing all the Matrix stuff. So if you have a linear Programming type problem, it might be able to reduce it to network fluff.  Okay good.  So we're going to look at the Ford Fulkerson method. It's basically a hill climbing solution because we're going to start with some random solution and try to improve it along the way.  Stop will be able to represent. Can we make it better by this other question? Is there any flow in a residual Network? So I'll show you what a residual network is.  Okay. So the first thing we need to do is start with a flow. It doesn't have to be the maximum flow just have to be a flow. How can I get like a flow really easily? What's one kind of quick way that we can get at least one non-trivial flow.  Okay, just take any path, right?  From source to sink. What about this one?  Now what Flo am I going to put on there?  The minimum of all of the edges, right? So 2K, we're going to start with that path and keep on improving it little by little until we can improve it anymore and then went once we're done that's going to be the maximum flow.  Okay, better than zero any path of non zero edges how much better but we can send the minimum capacity along that path. Okay. So here's the path. Here's the flow that corresponds to that top hat.  Okay for the next thing we're going to do is make a residual graph the way you do that is however much flow you're sending you View flip that flow around and send it back and make a new Edge to send it back. Okay. So this whole thing is going to be a two coming back. This one is going to split the four into two going forward to going back.  And this one's going to split the 3-1 going forward to going back.  So basically the inside here is we can represent the Improvement by this residual flow.  Okay, and this is this is basically what I told you how to change the graph into a residual graph.  Okay, so this is that and then this is our residual graph.  Now what I claim, which is kind of like the insight into why this algorithm works is any flow from your original graph plus a flow from the residual graph will be a better flow for your original graph basil. You can only improve your flow. So the idea is  find a path make the residual graph Now find another path make the residual graph and keep on updating the graph to this residual graph until there's no more pads left.  Okay, so this is kind of the key observation the additive Ade.  If f is a flow in the original a prime is a flow in the residual graph, then their sum is a flow in the original graph.  So, let's see how that works. Let's pick another pack. Okay. So let's pick this bottom path. The smallest Edge is one. So that's going to be the flow of that path. And now let's create the residual graph by reversing all of those. Okay, you can kind of see that we're eliminating some of the path Pathways right as we go. Okay. Does anybody see any other pads?  Maybe going up that way.  It still works. Okay.  Let's get rid of those. Are there any pads left?  Yes, right, maybe this one.  Now update that  Okay. Now are there any pads left know right was one indicator is that she doesn't have any incoming? I just stopped and all of those residual flows all those those clothes that we had before you just add them all up.  Why do we get stuck we end when there's no path? That means that if we let s be the set of all vertices reachable, then T is not an S and  Basically, you can you can talk about all of the vertices that are unreachable from s right and kind of separate those two sets of vertices and the sum of all the edges that is in that cut right that's going to be your maximum flow. So for example,  I can actually reach all of these vertices from s right and these are all the vertices I can't reach s from s so the cut here is 5 because it's the sum of all the edges and that's going to be the network bar.  Okay, so I'm kind of running out of time here, but  I guess maybe on Monday. I'll show you one application of this and then we'll jump into PNP and kind of finish it up from there. And on Friday next Friday will probably just do like a quick overview and summary of the whole class and take it from there.  Okay. Have a nice weekend.  linear programming where you pick the perfect edges "
}