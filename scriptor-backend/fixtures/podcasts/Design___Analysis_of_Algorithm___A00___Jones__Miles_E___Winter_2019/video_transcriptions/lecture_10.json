{
    "Blurbs": {
        "73 hair and 68. Thank you. Okay, great. So those are both greedy strategies and they both work and we're not going to prove them. But we all kind of have a good feeling that they were. Okay and then do you get 481 cookies? Okay. So what is it? What's the format for this one? It's the same right? You have your sheet? a cookies you have your solution ": [
            2236.6,
            2266.5,
            58
        ],
        "And it's not be pussy anymore because the input remember is a connected graph and 4 connected graphs. He is big Omega of the Okay, so so there's two components to kruskal's algorithm. There's the sorting and then there's the algorithm so it's this is really as best as we can do right because it takes just this long to sort it, right. So sorting a sort of the bottleneck. ": [
            396.7,
            433.3,
            10
        ],
        "And usually candy and then what you're doing is a Greek alphabet that are not real. Right. Yeah kind of greedy though. Right in a sense. You're like always picking the lowest one. to look at next and then it makes sense because whatever when you make a column, what do you think? I'm spooky. Would that work? Okay. Well, then you can't solve it with a greedy algorithm at ": [
            2657.2,
            2718.4,
            69
        ],
        "Choice best choice and one of them may work and one of them may not work. We we just saw that piece of the next example, we're going to look at I want you guys to get started on this is event scheduling. Okay. So suppose you're running a cookie conference and you have a collection of events or talks people talk about which is their favorite cookie or this ": [
            2754.8,
            2777.5,
            71
        ],
        "Eastpoint. Good. good observation Okay. So let's just go through this a few more slides here. So doesn't always work and because of that right like you were staying up there. We have to prove that it works. Once we once we make it right or else we must present a counterexample like we did before. Okay, so furthermore for single problem. There might be one more than one greedy ": [
            2718.4,
            2754.8,
            70
        ],
        "I could do is pick the the smallest cookie, which is 40 cross out the row and column right then pick the next smallest which is 50 cross out the row and column. Then pick the next smallest, which is 60. Knock out the row and column. The next smallest is. 74 and then the next smallest is 81. The next smallest is 99. You guys notice anything about this ": [
            2538.0,
            2575.2,
            66
        ],
        "Okay a list of vertices or a list of edges write a path. What's the constraint? Willa path is a valid path. But where does it start and where does it end? Okay, good. So has two. start s and end At T I just called these S&T. Okay. Good and then what's the objective? What is the function like the objective is basically a function that you input and ": [
            1392.4,
            1443.7,
            37
        ],
        "Okay, good morning. I mean good afternoon everyone anybody have any questions before we begin? We're going to give you all the seating chart right for the quiz. Okay, so make sure you go to the quiz section that you are assigned to if there is a circumstance where you need to change sections then just let me know by email and I'll make sure that you're on the other ": [
            58.8,
            85.5,
            0
        ],
        "Okay, so this is how they describe it in the book. I'm just going to give you guys like a an example of what it would look like. Okay, so let's just make up an example. Let's say that this tree has is height to okay. So let's say a is too and then we have B. 0 and a shady one. where's cc0 and I don't know maybe. That ": [
            567.8,
            619.4,
            15
        ],
        "So for example, let's think about shortest path. Let's say in shortest path between two points in a graph. between two points case of the instance is going to be a graph. start node and endnote And maybe you have positive Edge weights or something like that, right? But that's just the information given so what's the solution for Matt? What is the solution going to look like in general? ": [
            1354.1,
            1389.2,
            36
        ],
        "So if we do any improvements on kruskal's algorithm, it won't improve the overall run time anymore. If we were able to do the the whole process in linear time, the whole algorithm is still going to take elog be because that's how how long it takes to sort. But that being said we are going to think about can we improve the runtime of Union? Can we improve the ": [
            433.3,
            461.0,
            11
        ],
        "The cookies are all chocolate chip cookies, but they may have different sizes. You're only allowed to take 6 cookies. How can you maximize your total cookie intake? Okay, let's so give you an example or let's first let's let's look at the breakdown. The instance is the the sizes of cookies But let's let's just assume that the Cookie Monster has the ability to determine the size of a ": [
            2016.1,
            2055.3,
            53
        ],
        "a solution and outputs a number. So this one is the path length, which is the the sum of all the edge lengths, right? Or the sum of all the edges in the past the length of the edge. questions about that Okay, so that's what we have right? Yeah. Okay. I want you guys to think of think for a few minutes. How would you fill in the details ": [
            1443.7,
            1480.2,
            38
        ],
        "about that. Okay good. So that sounds all of our operations. So now instead of finding the height of the tree we can actually change it to find being login Union being login. Where n is the number of vertices and so now the wrong times of crew schools will make set is20 is big old one fine is Big O V Union is bigger a V and sorting is ": [
            308.9,
            338.7,
            8
        ],
        "and maybe we'll make a tree of height 3. So it's a we have e is 3 and then we have f-zero Angie 1 + H20 Grinch song let's say we had that tree and I might have it might look kind of weird the way that I built it, but I'm trying to have a tree that's actually able to be built using the Union's right? And so what ": [
            619.4,
            656.1,
            16
        ],
        "and that each of them has a start time and end time. Okay Ono you only have one conference room. So now you have to schedule as many stalks as possible. Okay? And none of them have to overlap. So how do we fill in this thing? The instance is a set of intervals. With a start time and a finish time. What's the solution for Matt? I guess we ": [
            2777.5,
            2808.9,
            72
        ],
        "and what is Graph Search give you That's right. Exactly the type of solution that we want. Okay, what was the objective again? The minimum overall edges in the path? weight of edge So the objective function is not doesn't tell you the you know, the optimal thing the objective function all it does it tells you how to compare two solutions to potential Solutions. So it's a function that ": [
            1648.8,
            1690.7,
            43
        ],
        "at least shows us that the the one our algorithm gave us is not the best and that's what's important. Okay. So here's a just another one that I put okay. So here's the actual best solution for this problem. Okay. So the greedy algorithm gave us 404 the actual best solutions for 58. How do I get there? Well, I'll let you guys think about how to do it ": [
            2476.8,
            2507.2,
            64
        ],
        "bandwidth. Is that what you guys got? Pictures of this gives you a sense of why the shortest path problem and the max bandwidth problem are so similar. Do you remember we used like basically the same dijkstra type algorithm to solve them both, right? Because all of all of the solution format is the same and basically what the kind of the scaffolding that we used was Graph Search ": [
            1596.5,
            1648.8,
            42
        ],
        "be the height of the other tree plus that other Edge can we do like kind of a picture so suppose this tree has height k, and this tree also has hike k so then when we Union them together I mean straight like this. You are you add that edge right there? And now this has hiked a plus one and it says hike K and the K plus ": [
            190.4,
            222.6,
            4
        ],
        "bunch of vertices only on one level, right? And we're taking care of those those redirections during times when we have to do something anyway, so we're like not really losing out. We go all the way up so member what fine does is you start at the vertex you're finding in this case see right? So what I'm going to do is I'm going to say okay redirect cease ": [
            867.6,
            905.5,
            22
        ],
        "child of the route. So that means next time I call find C. I only have to do one. one thing PriceSmart though, right Log of and lock up the highest number of elements. You got to Traverse through the many ways and so if you do a constant time thing while you're going up, you're not really adding exponential asymptotic lie to your run time. Yeah. So what is ": [
            930.7,
            977.3,
            24
        ],
        "cookie by just looking at it in constant time. The solution format is a set. subset of 6 constraints are no constraints. And the objective is to maximize. the sum of all the sizes of all the cookies I just put to see. Where cookie is in your subset? Okay, let's look at an example. What kind of algorithm would I use let's say that these are the the size ": [
            2055.3,
            2099.0,
            54
        ],
        "could do like start one finish one start to finish two and so on. start and finishing What's the solution format? Okay good so subset. intervals What's the constraint? best objective Okay good. So they right they don't. overlap And then the objective is maximized. size of subset so I like to do it this way because this gives you a sense of like the size of the problem the ": [
            2808.9,
            2875.9,
            73
        ],
        "e lockie. right so we basically have like the runtime of the algorithm which is this plus how long it takes to sort and the result we get is Big O of elog V. Any questions about that? Because I log. e Is Big O of log V? four pics eight actually You can just kind of put them all together. It's fine. Just makes it simpler to look at. ": [
            338.7,
            394.9,
            9
        ],
        "flow both directions through a pipe. So Yeah, I would think that the for the minimum spanning tree now that that should not be directed The Venomous penetration always be undirected graph, which is your kind of thing. Where if if this one can communicate to that one then they should be able to communicate back and then if you cut all the lines what kind of by Direction where ": [
            1543.6,
            1571.5,
            40
        ],
        "for the Mac Band with path problem? I'll give you a hint. This is a optimization problem. Ready go. If you want you want me to put it on this again? I'm so damn real world situation with Max that would be direct or indirect by Direct Communications. I would say it's directed and I'm thinking more of like the the water flow kind of situation where The water can ": [
            1480.2,
            1543.6,
            39
        ],
        "format is a subset. Of sixth the constraints is that no two cookies. In same row and then the objective is the total size difference between those was that now I have a constraint put one more constraint on it. What if what is algorithm you could use to select the best option? If you can't select two cookies from the same row or column can anybody give me a ": [
            2266.5,
            2299.0,
            59
        ],
        "greedy strategy to do this? Take me to Vegas and all that guy 99. Okay good. And repeat. Okay. I didn't finish this animation. Okay, let's just do it this way by what's the next biggest 81 Right, and then the next biggest is what 74? That right. okay, and then 50 snow 60 and then 50 Oh, no. And then 40, right? Okay. So then we you can fill ": [
            2299.0,
            2361.7,
            60
        ],
        "immediate best interest? Are you dropped off the window from your apartment? Oh wow. So you saved you saved yourself the the the manual labor of walking it down the stairs and you gained you gained that but then you lost in the longer-term maybe a financial burden. But has anybody have any examples of when acting in your best your immediate been best interest is actually better for the ": [
            1900.8,
            1942.5,
            50
        ],
        "is kind of like TCG? Exactly. Yeah exactly. You need to be able to but this one but Mac bandwidth is like how much can I push through this network in the network has to be directed so I know which direction they go. Now. Maybe there is a pipe that goes this way and a pipe that goes back that could be the case and I could have different ": [
            1571.5,
            1596.5,
            41
        ],
        "it again. No, sew so suppose I did a bunch of unions and this this tree was the result right now. Yes, the result of doing a bunch of stuff and then the next operation was fine to see until finding it you basically just every every vertex along the way you just redirected to the route. yeah, yeah, because remember Union is Define to find each vertex first and ": [
            781.5,
            830.3,
            20
        ],
        "it works is another case. Okay doesn't always work just as in life acting in one's immediate best interest is not always the best longer-term strategy. Does anybody have any examples? Not going to class. Wait, but how is that in one's immediate best interest? Cuz because he wanted to sleep or play video games or you forgot to have lunch and or you wanted to meet up with somebody ": [
            1822.5,
            1855.8,
            48
        ],
        "it's and it's rank is set to zero. So that's good. And then so suppose every vertex of rank K has has its height as K. So now consider a vertex of rank a plus one. The only way it can be ranked k + 1 is if you Union two vertices of rank K and if that happened then one of them would be K plus one and will ": [
            162.0,
            190.4,
            3
        ],
        "just means when you average it over the whole algorithm. It will average out to log star. And Union is also a more ties to log * so basically now we get that the out running the algorithm is elog * n we still have this bottleneck of sorting but if we take if we assume that all the information comes in sorted then we get you know, Big O ": [
            1254.5,
            1285.6,
            33
        ],
        "log log 8.9. And so how many times do you have to log it over over and over until you get less than 1? next song So it turns out that. This is a very slow growing function. Okay, in fact if you want log star and be greater than 5 Uniden to be greater than 2 raised to the 65536 power. Which is really big, right? so super all ": [
            1101.2,
            1148.1,
            29
        ],
        "long-term. Okay looking for internship. Yeah. What you're giving up having fun? But yeah, I know I mean if if that's what you consider best then yeah, that's the that's the best way. So we're going to see here that some algorithms have a lot of may be obvious best choice choices, but they may not all lead to the optimal answer. Okay, so some other techniques that I will ": [
            1942.5,
            1986.6,
            51
        ],
        "of e-log star. And which I like to call linear star time cuz it's it's almost linear right? It's basically linear for any reasonably sized graph questions about that. Okay, let's move on. Reading strategies talked about greedy strategies, but let's kind of talk about them and more generality strategies are usually used to solve optimization problems optimization problems are generally when you try to solve a problem you're trying ": [
            1285.6,
            1327.9,
            34
        ],
        "of events has n then checking all possibilities it would take. to the end to the end she goes to all the subsets check if it's valid and then store the the number and just do that for every single subset and then find the maximum out of all those okay, so I guess we'll start with this on Monday because Friday we're going to have our quiz and we'll ": [
            2898.3,
            2933.4,
            75
        ],
        "of just asking about every single possible solution. Okay, so the greedy method in some cases not all. There's like a sufficient structure in the actual problem where you can just blindly make the best local choice and it will get you to the to the right answer. Just called the greedy method you can you can just find the greedy method for pretty much any problem whether or not ": [
            1788.1,
            1822.5,
            47
        ],
        "of shortens that shortens the tree. So every subsequent time you you you call that vertex again, you only have to go up once you don't have to go up the whole length of the tree anymore. Okay. So for each vertex, you only really have to go up the farthest length only one time every other time you look at it. You only have to go up one Edge. ": [
            539.4,
            565.1,
            14
        ],
        "of the cookies in. grams Those are the small cookies though, right? How much is 100 G? Chip Ahoy Okay, so you need 6 chip ahoys basically, yeah. Okay, so what's a good algorithm to do this? Take the biggest cookie. So this will be a greedy strategy take the biggest cookie remove it from the pile and then repeat six times, right? So, how would that look you take ": [
            2099.0,
            2147.4,
            55
        ],
        "of the problem. If you swap go Bank. Okay, so if I swap 99 + 81 instead put 97 + 85 then, instead of 99 + 81 don't have 97 + 85 and that means it's going to be 9981 is what hundred and eighty. + 97 + 85 is 182 sweet Pecan up by two and that's it. I mean this might not be the best solution but it ": [
            2435.2,
            2476.8,
            63
        ],
        "on the other seating chart. Any other questions? Okay. So the last part of Monday's lecture I kind of went through it a little fast. So let's let's just revisit it. We did a few proofs. and these proofs were supposed to justify why the heights of the trees will stay short, right? We wanted the heights of the trees never to get any any taller than login or their ": [
            85.5,
            129.5,
            1
        ],
        "one comes from that added Edge Plus the height of that other tree. Okay. So the other thing that we wanted to show is that any routenote of rank K has at least two the caver to seize. This is a simple induction proof to a root node has only one vertex and it has rained 0. And let's suppose that a root of Frank K has at least two ": [
            222.6,
            249.3,
            5
        ],
        "out to be the worst possible one. So the greedy strategy gave you the worst possible selection of six cookies with the constraints. Are usually doesn't give us the optimal room temperature inside the best. Yeah, so that's how you describe the greedy algorithm whether or not it gives you the optimal solution is what we're going to have to do to prove it. I need for this problem solution. ": [
            2613.8,
            2654.0,
            68
        ],
        "parent to be the route. Rank and then I move up to Dee and I say okay read DirecTV's parent to be the root. Okay, then I move up to a and I say redirect a parent to be the root and I'm about to eat and I found the route so then I'm done. So everybody along the way you just redirect them all to be the child direct ": [
            905.5,
            930.7,
            23
        ],
        "reasonably sized graphs log star and is basically constant time right? Because it has this upper bound of four, right? You're you're not really going to get any inputs that are bigger than this. can't really think of I mean how many particles are there in the universe? There's only like two to the 200 or something, right? Anybody know? any physicists in here I'm fairly confident that to to ": [
            1148.1,
            1184.9,
            30
        ],
        "right is just say, well there's this other solution that has a a better objective function. Okay. Can anybody give me a better solution? No, I so when I say solution, I mean a subset of 6. another solution not another algorithm just another solution. Know the solution remember we did this solution for me. So in this case, the solution format is a subset of 6 cookies like solution ": [
            2390.1,
            2435.2,
            62
        ],
        "runtime of this discrete this disjoint sets data structure. Is it actually going to improve the runtime of crystals? The answer is no. But suppose that the information comes in already sorted then we can improve on the time. Alex just say edges if edges Are already sorted? then it is worth it. Okay to the way to do it is by or one way to do it is by ": [
            461.0,
            510.6,
            12
        ],
        "slower than lockstar so long stars like an upper bound of inverse Ackerman. and actually I think that this with Pat compression you actually get ackermann function as the upper bound but log star is easier and easier up or down to prove. It's still pretty slow. Any other questions? So if we improve crusco's then fine turns into. An amortized cost of log, * what does that mean? That ": [
            1213.9,
            1254.5,
            32
        ],
        "solution space here is all subsets when we all know that the number of subsets of a set of size and is 2 to the end. So at least we know kind of what we're working with and and how we should. How was your week consider a solution to be better than Brute Force, right? So for example, if T is the set of the events and the number ": [
            2875.9,
            2898.3,
            74
        ],
        "solution? was that Yeah, we took the largest cookie. But what else? The same exact solution that we got when we did the greedy the other way. So this is just to demonstrate to you that to you that it might look like it's working but it's actually Not this this example was I took it from a book and it's actually very particularly chosen all the values. This turns ": [
            2575.2,
            2613.8,
            67
        ],
        "spend so it's kind of like a funny way to think about it. But the idea is that now instead of having a Having a cost every time you find a view every time you run fine. We're going to look at an amortized cost of how long does it take to run find m x song. Whenever you call a Vertex at points B and all of its ancestors ": [
            1000.9,
            1029.4,
            26
        ],
        "talk about some different greedy strategy is which ones work which ones don't and See you guys on Friday. ": [
            2933.4,
            2942.6,
            76
        ],
        "that you liked or. Yeah, but then it's might not be in your best interest because in the longer term you may not do well on your exam. Anybody else? going to class because then you missed that date would that person and Are you are you starved or you you didn't get enough sleep, right? So you dropped your laptop out the window? But how is that in your ": [
            1855.8,
            1900.8,
            49
        ],
        "the 65536 is more than the number of atoms in the universe. So if you have a graph that has all the atoms connected and stuff like that, then it's still you still would have log star of that number to be equal to 4. I forgot what I was reading book with lock star was unable to like in which of the ocean. Inverse of ackermann function actually grows ": [
            1184.9,
            1213.9,
            31
        ],
        "the biggest cookie? Okay, then remove it. o99 99 remove it 97 remove it 94 and then 92 and then 88 and then 85 and that's it, right? Okay, we're done. Okay. And then we're going to eat 555g of cookie. Okay, that's fine. Okay, what about if I'm restricted to only selecting one cookie from each row? What would be a greedy algorithm to do this? Child start from ": [
            2147.4,
            2192.2,
            56
        ],
        "the cost of calling find f x is log * m n so have you guys heard of log star before? Okay log star and is the number of times you have to log in to get back to 1? Okay. So for example Log star of 10,000 is 4 because log of 10,000 is 13 log log of 10,000 is 3 log log log is 1.9 + log log ": [
            1059.8,
            1101.2,
            28
        ],
        "the top row and pick the biggest cookie start from the second row and pick the biggest cookie starts in the third row or alternatively pick the biggest cookie overall and then remove its row, right? Then pick the next biggest cookie overall and remove its Roe. Frank and then pick the next one which is what 75? 80 top rail and then what 75? 7076 and then 70 weight ": [
            2192.2,
            2236.6,
            57
        ],
        "the way I did it was not using a greedy strategy. Okay, I want to do one more one more demonstration of this. So I suppose the Cookie Monster was going on a diet. Okay, but he still wanted to eat 6 cookies. But now the objective function is to minimize right? So what would the greedy strategy here be a might not work, but you could think about what ": [
            2507.2,
            2538.0,
            65
        ],
        "the what is the runtime now this thing we're not going to go too deep into it cuz it's kind of like. I don't know it takes a while but it is given in the book and you can take a look and they do give you a A nice little analogy of like giving the vertices like money to spend and then like how much money did each vertex ": [
            977.3,
            1000.9,
            25
        ],
        "then when you call those finds you You are you clean up? P0180 because they're not on the path of see it's it's it's it's dependent on like what operation I'm doing. So if later I I did find B, then then be would be the redirected also. Yeah. So after a while if you find enough things the result is just going to be a root node with a ": [
            830.3,
            867.6,
            21
        ],
        "those in let's just move on a little bit. Alright, so this is what you get. This is what we got by doing it. Okay, if we get 404 Okay. So my question to you is is this the optimal strategy? Not necessarily, right? Okay. So every time you say it's not the optimal strategy, you have to come up with a counterexample. That's the best way to prove it ": [
            2361.7,
            2390.1,
            61
        ],
        "to III and A2 gets directly pointed to III even though it's already pointing to it. B 0 and then we have the rest, right? Everybody along the path that I had to go up will point up to eat. all of these in so as you go up. Every vertex that you encounter on your way up you redirect its parent to be directly to the root. We say ": [
            723.1,
            781.5,
            19
        ],
        "to do that, I have to climb the tree in an end while I'm climbing the tree. Why don't I just keep on pointing everybody back to the route? Okay. So when I when I do find see the result would look like so I'm going to kind of Do something in here? queso I said Z C 0 and a point that to E3 right D1 gets directly pointed ": [
            691.2,
            723.1,
            18
        ],
        "to find the best solution among a large space of possibilities. Okay. So let's try to break down an optimization problem. You have your instance your input Your solution format. What is your output supposed to look like the constraints? What properties does your solution have to have and the objective function? How do you know if given two solutions? How do you know one is better than the other? ": [
            1327.9,
            1353.0,
            35
        ],
        "to the K vertices. So again, the only way that you can get a root of k + 1 is if you Union to rank a vertices and if each one of those subtrees has more than two to the K vertices and then when you put them together and has to the k+ to the K vertices or more. Okay, any questions about that? Okay, that's going to give ": [
            249.3,
            279.2,
            6
        ],
        "to the root the ranks don't necessarily represent the height of the graph anymore. So that's sort of lost right because the grass are going to start getting shorter and shorter, but at least they're there an upper bound on how high by the tree is so that's a no Okay. So how much does it help so without pack compression the height will be log and with Pat compression ": [
            1029.4,
            1059.8,
            27
        ],
        "towards an efficient algorithm is to break that massive Global search that kind of Brute Force search into a series of like simple local searches where hopefully at each stage we're kind of getting closer and closer to the optimal solution. But you can't tell which local choices best. You may still have to kind of search all possible choices, but at least you're sort of doing it intelligently instead ": [
            1757.4,
            1788.1,
            46
        ],
        "us a bound. Okay Suppose there and vertices. Hobart XR Bank login has at least and vertices. Right? So if you have a vertex of rank anything bigger than login, it's going to have at least more than and vertices. So basically what I'm saying here, is that the hot the the maximum height you can have is login. And then that that balance all of our operations any questions ": [
            279.2,
            308.9,
            7
        ],
        "using something called path compression. And the idea here. Is that every time you you see a Vertex every time you you're finding. White River when you find your you're climbing up until you see the route so as you climb up you do a bit of housekeeping and so every vertex on that climb, you just attach it directly to the root. And what does that do? It kind ": [
            510.6,
            539.4,
            13
        ],
        "was the what was the last Union that I did with this tree? a union the two trees together the the the route and the route e Okay. Anyhow, so we have this tree and let's say the operation than I call is. find see do just fine and see all I want to Output is a I want to me. I want to Output the route. But in order ": [
            656.1,
            691.2,
            17
        ],
        "will look at our backtracking dynamic programming hill climbing sarcastic search heuristics. These are all ways that you take the big Global search and break it down to little local searches that you do in order to get there. Okay, so let's look at a very simple example. Okay suppose you're the Cookie Monster and you have a 6 by 6 sheet of freshly baked cookies in front of you. ": [
            1986.6,
            2016.1,
            52
        ],
        "you know, when and is the number of vertices and so in order to show this let's prove it. So we proved it in with two different. Sprite with two with two claims for the first claim is that the ranks actually correspond to the heights of the trees and so here's an induction proof will just go over it quickly. A Vertex by itself has has hide zero and ": [
            129.5,
            162.0,
            2
        ],
        "you plug in a solution that gives you a number so that would be the number and that would also be like the bandwidth of the path. And I guess I guess we should say. Objective is to maximize right? Maximize this thing. Where is this one you want to minimize minimize? Okay, so in a lot of algorithmic problems that we'll see in this class and a lot that ": [
            1690.7,
            1726.5,
            44
        ],
        "you'll encounter the space of solutions is exponential. So obviously you could you could just search through all the solutions exponentially large still is finite so you can still do it in finite time. And sometimes this is the best way to do it unless p is equal to NP the best algorithms that we have for certain problems are still exponential time. So a good way to make progress ": [
            1726.5,
            1757.4,
            45
        ]
    },
    "File Name": "Design___Analysis_of_Algorithm___A00___Jones__Miles_E___Winter_2019-lecture_10.flac",
    "Full Transcript": "Okay, good morning. I mean good afternoon everyone anybody have any questions before we begin? We're going to give you all the seating chart right for the quiz. Okay, so make sure you go to the quiz section that you are assigned to if there is a circumstance where you need to change sections then just let me know by email and I'll make sure that you're on the other on the other seating chart.  Any other questions?  Okay. So the last part of Monday's lecture I kind of went through it a little fast. So let's let's just revisit it. We did a few proofs.  and these proofs were supposed to  justify why the heights of the trees will stay short, right? We wanted the heights of the trees never to get any any taller than login or their you know, when and is the number of vertices and so in order to show this let's prove it. So we proved it in with two different.  Sprite with two with two claims for the first claim is that the ranks actually correspond to the heights of the trees and so here's an induction proof will just go over it quickly.  A Vertex by itself has has hide zero and it's and it's rank is set to zero. So that's good. And then so suppose every vertex of rank K has has its height as K. So now consider a vertex of rank a plus one. The only way it can be ranked k + 1 is if you Union two vertices of rank K and if that happened then one of them would be K plus one and will be the height of the other tree plus that other Edge can we do like kind of a picture so suppose this tree has height k,  and this tree also has hike k  so then when we Union them together  I mean straight like this.  You are you add that edge right there? And now this has hiked a plus one and it says hike K and the K plus one comes from that added Edge Plus the height of that other tree.  Okay. So the other thing that we wanted to show is that any routenote of rank K has at least two the caver to seize. This is a simple induction proof to a root node has only one vertex and it has rained 0.  And let's suppose that a root of Frank K has at least two to the K vertices. So again, the only way that you can get a root of k + 1 is if you Union to rank a vertices and if each one of those subtrees has more than two to the K vertices and then when you put them together and has to the k+ to the K vertices or more.  Okay, any questions about that?  Okay, that's going to give us a bound.  Okay Suppose there and vertices.  Hobart XR Bank login has at least and vertices. Right? So if you have a vertex of rank anything bigger than login, it's going to have at least more than and vertices. So basically what I'm saying here, is that the hot the the maximum height you can have is login.  And then that that balance all of our operations any questions about that.  Okay good. So that sounds all of our operations. So now instead of finding the height of the tree we can actually change it to find being login Union being login.  Where n is the number of vertices and so now the wrong times of crew schools will make set is20 is big old one fine is Big O V Union is bigger a V and sorting is e lockie.  right  so  we basically have like the runtime of the algorithm which is this plus how long it takes to sort and the result we get is Big O of elog V.  Any questions about that?  Because I log.  e  Is Big O of log V?  four pics eight actually  You can just kind of put them all together.  It's fine.  Just makes it simpler to look at.  And it's not be pussy anymore because the input remember is a connected graph and 4 connected graphs.  He is big Omega of the  Okay, so so there's two components to kruskal's algorithm. There's the sorting and then there's the algorithm so it's this is really as best as we can do right because it takes just this long to sort it, right. So sorting a sort of the bottleneck. So if we do any improvements on kruskal's algorithm, it won't improve the overall run time anymore. If we were able to do the the whole process in linear time, the whole algorithm is still going to take elog be because that's how how long it takes to sort.  But that being said we are going to think about can we improve the runtime of Union? Can we improve the runtime of this discrete this disjoint sets data structure.  Is it actually going to improve the runtime of crystals? The answer is no.  But suppose that the information comes in already sorted then we can improve on the time.  Alex just say edges if edges  Are already sorted?  then  it is worth it.  Okay to the way to do it is by or one way to do it is by using something called path compression.  And the idea here. Is that every time you you see a Vertex every time you you're finding.  White River when you find your you're climbing up until you see the route so as you climb up you do a bit of housekeeping and so every vertex on that climb, you just attach it directly to the root. And what does that do? It kind of shortens that shortens the tree. So every subsequent time you you you call that vertex again, you only have to go up once you don't have to go up the whole length of the tree anymore. Okay. So for each vertex, you only really have to go up the farthest length only one time every other time you look at it.  You only have to go up one Edge.  Okay, so this is how they describe it in the book. I'm just going to give you guys like a an example of what it would look like. Okay, so let's just make up an example.  Let's say that this tree has is height to okay. So let's say a is too and then we have B.  0  and a shady one.  where's cc0 and  I don't know maybe.  That and maybe we'll make a tree of height 3. So it's a we have e  is 3  and then we have  f-zero  Angie 1 + H20  Grinch song let's say we had that tree and I might have it might look kind of weird the way that I built it, but I'm trying to have a tree that's actually able to be built using the Union's right? And so what was the what was the last Union that I did with this tree?  a union the two trees together the the the route and the route e  Okay. Anyhow, so we have this tree and let's say the operation than I call is.  find  see  do just fine and see all I want to Output is a I want to me. I want to Output the route. But in order to do that, I have to climb the tree in an end while I'm climbing the tree. Why don't I just keep on pointing everybody back to the route? Okay. So when I when I do find see the result would look like so I'm going to kind of  Do something in here?  queso  I said Z C 0 and a point that to E3 right D1 gets directly pointed to III and A2 gets directly pointed to III even though it's already pointing to it.  B 0 and then we have the rest, right?  Everybody along the path that I had to go up will point up to eat.  all of these in  so as you go up.  Every vertex that you encounter on your way up you redirect its parent to be directly to the root.  We say it again.  No, sew so suppose I did a bunch of unions and this this tree was the result right now.  Yes, the result of doing a bunch of stuff and then the next operation was fine to see until finding it you basically just every every vertex along the way you just redirected to the route.  yeah, yeah, because remember Union is Define to find each vertex first and then when you call those finds you  You are you clean up?  P0180 because they're not on the path of see it's it's it's it's dependent on like what operation I'm doing. So if later I I did find B, then then be would be the redirected also. Yeah.  So after a while if you find enough things the result is just going to be a root node with a bunch of vertices only on one level, right?  And we're taking care of those those redirections during times when we have to do something anyway, so we're like not really losing out.  We go all the way up so member what fine does is you start at the vertex you're finding in this case see right? So what I'm going to do is I'm going to say okay redirect cease parent to be the route.  Rank and then I move up to Dee and I say okay read DirecTV's parent to be the root. Okay, then I move up to a and I say redirect a parent to be the root and I'm about to eat and I found the route so then I'm done. So everybody along the way you just redirect them all to be the child direct child of the route. So that means next time I call find C. I only have to do one.  one thing  PriceSmart though, right  Log of and lock up the highest number of elements.  You got to Traverse through the many ways and so if you do a constant time thing while you're going up, you're not really adding exponential asymptotic lie to your run time.  Yeah.  So what is the what is the runtime now this thing we're not going to go too deep into it cuz it's kind of like.  I don't know it takes a while but it is given in the book and you can take a look and they do give you a  A nice little analogy of like giving the vertices like money to spend and then like how much money did each vertex spend so it's kind of like a funny way to think about it. But the idea is that now instead of having a  Having a cost every time you find a view every time you run fine. We're going to look at an amortized cost of how long does it take to run find m x song.  Whenever you call a Vertex at points B and all of its ancestors to the root the ranks don't necessarily represent the height of the graph anymore. So that's sort of lost right because the grass are going to start getting shorter and shorter, but at least they're there an upper bound on how high by the tree is so that's a no  Okay. So how much does it help so without pack compression the height will be log and with Pat compression the cost of calling find f x is log * m n  so have you guys heard of log star before?  Okay log star and is the number of times you have to log in to get back to 1?  Okay.  So for example  Log star of 10,000 is 4 because log of 10,000 is 13 log log of 10,000 is 3 log log log is 1.9 + log log log log 8.9.  And so how many times do you have to log it over over and over until you get less than 1?  next song  So it turns out that.  This is a very slow growing function.  Okay, in fact if you want log star and be greater than 5 Uniden to be greater than 2 raised to the 65536 power.  Which is really big, right?  so  super all reasonably sized graphs log star and is basically constant time right? Because it has this upper bound of four, right? You're you're not really going to get any inputs that are bigger than this.  can't really think of  I mean how many particles are there in the universe? There's only like two to the 200 or something, right?  Anybody know?  any physicists in here  I'm fairly confident that to to the 65536 is more than the number of atoms in the universe. So if you have a graph that has all the atoms connected and stuff like that, then it's still you still would have log star of that number to be equal to 4.  I forgot what I was reading book with lock star was unable to like in which of the ocean.  Inverse of ackermann function actually grows slower than lockstar so long stars like an upper bound of inverse Ackerman.  and actually I think that  this with Pat compression you actually get ackermann function as the upper bound but log star is easier and easier up or down to prove.  It's still pretty slow.  Any other questions?  So if we improve crusco's then fine turns into.  An amortized cost of log, * what does that mean? That just means when you average it over the whole algorithm. It will average out to log star. And Union is also a more ties to log *  so basically now we get that the out running the algorithm is elog * n  we still have this bottleneck of sorting but if we take if we assume that all the information comes in sorted then we get you know, Big O of e-log star.  And which I like to call linear star time cuz it's it's almost linear right? It's basically linear for any reasonably sized graph questions about that.  Okay, let's move on.  Reading strategies talked about greedy strategies, but let's kind of talk about them and more generality strategies are usually used to solve optimization problems optimization problems are generally when you try to solve a problem you're trying to find the best solution among a large space of possibilities.  Okay. So let's try to break down an optimization problem. You have your instance your input Your solution format. What is your output supposed to look like the constraints? What properties does your solution have to have and the objective function? How do you know if given two solutions? How do you know one is better than the other?  So for example, let's think about shortest path. Let's say in shortest path between two points in a graph.  between two points  case of the instance is going to be a graph.  start  node and endnote  And maybe you have positive Edge weights or something like that, right? But that's just the information given so what's the solution for Matt? What is the solution going to look like in general?  Okay a list of vertices or a list of edges write a path.  What's the constraint?  Willa path is a valid path. But where does it start and where does it end?  Okay, good. So has two.  start  s and end  At T I just called these S&T. Okay.  Good and then what's the objective?  What is the function like the objective is basically a function that you input and a solution and outputs a number.  So this one is  the path length, which is the the sum of all the edge lengths, right?  Or the sum of all the edges in the past the length of the edge.  questions about that  Okay, so that's what we have right? Yeah. Okay. I want you guys to think of think for a few minutes. How would you fill in the details for the Mac Band with path problem?  I'll give you a hint. This is a optimization problem. Ready go.  If you want you want me to put it on this again?  I'm so damn real world situation with Max that would be direct or indirect by Direct Communications. I would say it's directed and I'm thinking more of like the the water flow kind of situation where  The water can flow both directions through a pipe. So  Yeah, I would think that the for the minimum spanning tree now that that should not be directed The Venomous penetration always be undirected graph, which is your kind of thing. Where if if this one can communicate to that one then they should be able to communicate back and then if you cut all the lines  what kind of by Direction where is kind of like TCG?  Exactly. Yeah exactly. You need to be able to  but this one but Mac bandwidth is like how much can I push through this network in the network has to be directed so I know which direction they go. Now. Maybe there is a pipe that goes this way and a pipe that goes back that could be the case and I could have different bandwidth.  Is that what you guys got?  Pictures of this gives you a sense of why the shortest path problem and the max bandwidth problem are so similar. Do you remember we used like basically the same dijkstra type algorithm to solve them both, right? Because all of all of the solution format is the same and basically what the kind of the scaffolding that we used was Graph Search and what is Graph Search give you  That's right. Exactly the type of solution that we want.  Okay, what was the objective again? The minimum overall edges in the path?  weight of edge  So the objective function is not doesn't tell you the you know, the optimal thing the objective function all it does it tells you how to compare two solutions to potential Solutions. So it's a function that you plug in a solution that gives you a number so that would be the number and that would also be like the bandwidth of the path.  And I guess I guess we should say.  Objective is to maximize right?  Maximize this thing. Where is this one you want to minimize minimize?  Okay, so  in a lot of algorithmic problems that we'll see in this class and a lot that you'll encounter the space of solutions is exponential. So obviously you could you could just search through all the solutions exponentially large still is finite so you can still do it in finite time. And sometimes this is the best way to do it unless p is equal to NP the best algorithms that we have for certain problems are still exponential time. So a good way to make progress towards an efficient algorithm is to break that massive Global search that kind of Brute Force search into a series of like simple local searches where hopefully at each stage we're kind of getting closer and closer to the optimal solution.  But you can't tell which local choices best. You may still have to kind of search all possible choices, but at least you're sort of doing it intelligently instead of just asking about every single possible solution.  Okay, so the greedy method in some cases not all.  There's like a sufficient structure in the actual problem where you can just blindly make the best local choice and it will get you to the to the right answer.  Just called the greedy method you can you can just find the greedy method for pretty much any problem whether or not it works is another case. Okay doesn't always work just as in life acting in one's immediate best interest is not always the best longer-term strategy. Does anybody have any examples?  Not going to class.  Wait, but how is that in one's immediate best interest?  Cuz because he wanted to sleep or play video games or you forgot to have lunch and or you wanted to meet up with somebody that you liked or.  Yeah, but then it's might not be in your best interest because in the longer term you may not do well on your exam.  Anybody else?  going to class because then you missed that date would that person and  Are you are you starved or you you didn't get enough sleep, right?  So you dropped your laptop out the window?  But how is that in your immediate best interest?  Are you dropped off the window from your apartment?  Oh wow.  So you saved you saved yourself the the the manual labor of walking it down the stairs and you gained you gained that but then you lost in the longer-term maybe a financial burden.  But has anybody have any examples of when acting in your best your immediate been best interest is actually better for the long-term.  Okay looking for internship.  Yeah.  What you're giving up having fun?  But yeah, I know I mean if if that's what you consider best then yeah, that's the that's the best way. So we're going to see here that some algorithms have a lot of may be obvious best choice choices, but they may not all lead to the optimal answer.  Okay, so some other techniques that I will will look at our backtracking dynamic programming hill climbing sarcastic search heuristics. These are all ways that you take the big Global search and break it down to little local searches that you do in order to get there.  Okay, so let's look at a very simple example. Okay suppose you're the Cookie Monster and you have a 6 by 6 sheet of freshly baked cookies in front of you. The cookies are all chocolate chip cookies, but they may have different sizes.  You're only allowed to take 6 cookies. How can you maximize your total cookie intake? Okay, let's so give you an example or let's first let's let's look at the breakdown. The instance is the  the sizes  of cookies  But let's let's just assume that the Cookie Monster has the ability to determine the size of a cookie by just looking at it in constant time.  The solution format is a set.  subset  of 6 constraints are no constraints.  And the objective is to maximize.  the sum of all the sizes of all the cookies  I just put to see.  Where cookie is in your subset?  Okay, let's look at an example.  What kind of algorithm would I use let's say that these are the the size of the cookies in.  grams  Those are the small cookies though, right?  How much is 100 G?  Chip Ahoy  Okay, so you need 6 chip ahoys basically, yeah.  Okay, so what's a good algorithm to do this?  Take the biggest cookie.  So this will be a greedy strategy take the biggest cookie remove it from the pile and then repeat six times, right? So, how would that look you take the biggest cookie? Okay, then remove it.  o99  99 remove it 97 remove it 94  and then 92 and then  88  and then 85 and that's it, right? Okay, we're done.  Okay.  And then we're going to eat 555g of cookie. Okay, that's fine.  Okay, what about if I'm restricted to only selecting one cookie from each row? What would be a greedy algorithm to do this?  Child start from the top row and pick the biggest cookie start from the second row and pick the biggest cookie starts in the third row or alternatively pick the biggest cookie overall and then remove its row, right?  Then pick the next biggest cookie overall and remove its Roe.  Frank and then pick the next one which is what 75?  80 top rail  and then what 75?  7076  and then  70  weight 73 hair  and 68. Thank you.  Okay, great. So those are both greedy strategies and they both work and we're not going to prove them. But we all kind of have a good feeling that they were. Okay and then do you get 481 cookies? Okay. So what is it? What's the format for this one? It's the same right? You have your sheet?  a cookies  you have your solution format is a subset.  Of sixth the constraints is that no two cookies.  In same row and then the objective is the total size difference between those was that now I have a constraint put one more constraint on it.  What if what is algorithm you could use to select the best option? If you can't select two cookies from the same row or column can anybody give me a greedy strategy to do this?  Take me to Vegas and all that guy 99.  Okay good.  And repeat. Okay. I didn't finish this animation. Okay, let's just do it this way by what's the next biggest 81  Right, and then the next biggest is what 74?  That right.  okay, and then  50 snow 60  and then 50  Oh, no.  And then 40, right?  Okay.  So then we you can fill those in let's just move on a little bit. Alright, so this is what you get. This is what we got by doing it. Okay, if we get 404  Okay. So my question to you is is this the optimal strategy?  Not necessarily, right? Okay. So every time you say it's not the optimal strategy, you have to come up with a counterexample. That's the best way to prove it right is just say, well there's this other solution that has a a better objective function. Okay. Can anybody give me a better solution?  No, I so when I say solution, I mean a subset of 6.  another  solution not another algorithm just another solution.  Know the solution remember we did this solution for me.  So in this case, the solution format is a subset of 6 cookies like solution of the problem.  If you swap go Bank.  Okay, so if I swap 99 + 81 instead put 97 + 85 then, instead of 99 + 81 don't have 97 + 85 and that means it's going to be 9981 is what hundred and eighty.  + 97 + 85 is 182 sweet Pecan up by two and that's it. I mean this might not be the best solution but it at least shows us that the the one our algorithm gave us is not the best and that's what's important.  Okay. So here's a just another one that I put  okay. So here's the actual best solution for this problem. Okay. So the greedy algorithm gave us 404 the actual best solutions for 58. How do I get there? Well, I'll let you guys think about how to do it the way I did it was not using a greedy strategy.  Okay, I want to do one more one more demonstration of this. So I suppose the Cookie Monster was going on a diet. Okay, but he still wanted to eat 6 cookies. But now the objective function is to minimize right? So what would the greedy strategy here be a might not work, but you could think about what I could do is pick the the smallest cookie, which is 40 cross out the row and column right then pick the next smallest which is 50 cross out the row and column.  Then pick the next smallest, which is 60.  Knock out the row and column. The next smallest is.  74  and then the next smallest is 81.  The next smallest is 99.  You guys notice anything about this solution?  was that  Yeah, we took the largest cookie. But what else?  The same exact solution that we got when we did the greedy the other way. So this is just to demonstrate to you that to you that it might look like it's working but it's actually  Not this this example was I took it from a book and it's actually very particularly chosen all the values. This turns out to be the worst possible one. So the greedy strategy gave you the worst possible selection of six cookies with the constraints.  Are usually doesn't give us the optimal room temperature inside the best.  Yeah, so that's how you describe the greedy algorithm whether or not it gives you the optimal solution is what we're going to have to do to prove it.  I need for this problem solution.  And usually candy and then what you're doing is a Greek alphabet that are not real.  Right. Yeah kind of greedy though. Right in a sense. You're like always picking the lowest one.  to look at next  and then it makes sense because whatever when you make a column, what do you think? I'm spooky.  Would that work? Okay. Well, then you can't solve it with a greedy algorithm at Eastpoint.  Good.  good observation  Okay. So let's just go through this a few more slides here. So doesn't always work and because of that right like you were staying up there. We have to prove that it works. Once we once we make it right or else we must present a counterexample like we did before.  Okay, so furthermore for single problem. There might be one more than one greedy Choice best choice and one of them may work and one of them may not work. We we just saw that piece of the next example, we're going to look at I want you guys to get started on this is event scheduling. Okay. So suppose you're running a cookie conference and you have a collection of events or talks people talk about which is their favorite cookie or this and that each of them has a start time and end time. Okay Ono you only have one conference room. So now you have to schedule as many stalks as possible. Okay?  And none of them have to overlap. So how do we fill in this thing? The instance is a set of intervals.  With a start time and a finish time.  What's the solution for Matt? I guess we could do like start one finish one start to finish two and so on.  start and finishing  What's the solution format?  Okay good so subset.  intervals  What's the constraint?  best objective  Okay good. So they right they don't.  overlap  And then the objective is maximized.  size of subset  so  I like to do it this way because this gives you a sense of like the size of the problem the solution space here is all subsets when we all know that the number of subsets of a set of size and is 2 to the end. So at least we know kind of what we're working with and and how we should.  How was your week consider a solution to be better than Brute Force, right? So for example, if T is the set of the events and the number of events has n then checking all possibilities it would take.  to the end  to the end  she goes to all the subsets check if it's valid and then store the the number and just do that for every single subset and then find the maximum out of all those  okay, so I guess we'll start with this on Monday because Friday we're going to have our quiz and we'll talk about some different greedy strategy is which ones work which ones don't and  See you guys on Friday. "
}