{
    "Blurbs": {
        "1 so you ignore it, but C&E have distance of infinity. So you put those in And what do you set them to? to write so what is your cue look like we'll be has been ejected D moves to the front and then you have c and e like that. questions about that You guys probably are I've all seen this already before. Okay, so let's just finish it ": [
            826.6,
            869.8,
            22
        ],
        "And that sense you might say Okay. I want to I want to find the sequence of flights that I travel that give me the the shortest distance, right? Anybody have any other I think so cost. Good, so maybe instead of instead of trying to minimize distance. You don't care about the distance. You just want it to cost the least and so What sequence of flights cost the ": [
            1759.7,
            1792.8,
            46
        ],
        "F you update it with this value depending on its neighbors. So same same idea. We're going to initialize v&s for all those. Well, f is not empty. Let's pick some v&f and we're going to see that for now. We'll just pick any V. But we're going to see that the power of dijkstra's algorithm is that we're going to pick the v in a very special way and ": [
            2805.0,
            2840.3,
            71
        ],
        "How would you use BFS as a reduction to solve this problem ready? Go? El Sobrante Hi, dear, find what? Now we're going to the next thing we're going to talk about is dijkstra's algorithm, which is a good way to do this. But that is not a reduction is it that's a modification so I kind of want to first thing about it. Is there a way to do ": [
            2179.6,
            2263.6,
            56
        ],
        "I saw it somewhere else but I like this idea of to get the output tree think about all of these vertices as like balls and the edges are our strings, right? So what you can think about is grab a grab your starting for a text and let all the other things hang and what does it look like? you have a and you have B&D here. and then ": [
            971.3,
            1004.5,
            25
        ],
        "Let's let's think about the differences between stacks and queues peso. The queue actually gives you more information in the Stacked us right cuz the Q starts with just the node ass. It's the only one that has distant 0 right. What are the next nodes to be put into the Q? Okay, so the neighbors of s right so all the neighbors of s will have distance one, right? ": [
            449.5,
            483.7,
            11
        ],
        "Let's make this song. Let's turn out down the light so we can have a more intimate setting. Okay, so I have some good news, and I have some. Was good news. If you look at it one way and its other kind of news if you look at it another way. So the good news is that we're going at a good pace and we're kind of ahead of ": [
            9.3,
            42.2,
            0
        ],
        "Remember, it keeps on like updating. It keeps on going until you go through all the vertices even if they're not connected. Where is BFS only gives you info information related to a given vertex. So it's very vertex Pacific. Right? Cuz you're getting all the shortest paths from ass. I don't know the shortest path between any other pair of vertices. I only know what they are in terms ": [
            1658.5,
            1682.3,
            43
        ],
        "So those all get put into the queue, right? Then since we're doing the first in first out, all of the nodes of distance one will be explored. And as you explore each one of those you're finding all the distance to vertices and those are going to be going into the end of the queue, right and all the distance one vertices will be explored before you even consider ": [
            483.7,
            510.6,
            12
        ],
        "They supposed to Sunriver text that there's a path P from s2v such that the length of P. The length of the path is actually shorter than whatever BFS set the distance to. Okay, so just like we did before we're going to suppose that this path exists and we're going to find the contradiction. So let me just introduce another notation. Let's say that D of V. Is the ": [
            1312.3,
            1347.1,
            33
        ],
        "a stack. We saw that earlier this week. Then you're talkin about DFS. What we're going to look at now is if f is a q so the first found is the first explored right Isn't that how it is? Yeah. And then the end then if we have time we might get to F being a priority queue, but that's probably more likely to be next week's lesson. queso ": [
            410.6,
            446.4,
            10
        ],
        "actual length of the shortest path among all pass from s2v. The actual length. Remember that diss to be Is the is the value that the algorithm gives it we haven't shown that those are going to be equal yet, right? That's that's kind of what we're trying to prove now. Okay, so we have this path from s2v. We know that dissed s is equal to DS. Because we ": [
            1347.1,
            1376.5,
            34
        ],
        "algorithm. Okay. What is dijkstra's algorithm do? The input is a graph with Edge lengths and a starting vertex. The output is going to be for all the vertices that are reachable. It will give you dissed you. Will be set to the distance from s to you using those Edge weights basically the shortest path. I guess I should highlight that distance means shortest path. Break the minimum over ": [
            2743.6,
            2778.2,
            69
        ],
        "all pass from s to you. Of the sum of the edge lengths and for all vertices that are unreachable. It will be set to Infinity just like we said before. Okay. So how we going to do this? Well, you're going to see that this is a lot like what we did for the max bandwidth Pat instead of checking to see if the vertex is in X or ": [
            2778.2,
            2805.0,
            70
        ],
        "are special. No, they're not really. FedEx my location update my all of these numbers don't have a common divisor. special moments like about you Oh, but then you just doing. Can you just going to do dijkstra's anyway, right? Okay, so I want to kind of give you a sense of this high-level to low-level thing and it's in this is good for you to to see for your ": [
            2536.3,
            2579.3,
            62
        ],
        "as you all know reading just threw code can be maddening right? If you have to kind of keep track of all the indices and then you know, how many times has the loop go and then you have to go into the other loop. So if you have kind of like a high-level description saying basically what this algorithm is doing it is such and such that gives the ": [
            2660.5,
            2684.9,
            66
        ],
        "ask and then it keeps on going like that and it will just basically as you build that output tree, it sets distance B2B the distance of the parent plus one. Okay, so that is a empty slide forgot why I put that there. Okay, nevermind and the book uses some kind of weird terminology or maybe it's familiar. So for Q they have these words. eject And inject have ": [
            573.5,
            623.5,
            15
        ],
        "at we're going to denote them in a bunch of different ways. You'll see it in different textbooks is basically L of whatever Edge and it might be the weight if it's the weight then sometimes they just say w of whatever Edge I saw something like that. It's just you that you're assigning to each Edge. Okay. So BFS only really works. Well, if you're finding the shortest distance ": [
            2052.5,
            2079.3,
            52
        ],
        "because by induction hypothesis just into you corresponds to a path from s to you. And so then you just get that next to a notice how similar this is. That's just the initialization. Yeah, you start off not knowing anything, right? You start off thinking that everything is far away. And then has you go you kind of update them. Okay, so let's go the other direction. Now we ": [
            1239.9,
            1278.8,
            31
        ],
        "before w. So Wednesday is ejected W is injected with this. distance but that's what we assumed DW was so then we get dissed W is equal to d w, that's the contradiction. K-stew is that DW is actually less than the Z + 1. The only way that that's possible is if there's some other path that goes like that. rank Because we we are assuming that distant Z ": [
            1450.4,
            1491.4,
            37
        ],
        "change. I just wanted you to see what it is every step. Okay, so this will be my cue. case it starts off with a I guess we'll start with a right so everything starts as Infinity now, so the first thing you do is you deeqa right and then you look at all of its neighbors and for each one you check to see if their distance is infinity ": [
            753.3,
            791.6,
            20
        ],
        "chapter 3? Cat follow the book pretty closely for any of those for any of you who have read the book at least for the chapter 3 stuff. So if you do have questions, you can look through the book or come to office hours. Okay, I have another piece of news that is in the works right now. If you do feel like you're kind of falling behind then ": [
            73.4,
            105.8,
            2
        ],
        "do finding sinks and sources. Yeah, basically what we said. What is DFS not good for Good finding shortest paths finding shortest distances between vertices they so that's kind of the topic of chapter 4 is we're going to go into that. Okay, so distance in in graph Theory distance between two vertices distance actually just mean shortest distance and you don't have to have two vertices you can have ": [
            302.4,
            350.0,
            7
        ],
        "exploring any distance to vertex. Right? And so you can kind of think about these vertices entering the Q in the order of their distance from s Okay, just kind of a nice fact here. That might be helpful when you're thinking about how this works for every possible distance at some point. The stack will only hold vertices of that distance. And this kind of gives you a sense ": [
            510.6,
            542.8,
            13
        ],
        "finding shortest paths. Just a graph. What if we add edge weight or Edge lengths queso we have this Map of the United States with I think their flights for JetBlue. Okay, and so each one of these edges is is like a a flight path, right? Now what kind of different Edge weights could you think of labeling these edges with? Okay, so you could do the distance, right? ": [
            1714.8,
            1755.7,
            45
        ],
        "from FX. Okay, so let's say let's stop there. So you guys can maybe read up on chapter 4 you can you can get ahead a little bit and we'll start off with an animation. dijkstra's algorithm I just wanted to bring some. ": [
            2902.3,
            2928.2,
            74
        ],
        "from b u have c and e and d u have f g and H right and then all the other edges that don't make it into the output tree or just kind of like loose, right? FTE now for your favorite part correctness Okay, so we have to do correct this again because BFS I'm claiming it to do something different than what Graph Search does. I'm claiming it ": [
            1004.5,
            1051.8,
            26
        ],
        "going to modify it so that I can do shortest distances, but I still really want. To be able to reach all the vertices that are reachable, right? So I'm going to keep the main structure of graph search. The thing I'm going to change is just in what order do I pick the vertices from f So we seen this before if you if you choose app to be ": [
            379.6,
            410.6,
            9
        ],
        "graph if you are looking at the numbers. I know right but because instead of going directly from B to F you could have gone. Through C. And that would have been a path of length 3 where is going directly from B to F is a path of length 4. So how we going to get around this? I want you guys to get within your groups and discuss. ": [
            2143.4,
            2179.6,
            55
        ],
        "hear Wright 0 1 2 1 2 2 3 Infinity I didn't give myself enough space. There's h. 3/4 and then H gets taken off and you're done. Okay. so all those red All those red lines that I drew. Those are the bets the output tree of BFS valput tree is also the shortest path tree and I think I don't know if it was in the book or ": [
            929.1,
            971.3,
            24
        ],
        "homework for whenever year presenting algorithms and also for me when I'm presenting algorithms to you. The reason that we do it this way. This is kind of the idea guy. So the end goal really what you want is something that you can Implement into a computer you really want like the end goal to be a pseudocode or machine code or something like that. But it's first useful ": [
            2579.3,
            2604.8,
            63
        ],
        "if the distance is infinity then update the distance value and put it into the Q. and update it to be the distance to its parent plus one. Okay, so let's look at this. Look at this inaction. Okay. So these are going to be my distance values. I'm going to keep them in here in this array and I put a bunch of levels because they're just going to ": [
            723.6,
            753.3,
            19
        ],
        "in your algorithm terminates, but there's actually a better path. Boston Maybe yeah. Well, this one's not the most efficient either. And we're going to look at that in a minute. toe reduction means you take the algorithm like BFS and you use it as a subroutine and instead of instead of modifying the algorithm for a to solve the problem you modify the input instead. It's just it's just ": [
            2365.4,
            2425.9,
            58
        ],
        "is actually actual shortest path right? We're assuming that this path. Is the actual shortest path from s to Z. So if we if there if DW is a shorter path and that means you have to kind of circumvent it but that means that new pack with that little huh that's going to be a shorter path to V. So that's a contradiction because we assume that this was ": [
            1491.4,
            1517.0,
            38
        ],
        "is not empty. You eject or dq2 which means take off the the top element and then for all the neighbors you check to see if it's visited. You don't have to check to see if it's in some sort of visited or whatever. All you have to do is just check if it's distance is infinity or not. Cuz if it's Infinity than it hasn't been explored yet. Okay, ": [
            697.8,
            723.6,
            18
        ],
        "it when you get down to like the mid-level or to the low level. Okay, so then we still in those details. We make a low-level or implementation level algorithms from a high level one using data structures in place of those mathematical structures. Okay, why is this useful for one Clarity and I asked that everybody whenever you hand in any algorithm description, please include high-level description with it ": [
            2628.5,
            2660.5,
            65
        ],
        "know that they're both of 0. Right and were claiming that dissed V is greater than TV. So at some point along this path, you have to kind of break that that sequence right? So let's say that Z is the is the last vertex to have that equality and W is the first vertex to have the inequality. Okay, just like the four questions about that. Okay. So let's ": [
            1376.5,
            1414.9,
            35
        ],
        "least to get between two points anybody any others? time good. Probably also want to minimize time anything else. Okay fuel consumption. Maybe you're the airline right and you are worried about fuel consumption? Anybody else? Comfort comfort level okay, I'm going to put this one kind of differently because Comfort level is not really these other ones. These are going to work a lot these going to work well ": [
            1792.8,
            1856.0,
            47
        ],
        "length of some Pat from s2v, actually, I think in my base case I need to do one more thing distance V is infinity is the what would you call that path that empty path? So after Tia durations you always there's always going to be a path that gives you that distant. Okay inductive step. Well during the next iteration. All you're doing is exploring one of the vertices ": [
            1138.6,
            1184.0,
            29
        ],
        "let's divided into two cases on. What is DW? Okay. So DW could be actually DZ plus one. Maybe the shortest path is actually this black line. Maybe that's the short span. If it is then when you been when you discover Z. W will be one of its neighbors and so you'll set it to be dist Z Plus One. Write an algorithm Z is put in the queue ": [
            1414.9,
            1450.4,
            36
        ],
        "looking for. And then once you get your grades back, of course compare them to the solution. Got any questions about that? Okay, so the last class. Basically for the whole time, I guess the last two weeks, but mainly this past week we've been doing DFS. What is DFS good for? Anybody have any comments about DFS? What do we use it for? Do you want to go? What ": [
            168.5,
            218.2,
            5
        ],
        "means that you're using a given algorithm as a subroutine. So in this case, you take your original graph, which is the one on the left and you change it to be this new graph. The one on the right now, I can run BFS without any without any changes without any modifications. I just run regular BFS on this new graph. That kind of makes sense. Okay, so This ": [
            2425.9,
            2461.2,
            59
        ],
        "much done riding the solutions for the homework. So those should be out this evening. So you can look at how your answers compared to the solutions. I highly recommend doing that. Even if you are confident of your answer just because I may have done it in a different way or Ford in a different style and just so that you kind of get a feeling for what we're ": [
            140.9,
            168.5,
            4
        ],
        "of a BFF doesn't restart at other connected components because it doesn't make any sense to it. Really what we want is shortest path from s Then all I really want to know is if it's connected. What's the shortest path if it's disconnected then it's disconnected and that's it. Okay, so let's move on to a different problem. It's very similar, but Let's think about graphs and instead of ": [
            1682.3,
            1714.8,
            44
        ],
        "on grass were each Edge has equal way right doesn't matter what it is, but they all have to be the equal weight because BFS gives you the number of edges. So what happens if we perform DFS BFS on this graph? Let's look. Okay. So I start off as a right So let's just keep track of our cue. So we have a and then we put in the ": [
            2079.3,
            2108.2,
            53
        ],
        "questions can you answer? Okay good. readability Anybody else? Okay, good topological sort. of Dags Okay, buddy else. connectivity So that would be like connected components. Were strongly connected components, right? Maybe even you would put in there like cycles and stuff right finding Cycles. It can also be used as a reduction for Max bandwidth, right? helpful with Max bandwidth Okay, so Those are the ones who did I ": [
            218.2,
            302.4,
            6
        ],
        "queue B & E. Right, so then we look at be so we get C and F. and then we look at eat and we get d You guys can you guys even read those letters? Aunt barely Vine cfd and then we're done right after the and then F and then d Okay, but these have numbers on them you guys can read those is Bisbee actual shortest path ": [
            2108.2,
            2143.4,
            54
        ],
        "reader more kind of foresight into how to how to parse the code. To Clarity correctness proofs are usually a lot easier when we're talking about math objects because proofs are usually like a mathematical type of statement and inflexibility. And this is what we're going to see with dijkstra's algorithm. That's why I'm presenting it now is now we're going to have this high level or mid-level description. Now, ": [
            2684.9,
            2716.8,
            67
        ],
        "reason is because This vertex here. Maybe this is the wrong distance to so then you can't really you can't really anchor it on anyting are anchoring it on the fact that disc Z is actually the shortest path that's part of the Assumption and so I guess you can make this proof and say assume that V is the first time that that switches so that the the vertex ": [
            1565.4,
            1593.0,
            40
        ],
        "right before it has any quality just trying to find that Gap where you go from equality to not equality because that's going to be with the point where you can get your contradiction. Right because honestly what's going to happen at the end is you're going to have equality through all the pads. Yeah, if it messes up there then it messes up everywhere. And I sort of the ": [
            1593.0,
            1621.6,
            41
        ],
        "right here looking at all of its neighbors. When you're signing to all of its neighbors one plus the distance to that vertex and the path is just a path to that protects peso pick. you from f If V is a neighbor of you. then set the distance be Be equal to 1 plus distance you. and that corresponds to the path from s to you to the right ": [
            1184.0,
            1239.9,
            30
        ],
        "same. Idea that we use for all those other proofs that were like this. Don't worry. We'll see another one for dykstra's. little bit more complicated but now it's actually a lot like this one. Okay, so let's think a little bit more about how these things differ DFS uses information about the whole graph write the connectivity the SCC the topological sort. Does the graph have Cycles right? So ": [
            1621.6,
            1657.4,
            42
        ],
        "schedule. But if you look at another way, maybe that means that we're going too fast. So we finished basically all of chapter 3, and I wanted to just kind of Open it up for you guys to ask it questions about it. Just so that I know it's okay to move on to chapter 4 stuff today. So anybody have any questions about the things that we did in ": [
            42.2,
            73.4,
            1
        ],
        "see what different Edge Edge weight do to the graph. Anybody else any other questions or comments? What is it? Oh, yeah, so popularity and then how would that? Would you want to go on a popular flight? Right. Yeah. Yeah. But that might also be a good one for Max bandwidth, right? Yeah, what is that anyway? Yeah, but for what? It's like a biological thing and what are ": [
            1904.2,
            1964.2,
            49
        ],
        "so One Direction is after every iteration distance via the length of Sun path. Okay, so just going to kind of do sort of an abbreviated version of this proof because it's it's basically like all the proofs that we've done already so bass case. Is that distance? Of s is equal to 0 that corresponds to the trivial path. inductive hypothesis assume after t iterations distance V is the ": [
            1080.3,
            1138.6,
            28
        ],
        "that they're going in order. Okay, so let's first search. Why is that still? So given a graph in the starting vertex BFS compute distances from s to every other node. It keeps this information in an array called dist to do this BFS compute distances layer-by-layer kind of what I was saying, it sets distance as to be 0 and the next layer is all the vertices adjacent to ": [
            542.8,
            573.5,
            14
        ],
        "that's going to give us a good run time efficiency. If we just leave it to be picking any value of the willy nilly the algorithm will still work, but it won't be as efficient. Hey so for each neighborhood V each neighbor you of B if the distance of you is set already, but it's bigger than going through V10 reset it. So I have V here. And you ": [
            2840.3,
            2871.8,
            72
        ],
        "the distance from a Vertex to itself is 0 cuz remember there's always a path from a Vertex to itself with with without any edges. Okay, if there's no path between two vertices, then we say that the distance is infinite, right? You can't get there. It's bigger than anything that you could. bigger than any other distance Okay, let's go back to the graph search thing. And now I'm ": [
            350.0,
            379.6,
            8
        ],
        "the shortest So then the path p is actually not the shortest path. We found a short of that which is a contraction. questions is the shortest path in anything but You could get there in a straight shot, picking a straight edge. Are you are you questioning why we have to do what why we have to use z&w instead of just going right to V. Yeah, so the ": [
            1517.0,
            1565.4,
            39
        ],
        "this can't be efficient, especially if you have really really detailed Edge length, like what if your Edge lengths were measuring distance in centimeters from between the different planets? It was just you know, it's really not efficient. There must be a better way, okay? I got any comments on that. The number of inches you could you could / like a like a another value. And then just these ": [
            2490.1,
            2536.3,
            61
        ],
        "this is great because it's easy to do right? It's really easy to implement, but you could run into some problems. Right? What if you're trying to do this graph? This graph originally has 10 edges and then if you do it this way you're going to end up with 1783 new vertices made it starts off with 10 and then you get basically multiply it by. 170 rights of ": [
            2461.2,
            2490.1,
            60
        ],
        "this using reduction? any any ideas Okay good. like this Anybody else? Oh like we did the Mac Band with going to work. She keep on adding the smallest edges. Yeah, but that's still might not work really. Well, right because you could have like what if you had a bunch of ones? and then at 2 I showed you add in all the ones then you found the path ": [
            2263.6,
            2365.4,
            57
        ],
        "those Edge weights? energy Yeah, I just put that up there because it has Edge weights. It's another example of a graph with Edge weights. I don't know what kind of algorithm you would need to do. Any I don't even know what it is. But I know that this is though, this is New England or part of New England part of New York and those numbers there are ": [
            1964.2,
            2003.3,
            50
        ],
        "to Output these distance values correctly. So just like before all these graphs archetype algorithms. We have to do two directions. The first thing I want to do is show that every time I assign a distance value, it's actually it actually corresponds to a path. Okay, and you do that by induction. K2 BFS is done distance B is the length of the shortest path from s to be ": [
            1051.8,
            1080.3,
            27
        ],
        "to be zero because the the shortest path from s to itself is zero. You start the Q. We just asked in it and then you keep on repeating until the queue is empty. Right? What is this Q really? What what place does it what set does it take its place in our original kind of high mid-level Graph Search right to is the F set. So while Q ": [
            667.6,
            697.8,
            17
        ],
        "to come up with a high-level version the high-level version specifies what the algorithm wants to do at every step in terms of abstractions in terms of math objects such as sets relations graphs and so on but not all the details of how it's going to actually accomplish those things. You just going to say that it does those and worry about figuring out how it's going to do ": [
            2604.8,
            2628.5,
            64
        ],
        "up. Okay. So the next one is D width D I get a few set f2b to And you get CEF? And then the next one is nothing happens. The next one is d No, sorry. Next one is e e nothing happens. The next one is f so F you go to G and you said g to be three? That's down here. Sorry. FG I'm losing it here. ": [
            869.8,
            926.5,
            23
        ],
        "want to know does it actually achieve the shortest path. Are there any pads that are better peso after BFS is done distance V is the length of the shortest path from A to B for all vertices. Okay, so just like we did before let's prove this by contradiction by. By supposing that there's this other path out there that shorter than the path that corresponds to Justin's B. ": [
            1278.8,
            1309.8,
            32
        ],
        "was one of its neighbors. And here's ask. so there's a path from S2 to the that's going to be the distance of v and maybe there's a path. From s to you and that'll be the distance from to you. But if going through V is better than going on that red line then update you come the idea. Then when you're done with all the neighbors throw V ": [
            2871.8,
            2902.3,
            73
        ],
        "we will provide one-on-one sessions with the T A's and tutors so that you can ask questions about previous lectures previous homeworks. It's mainly so that during office hours. We can kind of move forward. Whereas on these in these 101 sessions. You can kind of move backward and spend catch up. Okay, so try to get that set up so that we can do that next week. I'm pretty ": [
            105.8,
            140.9,
            3
        ],
        "what? kilometers You know personally I much prefer if they were miles. I think they are. Anybody know how far it is from Philly to New York. I think it's 92 miles. It's all the same thing. You want maybe a shortest path to go distances through cities. Okay, so so I just can and I'll be giving a bunch of different values and then we're going to be looking ": [
            2003.3,
            2052.5,
            51
        ],
        "which they are and then you set their distances to be one plus the distance of a Hey, so we're going to put in B & D. We're going to set B&D to be one and these Allstate Infinity. So then the next thing you do is you pop off bee or not pop, but eject. And you look at its neighbors Saudi or has a has a distance of ": [
            791.6,
            826.6,
            21
        ],
        "with shortest path algorithm Comfort level might not because Did you take like? 10 really uncomfortable flights. Does that add up to a comfortable one? But but what what graph algorithm would work well for Comfort level. Max bandwidth, right cuz you kind of want to find the sequence of flights that has like the the minimum Comfort level that you want. I think so. So good so you can ": [
            1856.0,
            1904.2,
            48
        ],
        "you can modulate what different data structures you can put in weave already kind of sort of seeing this when we talked about Graph Search and we put in a stack and a queue just by putting in different data structures you get different results and you make a different run times. song case study dijkstra's algorithm. I'll give you kind of an idea of how this works with dijkstra's ": [
            2716.8,
            2743.6,
            68
        ],
        "you guys heard that before? No. And cue in DQ. That's just what it is. Eject will be what DQ? an injectable B&Q I don't know just want to put that up there so that when you read it in the book, you know what they're doing. Okay, so let's go through this real fast. You set all of the distances to Infinity then you set the distance of s ": [
            623.5,
            667.6,
            16
        ]
    },
    "File Name": "Design___Analysis_of_Algorithm___A00___Jones__Miles_E___Winter_2019-lecture_6.flac",
    "Full Transcript": "Let's make this song. Let's turn out down the light so we can have a more intimate setting.  Okay, so  I have some good news, and I have some.  Was good news. If you look at it one way and its other kind of news if you look at it another way.  So the good news is that we're going at a good pace and we're kind of ahead of schedule. But if you look at another way, maybe that means that we're going too fast. So we finished basically all of chapter 3, and I wanted to just kind of  Open it up for you guys to ask it questions about it. Just so that I know it's okay to move on to chapter 4 stuff today. So anybody have any questions about the things that we did in chapter 3?  Cat follow the book pretty closely for any of those for any of you who have read the book at least for the chapter 3 stuff. So if you do have questions, you can look through the book or come to office hours. Okay, I have another piece of news that is in the works right now. If you do feel like you're kind of falling behind then we will provide one-on-one sessions with the T A's and tutors so that you can ask questions about previous lectures previous homeworks.  It's mainly so that during office hours. We can kind of move forward. Whereas on these in these 101 sessions. You can kind of move backward and spend catch up. Okay, so try to get that set up so that we can do that next week.  I'm pretty much done riding the solutions for the homework. So those should be out this evening. So you can look at how your answers compared to the solutions. I highly recommend doing that. Even if you are confident of your answer just because I may have done it in a different way or Ford in a different style and just so that you kind of get a feeling for what we're looking for. And then once you get your grades back, of course compare them to the solution.  Got any questions about that?  Okay, so the last class.  Basically for the whole time, I guess the last two weeks, but mainly this past week we've been doing DFS. What is DFS good for?  Anybody have any comments about DFS? What do we use it for?  Do you want to go?  What questions can you answer?  Okay good.  readability  Anybody else?  Okay, good topological sort.  of Dags  Okay, buddy else.  connectivity  So that would be like connected components.  Were strongly connected components, right?  Maybe even you would put in there like cycles and stuff right finding Cycles.  It can also be used as a reduction for Max bandwidth, right?  helpful with Max bandwidth  Okay, so  Those are the ones who did I do finding sinks and sources. Yeah, basically what we said. What is DFS not good for  Good finding shortest paths finding shortest distances between vertices they so that's kind of the topic of chapter 4 is we're going to go into that.  Okay, so distance in in graph Theory distance between two vertices distance actually just mean shortest distance and you don't have to have two vertices you can have the distance from a Vertex to itself is 0 cuz remember there's always a path from a Vertex to itself with with without any edges.  Okay, if there's no path between two vertices, then we say that the distance is infinite, right? You can't get there. It's bigger than anything that you could.  bigger than any other distance  Okay, let's go back to the graph search thing. And now I'm going to modify it so that I can do shortest distances, but I still really want.  To be able to reach all the vertices that are reachable, right? So I'm going to keep the main structure of graph search. The thing I'm going to change is just in what order do I pick the vertices from f  So we seen this before if you if you choose app to be a stack. We saw that earlier this week. Then you're talkin about DFS. What we're going to look at now is if f is a q so the first found is the first explored  right  Isn't that how it is? Yeah.  And then the end then if we have time we might get to F being a priority queue, but that's probably more likely to be next week's lesson.  queso  Let's let's think about the differences between stacks and queues peso.  The queue actually gives you more information in the Stacked us right cuz the Q starts with just the node ass.  It's the only one that has distant 0 right.  What are the next nodes to be put into the Q?  Okay, so the neighbors of s right so all the neighbors of s will have distance one, right? So those all get put into the queue, right?  Then since we're doing the first in first out, all of the nodes of distance one will be explored. And as you explore each one of those you're finding all the distance to vertices and those are going to be going into the end of the queue, right and all the distance one vertices will be explored before you even consider exploring any distance to vertex. Right? And so you can kind of think about these vertices entering the Q in the order of their distance from s  Okay, just kind of a nice fact here. That might be helpful when you're thinking about how this works for every possible distance at some point. The stack will only hold vertices of that distance.  And this kind of gives you a sense that they're going in order.  Okay, so  let's first search.  Why is that still?  So given a graph in the starting vertex BFS compute distances from s to every other node. It keeps this information in an array called dist to do this BFS compute distances layer-by-layer kind of what I was saying, it sets distance as to be 0 and the next layer is all the vertices adjacent to ask and then it keeps on going like that and it will just basically as you build that output tree, it sets distance B2B the distance of the parent plus one.  Okay, so that is a empty slide forgot why I put that there. Okay, nevermind and the book uses some kind of weird terminology or maybe it's familiar. So for Q they have these words.  eject  And inject have you guys heard that before?  No.  And cue in DQ. That's just what it is.  Eject will be what DQ?  an injectable B&Q  I don't know just want to put that up there so that when you read it in the book, you know what they're doing.  Okay, so  let's go through this real fast.  You set all of the distances to Infinity then you set the distance of s to be zero because the the shortest path from s to itself is zero.  You start the Q.  We just asked in it and then you keep on repeating until the queue is empty. Right? What is this Q really? What what place does it what set does it take its place in our original kind of high mid-level Graph Search right to is the F set.  So while Q is not empty.  You eject or dq2 which means take off the the top element and then for all the neighbors you check to see if it's visited. You don't have to check to see if it's in some sort of visited or whatever. All you have to do is just check if it's distance is infinity or not. Cuz if it's Infinity than it hasn't been explored yet.  Okay, if the distance is infinity then update the distance value and put it into the Q.  and update it to be  the distance to its parent plus one.  Okay, so let's look at this. Look at this inaction.  Okay. So these are going to be my distance values. I'm going to keep them in here in this array and I put a bunch of levels because they're just going to change. I just wanted you to see what it is every step. Okay, so this will be my cue.  case it starts off with a  I guess we'll start with a right so  everything starts as Infinity  now, so the first thing you do is you deeqa right and then you look at all of its neighbors and for each one you check to see if their distance is infinity which they are and then you set their distances to be one plus the distance of a  Hey, so we're going to put in B & D.  We're going to set B&D to be one and these Allstate Infinity.  So then the next thing you do is you pop off bee or not pop, but eject.  And you look at its neighbors Saudi or has a has a distance of 1 so you ignore it, but C&E have distance of infinity. So you put those in  And what do you set them to?  to write  so what is your cue look like we'll be has been ejected D moves to the front and then you have c and e like that.  questions about that  You guys probably are I've all seen this already before.  Okay, so let's just finish it up. Okay. So the next one is D width D I get a few set f2b to  And you get CEF?  And then the next one is nothing happens.  The next one is d  No, sorry. Next one is e e nothing happens.  The next one is f  so F you go to G and you said g to be three?  That's down here. Sorry.  FG  I'm losing it here.  hear Wright 0 1 2 1 2 2 3 Infinity  I didn't give myself enough space. There's h.  3/4 and then H gets taken off and you're done.  Okay.  so all those red  All those red lines that I drew. Those are the bets the output tree of BFS valput tree is also the shortest path tree and I think I don't know if it was in the book or I saw it somewhere else but I like this idea of to get the output tree think about all of these vertices as like balls and the edges are our strings, right? So what you can think about is grab a grab your starting for a text and let all the other things hang and what does it look like?  you have a  and you have B&D here.  and then from b u have c and e and d u have f  g  and H right and then all the other edges that don't make it into the output tree or just kind of like loose, right?  FTE  now for your favorite part  correctness  Okay, so we have to do correct this again because BFS I'm claiming it to do something different than what Graph Search does. I'm claiming it to Output these distance values correctly. So just like before all these graphs archetype algorithms. We have to do two directions. The first thing I want to do is show that every time I assign a distance value, it's actually it actually corresponds to a path. Okay, and you do that by induction.  K2 BFS is done distance B is the length of the shortest path from s to be so One Direction is after every iteration distance via the length of Sun path.  Okay, so just going to kind of do sort of an abbreviated version of this proof because it's it's basically like all the proofs that we've done already so bass case.  Is that distance?  Of s is equal to 0 that corresponds to the trivial path.  inductive hypothesis  assume  after  t iterations  distance V  is  the length  of some Pat  from s2v, actually, I think in my base case I need to do one more thing distance V is infinity is the  what would you call that path that empty path?  So after Tia durations you always there's always going to be a path that gives you that distant. Okay inductive step. Well during the next iteration. All you're doing is exploring one of the vertices right here looking at all of its neighbors.  When you're signing to all of its neighbors one plus the distance to that vertex and the path is just a path to that protects peso pick.  you from f  If V is a neighbor of you.  then set  the distance be  Be equal to 1 plus distance you.  and that corresponds  to the path  from s to you to the right because by induction hypothesis just into you corresponds to a path from s to you. And so then you just get that next to a notice how similar this is.  That's just the initialization.  Yeah, you start off not knowing anything, right? You start off thinking that everything is far away. And then has you go you kind of update them.  Okay, so let's go the other direction.  Now we want to know does it actually achieve the shortest path. Are there any pads that are better peso after BFS is done distance V is the length of the shortest path from A to B for all vertices.  Okay, so just like we did before let's prove this by contradiction by.  By supposing that there's this other path out there that shorter than the path that corresponds to Justin's B.  They supposed to Sunriver text that there's a path P from s2v such that the length of P. The length of the path is actually shorter than whatever BFS set the distance to.  Okay, so just like we did before we're going to suppose that this path exists and we're going to find the contradiction.  So let me just introduce another notation. Let's say that D of V.  Is the actual length of the shortest path among all pass from s2v. The actual length. Remember that diss to be  Is the is the value that the algorithm gives it we haven't shown that those are going to be equal yet, right? That's that's kind of what we're trying to prove now.  Okay, so we have this path from s2v. We know that dissed s is equal to DS.  Because we know that they're both of 0.  Right and were claiming that dissed V is greater than TV.  So at some point along this path, you have to kind of break that that sequence right? So let's say that Z is the is the last vertex to have that equality and W is the first vertex to have the inequality.  Okay, just like the four questions about that.  Okay.  So let's let's divided into two cases on. What is DW? Okay. So DW could be actually DZ plus one.  Maybe the shortest path is actually this black line. Maybe that's the short span. If it is then when you been when you discover Z.  W will be one of its neighbors and so you'll set it to be dist Z Plus One.  Write an algorithm Z is put in the queue before w.  So Wednesday is ejected W is injected with this.  distance  but that's what we assumed DW was so then we get dissed W is equal to d w, that's the contradiction.  K-stew is that DW is actually less than the Z + 1.  The only way that that's possible is if there's some other path that goes like that.  rank  Because we we are assuming that distant Z is actually actual shortest path right? We're assuming that this path.  Is the actual shortest path from s to Z. So if we if there if DW is a shorter path and that means you have to kind of circumvent it but that means that new pack with that little huh that's going to be a shorter path to V. So that's a contradiction because we assume that this was the shortest  So then the path p is actually not the shortest path. We found a short of that which is a contraction.  questions  is the shortest path in anything but  You could get there in a straight shot, picking a straight edge.  Are you are you questioning why we have to do what why we have to use z&w instead of just going right to V.  Yeah, so the reason is because  This vertex here. Maybe this is the wrong distance to  so then you can't really you can't really anchor it on anyting are anchoring it on the fact that disc Z is actually the shortest path that's part of the Assumption and so  I guess you can make this proof and say assume that V is the first time that that switches so that the the vertex right before it has any quality just trying to find that Gap where you go from equality to not equality because that's going to be with the point where you can get your contradiction.  Right because honestly what's going to happen at the end is you're going to have equality through all the pads.  Yeah, if it messes up there then it messes up everywhere.  And I sort of the same.  Idea that we use for all those other proofs that were like this.  Don't worry. We'll see another one for dykstra's.  little bit more complicated but  now it's actually a lot like this one.  Okay, so  let's think a little bit more about how these things differ DFS uses information about the whole graph write the connectivity the SCC the topological sort. Does the graph have Cycles right? So  Remember, it keeps on like updating. It keeps on going until you go through all the vertices even if they're not connected. Where is BFS only gives you info information related to a given vertex. So it's very vertex Pacific. Right? Cuz you're getting all the shortest paths from ass. I don't know the shortest path between any other pair of vertices. I only know what they are in terms of a BFF doesn't restart at other connected components because it doesn't make any sense to it. Really what we want is shortest path from s  Then all I really want to know is if it's connected. What's the shortest path if it's disconnected then it's disconnected and that's it.  Okay, so let's move on to a different problem. It's very similar, but  Let's think about graphs and instead of finding shortest paths. Just a graph. What if we add edge weight or Edge lengths queso we have this  Map of the United States with I think their flights for JetBlue. Okay, and so each one of these edges is is like a a flight path, right?  Now what kind of different Edge weights could you think of labeling these edges with?  Okay, so you could do the distance, right?  And that sense you might say Okay. I want to I want to find the sequence of flights that I travel that give me the the shortest distance, right? Anybody have any other  I think so cost.  Good, so maybe instead of instead of trying to minimize distance. You don't care about the distance. You just want it to cost the least and so  What sequence of flights cost the least to get between two points anybody any others?  time  good.  Probably also want to minimize time anything else.  Okay fuel consumption. Maybe you're the airline right and you are worried about fuel consumption?  Anybody else?  Comfort comfort  level  okay, I'm going to put this one kind of differently because  Comfort level is not really these other ones. These are going to work a lot these going to work well with shortest path algorithm Comfort level might not because  Did you take like?  10 really uncomfortable flights. Does that add up to a comfortable one?  But but what what graph algorithm would work well for Comfort level.  Max bandwidth, right cuz you kind of want to find the sequence of flights that has like the the minimum Comfort level that you want. I think so.  So good so you can see what different Edge Edge weight do to the graph.  Anybody else any other questions or comments?  What is it?  Oh, yeah, so popularity and then how would that?  Would you want to go on a popular flight?  Right. Yeah. Yeah.  But that might also be a good one for Max bandwidth, right?  Yeah, what is that anyway?  Yeah, but for what?  It's like a biological thing and what are those Edge weights?  energy  Yeah, I just put that up there because it has Edge weights. It's another example of a graph with Edge weights.  I don't know what kind of algorithm you would need to do. Any I don't even know what it is. But I know that this is though, this is New England or part of New England part of New York and those numbers there are what?  kilometers  You know personally I much prefer if they were miles.  I think they are.  Anybody know how far it is from Philly to New York. I think it's 92 miles.  It's all the same thing. You want maybe a shortest path to go distances through cities.  Okay, so so I just can and I'll be giving a bunch of different values and then we're going to be looking at we're going to denote them in a bunch of different ways. You'll see it in different textbooks is basically L of whatever Edge and it might be the weight if it's the weight then sometimes they just say w of whatever Edge I saw something like that. It's just you that you're assigning to each Edge.  Okay. So BFS only really works. Well, if you're finding the shortest distance on grass were each Edge has equal way right doesn't matter what it is, but they all have to be the equal weight because BFS gives you the number of edges.  So what happens if we perform DFS BFS on this graph? Let's look. Okay. So I start off as a  right  So let's just keep track of our cue. So we have a and then we put in the queue B & E.  Right, so then we look at be so we get C and F.  and then we look at eat and we get d  You guys can you guys even read those letters?  Aunt barely Vine cfd  and then we're done right after the and then F and then d  Okay, but these have numbers on them you guys can read those is Bisbee actual shortest path graph if you are looking at the numbers.  I know right but because instead of going directly from B to F you could have gone.  Through C. And that would have been a path of length 3 where is going directly from B to F is a path of length 4.  So how we going to get around this? I want you guys to get within your groups and discuss. How would you use BFS as a reduction to solve this problem ready? Go?  El Sobrante  Hi, dear, find what?  Now we're going to the next thing we're going to talk about is dijkstra's algorithm, which is a good way to do this. But that is not a reduction is it that's a modification so I kind of want to first thing about it. Is there a way to do this using reduction?  any any ideas  Okay good.  like this  Anybody else?  Oh like we did the Mac Band with going to work.  She keep on adding the smallest edges.  Yeah, but that's still might not work really. Well, right because you could have like  what if you had a bunch of ones?  and then at 2  I showed you add in all the ones then you found the path in your algorithm terminates, but there's actually a better path.  Boston  Maybe yeah.  Well, this one's not the most efficient either.  And we're going to look at that in a minute.  toe reduction means you take the algorithm like BFS and you use it as a subroutine and instead of instead of modifying the algorithm for a  to solve the problem you modify the input instead.  It's just it's just means that you're using a given algorithm as a subroutine.  So in this case, you take your original graph, which is the one on the left and you change it to be this new graph. The one on the right now, I can run BFS without any without any changes without any modifications. I just run regular BFS on this new graph.  That kind of makes sense.  Okay, so  This this is great because it's easy to do right? It's really easy to implement, but you could run into some problems. Right? What if you're trying to do this graph?  This graph originally has 10 edges and then if you do it this way you're going to end up with 1783 new vertices made it starts off with 10 and then you get basically multiply it by.  170 rights of this can't be efficient, especially if you have really really detailed Edge length, like what if your Edge lengths were measuring distance in centimeters from between the different planets?  It was just you know, it's really not efficient. There must be a better way, okay?  I got any comments on that.  The number of inches you could you could / like a like a another value.  And then just these are special. No, they're not really.  FedEx my location  update my all of these numbers don't have a common divisor.  special moments like about you  Oh, but then you just doing.  Can you just going to do dijkstra's anyway, right?  Okay, so  I want to kind of give you a sense of this high-level to low-level thing and it's in this is good for you to to see for your homework for whenever year presenting algorithms and also for me when I'm presenting algorithms to you. The reason that we do it this way. This is kind of the idea guy. So the end goal really what you want is something that you can Implement into a computer you really want like the end goal to be a pseudocode or machine code or something like that.  But it's first useful to come up with a high-level version the high-level version specifies what the algorithm wants to do at every step in terms of abstractions in terms of math objects such as sets relations graphs and so on but not all the details of how it's going to actually accomplish those things. You just going to say that it does those and worry about figuring out how it's going to do it when you get down to like the mid-level or to the low level.  Okay, so then we still in those details. We make a low-level or implementation level algorithms from a high level one using data structures in place of those mathematical structures.  Okay, why is this useful for one Clarity and I asked that everybody whenever you hand in any algorithm description, please include high-level description with it as you all know reading just threw code can be maddening right? If you have to kind of keep track of all the indices and then you know, how many times has the loop go and then you have to go into the other loop. So if you have kind of like a high-level description saying basically what this algorithm is doing it is such and such that gives the reader more kind of foresight into how to how to parse the code.  To Clarity correctness proofs are usually a lot easier when we're talking about math objects because proofs are usually like a mathematical type of statement and inflexibility. And this is what we're going to see with dijkstra's algorithm. That's why I'm presenting it now is now we're going to have this high level or mid-level description. Now, you can modulate what different data structures you can put in weave already kind of sort of seeing this when we talked about Graph Search and we put in a stack and a queue just by putting in different data structures you get different results and you make a different run times.  song  case study dijkstra's algorithm. I'll give you kind of an idea of how this works with dijkstra's algorithm.  Okay. What is dijkstra's algorithm do?  The input is a graph with Edge lengths and a starting vertex. The output is going to be for all the vertices that are reachable. It will give you dissed you.  Will be set to the distance from s to you using those Edge weights basically the shortest path. I guess I should highlight that distance means shortest path.  Break the minimum over all pass from s to you.  Of the sum of the edge lengths and for all vertices that are unreachable. It will be set to Infinity just like we said before.  Okay. So how we going to do this? Well, you're going to see that this is a lot like what we did for the max bandwidth Pat instead of checking to see if the vertex is in X or F you update it with this value depending on its neighbors.  So same same idea. We're going to initialize v&s for all those.  Well, f is not empty. Let's pick some v&f and we're going to see that for now. We'll just pick any V. But we're going to see that the power of dijkstra's algorithm is that we're going to pick the v in a very special way and that's going to give us a good run time efficiency. If we just leave it to be picking any value of the willy nilly the algorithm will still work, but it won't be as efficient.  Hey so for each neighborhood V each neighbor you of B if the distance of you is set already, but it's bigger than going through V10 reset it. So I have V here.  And you was one of its neighbors.  And here's ask.  so  there's a path from S2 to the that's going to be the distance of v and maybe there's a path.  From s to you and that'll be the distance from to you. But if going through V is better than going on that red line then update you come the idea. Then when you're done with all the neighbors throw V from FX.  Okay, so let's say let's stop there. So you guys can maybe read up on chapter 4 you can you can get ahead a little bit and we'll start off with an animation.  dijkstra's algorithm  I just wanted to bring some. "
}