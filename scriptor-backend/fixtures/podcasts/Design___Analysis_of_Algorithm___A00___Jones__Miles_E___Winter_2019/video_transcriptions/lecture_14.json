{
    "Blurbs": {
        "- 1 What do you mean? Yes any questions about that? What if I did this? What happens if R is equal to 1 then? What is the sum equal to? And plus one. Okay, good. You guys should know this closed form. Okay good. So actually thinking about this. in terms of our this thing behave differently for different values of our we've already seen that it would behave ": [
            2564.4,
            2617.9,
            52
        ],
        "And the objective is to minimize. I like to call it the maximum. room number Nice to kind of figure out what you're trying to do. Okay, so now I want to give you guys a few minutes. How would you implement this particular greedy strategy? Okay, ready go. Do you like maybe if you want to look at this or this one maybe is better. Maximum FX pose renewed ": [
            1157.4,
            1215.3,
            23
        ],
        "I'm just going to hold this for a second. actually, you know of a good would be to give a a place to draw it. Did you do? Okay. say okay. Does anybody have a counterexample this one's kind of tricky? Kind of gives you a sense of you know, sometimes they're not so obvious why they're counter-examples. Okay. Well, let's just see the one that I came up with ": [
            483.7,
            579.8,
            7
        ],
        "It's less than or equal to why you actually can't get less than because we prove that that bound was the lowest possible number of rooms. Okay, so in conclusion Yeah, this is kind of basically what we just said. So let's move on to the implementation. Okay event scheduling with multiple rooms. What is the instance while we have an event? He won through en write each with a ": [
            1064.4,
            1104.0,
            21
        ],
        "Okay. Good afternoon, everyone. How's everyone doing? Does anybody have any? Questions or comments before we begin? All right, let's get started then. Alright, so today we're going to Let's get that thing off. We're going to finish up that same example from from the last class and then we'll move on into divide and conquer so this will be like the last day we do greedy stuff. I hope ": [
            6.9,
            94.5,
            0
        ],
        "Right. So * 2 ^ n r ^ n / 2 that's not an actual multiplication that we need the algorithm for right? Cuz you're just shifting. Okay good. So we get this recursion. these guys karatsuba and comedor of they were able to reduce the number of multiplications needed and they traded it for some additions and subtractions. So, let's see what that looks like. So it's the same ": [
            2184.2,
            2219.5,
            42
        ],
        "What you've done a to the K many subproblems each of size n over B to the k? And you're going to have to have combined them together in end to the D time but you're only combining little sub problems. So it's only going to take and Overby to the Kate to the Andover be to the K2 the D time. Okay, so that's why you get this whole ": [
            2830.0,
            2857.3,
            60
        ],
        "XL / x l y l x r y r and then you guys can verify this as an exercise and then you show that it's equal to that which is equal to XY right? So it's just kind of algebra and that's the end of that proof. So these proofs are usually pretty easy to do. Yeah, but this one in particular you can just pad the the the ": [
            2433.4,
            2473.3,
            49
        ],
        "a constant time check splitting up these bits of binary strings we can think about that is running in like a linear time thing at worst frames. Just kind of feel in these new strings and then this addition here while we're going to assume that Edition takes linear time on itself. So this will be a linear time addition. Southern or Crystal part is Big O of n yes. ": [
            2145.4,
            2176.7,
            41
        ],
        "achieves the bound technique proved strategy and we kind of looked at it already, but let's go over it again. and what I wanted to do was you guys probably all remember. how to do it but what I wanted to do is maybe think about it cuz I talked to the last class. I mean the the 4 class. And wait, how do I do this? Okay, and they ": [
            159.1,
            197.1,
            3
        ],
        "algorithm might look something like this. Okay, this is going to be kind of a you know. the main way that you build a divide-and-conquer algorithm you give it a name so x x y where X Y X + Y R N B and B are integers and the output is the product XY you have your base case. And then you split it up. Split it up. and ": [
            2055.8,
            2093.5,
            39
        ],
        "all you're left with is end-to-end to the D. If a is equal to B to the D, then you have A over B to the D is equal to 1. And so that some is linear in in with respect to the upper bound of the summation. Basically, you're just Adding One log by event many times. So that's why you get this one. and then finally He is ": [
            2924.0,
            2954.3,
            63
        ],
        "an algorithm running in this amount of time. FRS equal to 1 + 10 + 1 + we get linear time. And if R is greater than 1 then this is just an exponential function and our this sum is actually big of art to the end. Okay, so we get this nice. kind of three different scenarios based on what the value of R is here. These are the ": [
            2643.0,
            2680.7,
            54
        ],
        "as you go down these levels the number of operations you need increases so we call this a bottom-heavy algorithm because most of the work is done at the at the bottom level and then it kind of goes up. Okay, when we do it in two three now, you can see instead of 2 and 4. I'm getting 1.5 + 1.5 squared so it's still bottom-heavy, but it's not ": [
            2775.2,
            2804.8,
            58
        ],
        "before we have a two to the end times xly I'll move it to the end over two times the sum and we have an x r y r I'm so naively if you wanted to do this problem you could recurse. recurse on x l y l x l y r x r y l and X are y are right and do for workers of calls? And your ": [
            2020.6,
            2055.8,
            38
        ],
        "bit strings with zeros until you reach a power of two if you like and then it and then I'll always be able to divide. Okay, so now we got a better. runtime Okay, so let's run through a how to solve these using the master theorem. queso most divide and conquer algorithms will give you a recursion that looks like this. So we're going to figure out how to ": [
            2473.3,
            2509.4,
            50
        ],
        "book? events two rooms in such a way as to minimize the number of rooms Okay, so I have this one doesn't work. Okay, so this is a candidate. greedy strategy One, okay. So what is it going to do is? used the event scheduling algorithm from before right the one where you pick the earliest end time use event scheduling algorithm to fill room one right with events then. ": [
            222.6,
            280.1,
            5
        ],
        "came up with something that I have a funny feeling is a not not always optimal but I was trying to figure out a counterexample. So maybe you guys this would be a good exercise for you to try to come up with it. Okay. So here's the problem. You have a conference room to plan with an events and you have an unlimited supply of rooms you want to ": [
            197.1,
            222.6,
            4
        ],
        "conquer. Okay, so let's just give like a 3 the three steps of divide and conquer break the problem up into simpler subproblems. Saudi subproblem recursively and then combine. Okay. So we're going to start off with multiplication. I know that in 21 we did this also, so those of you taking 21 this might be kind of a review but we're going to we're going to take it a ": [
            1790.2,
            1820.7,
            31
        ],
        "differently if R is equal to one or if R is not equal to 1 but it also as n goes to Infinity this thing behaves differently if R is less than 1 in ours greater than one. Okay. So far is less than 1 then this thing is actually constant right? It's it's it conversions. So it has an upper bound. So it's constant time if you think about ": [
            2617.9,
            2643.0,
            53
        ],
        "every single pair of numbers right like this and it's going to get messy. But you have to do every single possible multiplication. Then you have to do a bunch of petitions. Okay, so what would it look like to do this divide and conquer? So the idea here is to split up X and Y which would be are binary numbers and split them up until like the left ": [
            1930.3,
            1956.6,
            35
        ],
        "few steps farther. We might not get to it exactly today, but We can kind of start. Getting more and more efficient algorithms by taking it step a few steps farther. Okay, so here's the idea when you multiply binomials. It requires for multiplications, right? a x + b x c x + D you need to multiply a c a d e b c and b d But what ": [
            1820.7,
            1861.6,
            32
        ],
        "for kids Is anybody have any? High-level description of how to implement where I guess it would be like a mid-level implementation level description on how to do this. wait But different than what we had. I'm not sure. Find a new route with number we find start the first floor on the Avengers by their end. Karthik you wake up at night and then we bring whenever we can ": [
            1215.3,
            1497.4,
            24
        ],
        "from 16 to 18. I just put it up here I guess. Okay, so let's talk about why this would be a counterexample. So the you use the algorithm which says pick the one that has the earliest end time and kind of fill up room one with those. Okay. So, let's see which ones we pick we're going to pick this one for room one, right? Then what's the ": [
            644.2,
            673.9,
            9
        ],
        "get an event start time is earlier than our current and time that we know. otherwise Okay, but then how do you know which room to assign it to? I'm not coming up there. of the room count and you only when do you increment the number of rooms? Okay. Okay, but you're going to kind of start assigning rooms that you might not need to write. I guess. So ": [
            1497.4,
            1579.1,
            25
        ],
        "greater than b to the D. Then you have A over B to the D is greater than 1 and you have that this summation kind of acts like an exponential and that's why you get this and you guys can use a exercise maybe to show that why those people so that's where all of these things come from. You got the top-heavy the steady-state and the bottom-heavy so ": [
            2954.3,
            2982.8,
            64
        ],
        "growing as much and so you're going to get a better run time. Song I know we just have a few minutes left. So I'm going to kind of go through this kind of quickly since I know you've seen it before but I want you to see it again. We have a good understanding. Okay, so during the case level of that of that tree. What have you done? ": [
            2804.8,
            2830.0,
            59
        ],
        "half of digits in the right half of digits. Okay. Now we have we're basically dividing it into sub problems and we're going to use our algorithm to solve those so problems. Okay, here's kind of the key Insight is that to do this one of your One of your sub problems XR is just that binary number but XL is going to be that binary number with a bunch ": [
            1956.6,
            1986.5,
            36
        ],
        "hypothesis for some and greater than 1 assume that your algorithm works. Whenever X has K digits and why has K digits for nek in between one enhance the so one of them is one really. Okay. So then by the inductive hypothesis those R1 R2 and R3 are they actual correct products of those binary strings? Picture now. The only thing we have to do is show that combining ": [
            2362.6,
            2405.7,
            47
        ],
        "it's got to be equal to the bound l. Okay, so this is sort of The main strategy is to show that there's a bound and then show that the greedy solution achieves that bound and then you're done. Because if it's less than 1 is live is less than it at some point. Then then you take the max overall points. It's got to be less than the max. ": [
            1021.9,
            1061.4,
            20
        ],
        "last year. Okay. So let's say you have one event that goes from 3 to 7. Okay, and let's say another event goes from 7 to 11. Guy and another event that goes from 5 to 10. Play another event that goes from 10 to 14. Add another event that goes from 11 to 13. And another event that goes from 13 to 19. And then our last event goes ": [
            579.8,
            644.2,
            8
        ],
        "log base B event. So then what is this summation look like it's basically a geometric Series, right? So it's behavior is dependent on how are relates to be to the D. Does the same thing like we did before if a is less than b to the D? That means that A over B to the D is less than 1. So, you know that that sum converges and ": [
            2891.7,
            2924.0,
            62
        ],
        "maybe today or tomorrow so you have some more Practice and then I'll post the solutions and I push the solutions to the homework and the practice problems. Maybe all on Monday will be good to look over so you kind of know the the idea that any questions about that All right. So so this last example is the way we're going to prove it is to use the ": [
            124.9,
            159.1,
            2
        ],
        "move on. So what is the algorithm that we're going to use is you just kind of order the events by when they start? I keep on putting an event into the minimum number available room where the rooms are numbered 1 through infinity or whatever. Okay, so we saw this picture before and it would give you four rooms. Now. The reason that 4 is the lowest number of ": [
            815.0,
            847.8,
            13
        ],
        "need at least be of tea rooms. So in total you need at least be of tea rooms for all-time. Therefore we get that L being the maximum over all of these sizes of sex has got to be the lower Bound for all solutions. Okay. Now let's talk about how the greedy solution actually achieved this bound. So let's say that K is the number of rooms given by ": [
            904.9,
            931.7,
            16
        ],
        "next one we pick is this one, right? the room one and then the next one we pick is this one for room one, right? And then the next one we pick would be this one for room one. That kind of makes sense. Okay, so then you put all those in room one and then how about room to You picked this one for Room 2. Then you pick ": [
            673.9,
            709.3,
            10
        ],
        "of all events that are happening at time T. Right then if R is the number of rooms at an arbitrary valid schedule you need the number of rooms have to be bigger than or equal to be of tea for all tea because you need to be able to to fit all the events in at all times. Okay, and the poop idea is my friendy time to you ": [
            876.5,
            904.9,
            15
        ],
        "of zeros on it right with an over two zeros added to it. So really mathematically this is The same thing as putting your number into two halves. Okay, so let's go back to what it takes to multiply binomials together. But I'm going to instead look at these two binomials. Okay. So let's multiply these two binomials together and you'll see that it's a lot like what we had ": [
            1986.5,
            2020.6,
            37
        ],
        "reducing it by a constant, but because that is your reducing it at every single recursive call, you're going to save a lot of time. Okay. So multiplying let's just talk about it as multiplying binary numbers you can do at the grade school way. And if you like you can you can convince yourself that this is going to take Big O of N squared time. Basically, you're multiplying ": [
            1898.5,
            1930.3,
            34
        ],
        "room one and then you put that one into room two and it'll be fine. Okay, any questions pretty tricky, huh? I don't know. Maybe that'll be some challenge exercise. I mean, I think you're going to have to have at least like at least a problem that has two rooms. where that where are the minimum number of rooms has to yeah, you can maybe find one. Okay, let's ": [
            758.2,
            815.0,
            12
        ],
        "rooms it's the bound right and that's because that at this time at time T. You need at least four rooms. And so you can kind of mathematically go through it, but this is just the the main idea. So we're just going to kind of let me just go back through this stuff. I think we kind of talked about it already, but What's a BMT is the set ": [
            847.8,
            876.5,
            14
        ],
        "size and over to write and In order to combine those all back up to the original problem. You have to do it four times, right? So you basically add to x c x and many operations. Can't bend as you go down. Now. You have 16 problems all size and over for right? So now you're adding a 4 x c x in K and as you can see ": [
            2738.6,
            2775.2,
            57
        ],
        "solve it for everything. I know that most of you guys have seen this before I wanted to go into it in a little bit more detail so that you have an understanding of why the master theorem is what it is. let's start off with the Geometric series does anybody know what the closed form of this thing is? R to the n + 1 - 1 / r ": [
            2509.4,
            2564.4,
            51
        ],
        "start time less AEI is equal to a start. I and a finish I and the solution format is an assignment. of each event to a room maybe you can think about this as like ordered pairs where like maybe event one goes into room through not event want but maybe event 5 goes into room 3 Okay, the constraints are that no two events in the same. room overlap ": [
            1104.0,
            1155.9,
            22
        ],
        "that I've given you enough examples. There's some more examples that you can get from the notes from discussion. Right and then I'll be posting some more problem somewhere greedy algorithm problems that you can practice on. That won't be for turning in that would just kind of be like a practice quiz type problem. So I'll post those maybe today I guess the quiz is in a week, so ": [
            94.5,
            124.9,
            1
        ],
        "the greedy solution. Then I claim at some point K is going to be less than or equal to be of tea. In fact, it's going to be exactly equal to Beauty. Had some tea. Okay, so the idea here is Let's figure out. When did I first need to use that room K. When did I first need to use that last room with the only reason I needed ": [
            931.7,
            961.4,
            17
        ],
        "the latest finish time in that room to the most recent finish time in that room. Okay. So room has value Frank finished Of that room, right which is the the finish time of the set of events scheduled for that room up to that point. Okay. Okay, so then search through. rooms for each event until you find an available available Okay, that'll work. How long is that going ": [
            1619.0,
            1689.3,
            27
        ],
        "them. Right and then you keep a priority queue of available rooms ordered by or their key would be there room number A Min Heap. So then you go through the start times when an event starts. You assign it to the smallest possible room in the priority queue and then delete that room from the from the Q until that event ends and then put it back in and ": [
            1732.2,
            1760.4,
            29
        ],
        "then repeat with remaining events Crank seems pretty good. Right but it doesn't work all the time. So I want you guys to think about can you come up with a counterexample for this? Algorithm ready? Go? Play make sure my my thinking is correct on this to my outline counterexample. How many 3/4? Okay, so you pick this one? 9 Call Comcast. Are you found it? Cool. Thank you. ": [
            282.3,
            483.7,
            6
        ],
        "then return XY you can make a table of the possibilities. There's only for right when you multiply 0 * 008 * 1 * 2/1 * 1 so then that's all. Inductive hypothesis. We're going to have to do a strong inductive hypothesis. because sub problem size is less than and -1 goes all the way down to end mine then over to. Okay. So this is the strong induction ": [
            2320.7,
            2362.6,
            46
        ],
        "then you do your recursive calls Anza problems now, what is the runtime of this? Well, it basically just gives you a Tea event right gives you a recursion you have for recursive calls, each of size and / 2. right And then how long does it take to do the non recursive part? Well, what is the non recursive part? It's basically doing the base case, which is just ": [
            2093.5,
            2145.4,
            40
        ],
        "then you have a square different problem teacher size and over B squared and so on down to the lower case where you have size one. That's when you can put in the base case. Okay, so What the original multiplication algorithm that we saw where we divided into four. This would be kind of what it looks like, right? so you be split up into four problems each of ": [
            2710.8,
            2738.6,
            56
        ],
        "then you just kind of have this sort of priority queue that you keep on popping things and pulling things in and I guess want the priority queue is empty. Then you you put it you put the next number room in there. any questions Okay, let's see. Let's kind of This is going to be the end of greedy strategies and we're going to start talking about divide and ": [
            1760.4,
            1790.2,
            30
        ],
        "thing here. and you guys can do this as an exercise to show that these are equivalent. So basically what we're saying is that this is how long it takes for each level based on K there are and there are log base B of and many levels so you add them all up and you get this summation. Frank from K down to zero all the way up to ": [
            2857.3,
            2891.7,
            61
        ],
        "this one for Room 2. Okay, and then you pick front one from room 3. Okay, so why is this a counterexample? You could have just tell me if it's good. It was Bon one then. two and then right what students at Walmart? You could do use it you could do two rooms, right? Basically you swap these to write. Or you you put the the bottom one into ": [
            709.3,
            758.2,
            11
        ],
        "those things together gives you the product of the original. input Okay, so let's just do that. It's just some algebra. This is what the algorithm returns so start with that what it how does it combine them and show that the combination actually gives you what you want. Right? Well, we get our 1 to the end this whole thing to the end over to and R2. We got ": [
            2405.7,
            2433.4,
            48
        ],
        "three scenarios. That's what gives you the three cases in the master theorem. Okay, so let's kind of break it down into these cases. Okay, so think about a divide-and-conquer problem you split up the original problem and this case I'm splitting it up into four, but you can just think about it as you're splitting it up into a different problems each of size and over be right. And ": [
            2680.7,
            2710.8,
            55
        ],
        "to take? I've been searching through those rooms may take up to n time, right? So be like + sqrt, right? Okay good. Any other ideas? Anybody think about using a priority queue for the rooms? Something like this maybe. Do you sort it for you sorted the the the start time and the end times we have two sorted lists, so you can kind of go through both of ": [
            1689.3,
            1732.2,
            28
        ],
        "to use it was because it was the minimum number of available room, which means that there were events going on in all the rooms 1 through K - 1 so that means that what they're worth Kay events going on, right? And so the size of be of tea at that moment was equal to K. So you had to have that many rooms. Get me the time to ": [
            961.4,
            986.6,
            18
        ],
        "type of algorithm. We're going to call X KS. And instead of those for multiplications they have two of the same ones. And then they add them together first and then recursively call on their son. And so we have our one is the same as before. Our two is the same as before and then are 3 - ardoin - R2 that turns out to be that middle term ": [
            2219.5,
            2256.4,
            43
        ],
        "we can do. Is if we assume that Edition is cheap, which we know is efficient, which it is. It has a short run time. Then we can improve this by only doing three multiplications. So this is the karatsuba. approach Okay, so that's what we're going to talk about today for the remainder of the class. Basically. It may not seem like it's very impressive. It's just kind of ": [
            1861.6,
            1898.5,
            33
        ],
        "would divide and conquer usually have to do a strong induction because you're usually dividing it into two or dividing it into for something like that. Okay, so I just want to go through this because when you guys do your proofs I want them to be this type of induction. So base case is usually just the base case of the algorithm. So when n is equal to 1 ": [
            2295.5,
            2320.7,
            45
        ],
        "you don't have to prove this every time just wanted to give you a sense of why it works. Okay. So now we can just use it without proof in your homework in the quiz, whatever you like. Okay. Have a nice weekend everyone. ": [
            2982.8,
            2996.5,
            65
        ],
        "you guys can See that this is true if you want like as an exercise. Exercise is to check. Okay. So let's just go through the correctness of this algorithm really fast these divide and conquer algorithms. The correctness proofs are usually just a very simple induction. You just basically say I have faith the algorithm will work on a certain size show that it works on the next size ": [
            2256.4,
            2295.5,
            44
        ],
        "you're going to put the first one into I guess I guess I don't know exactly how you would do it without kind of giving the rooms names, right? Which room are you going to put it in? Because you're going to have to reuse rooms right in order to get the optimal strategy. So how do you know which rooms are which Okay. Okay. But really what according to ": [
            1579.1,
            1619.0,
            26
        ],
        "you. They were K events going on at the same time there for at that point K is greater than is less than or equal to be of tea or actually more specifically K is equal to 50. so if it's if it's equal to be a t at some point, then that means it's got to be. Less than or equal to the max overall the bmt's and therefore ": [
            986.6,
            1021.9,
            19
        ]
    },
    "File Name": "Design___Analysis_of_Algorithm___A00___Jones__Miles_E___Winter_2019-lecture_14.flac",
    "Full Transcript": "Okay. Good afternoon, everyone.  How's everyone doing?  Does anybody have any?  Questions or comments before we begin?  All right, let's get started then.  Alright, so today we're going to  Let's get that thing off.  We're going to finish up that same example from from the last class and then we'll move on into divide and conquer so this will be like the last day we do greedy stuff. I hope that I've given you enough examples.  There's some more examples that you can get from the notes from discussion. Right and then I'll be posting some more problem somewhere greedy algorithm problems that you can practice on. That won't be for turning in that would just kind of be like a practice quiz type problem. So I'll post those maybe today I guess the quiz is in a week, so maybe today or tomorrow so you have some more  Practice and then I'll post the solutions and I push the solutions to the homework and the practice problems. Maybe all on Monday will be good to look over so you kind of know the  the idea that any questions about that  All right. So so this last example is  the way we're going to prove it is to use the achieves the bound technique proved strategy and we kind of looked at it already, but let's go over it again.  and what I wanted to do was  you guys probably all remember.  how to do it  but what I wanted to do is maybe think about it cuz I talked to the last class. I mean the the 4 class.  And wait, how do I do this?  Okay, and they came up with something that  I have a funny feeling is a not not always optimal but I was trying to figure out a counterexample. So maybe you guys this would be a good exercise for you to try to come up with it. Okay. So here's the problem.  You have a conference room to plan with an events and you have an unlimited supply of rooms you want to book?  events two rooms in such a way as to minimize the number of rooms Okay, so  I have this one doesn't work.  Okay, so this is a candidate.  greedy strategy  One, okay. So what is it going to do is?  used the event  scheduling  algorithm  from before right the one where you pick the earliest end time use event scheduling algorithm to fill room one right with events then.  then repeat  with remaining events  Crank seems pretty good. Right but it doesn't work all the time. So I want you guys to think about can you come up with a counterexample for this? Algorithm ready? Go?  Play make sure my my thinking is correct on this to my outline counterexample.  How many 3/4?  Okay, so you pick this one?  9  Call Comcast.  Are you found it?  Cool. Thank you. I'm just going to hold this for a second.  actually, you know of a good would be to  give a a place to draw it.  Did you do?  Okay.  say  okay. Does anybody have a counterexample this one's kind of tricky?  Kind of gives you a sense of you know, sometimes they're not so obvious why they're counter-examples.  Okay. Well, let's just see the one that I came up with last year.  Okay. So let's say you have one event that goes from 3 to 7.  Okay, and let's say another event goes from 7 to 11.  Guy and another event that goes from 5 to 10.  Play another event that goes from 10 to 14.  Add another event that goes from 11 to 13.  And another event that goes from 13 to 19.  And then our last event goes from 16 to 18.  I just put it up here I guess.  Okay, so let's talk about why this would be a counterexample.  So the you use the algorithm which says pick the one that has the earliest end time and kind of fill up room one with those. Okay. So, let's see which ones we pick we're going to pick this one for room one, right?  Then what's the next one we pick is this one, right?  the room one  and then the next one we pick is  this one for room one, right?  And then the next one we pick would be this one for room one.  That kind of makes sense.  Okay, so then you put all those in room one and then how about room to  You picked this one for Room 2.  Then you pick this one for Room 2.  Okay, and then you pick front one from room 3.  Okay, so why is this a counterexample?  You could have just tell me if it's good.  It was Bon one then.  two and then right  what students at Walmart?  You could do use it you could do two rooms, right? Basically you swap these to write.  Or you you put the the bottom one into room one and then you put that one into room two and it'll be fine.  Okay, any questions pretty tricky, huh?  I don't know.  Maybe that'll be some challenge exercise.  I mean, I think you're going to have to have at least like at least  a problem that has two rooms.  where that where are the minimum number of rooms has to  yeah, you can maybe find one.  Okay, let's move on. So what is the algorithm that we're going to use is you just kind of order the events by when they start?  I keep on putting an event into the minimum number available room where the rooms are numbered 1 through infinity or whatever.  Okay, so we saw this picture before and it would give you four rooms. Now. The reason that 4 is the lowest number of rooms it's the bound right and that's because that at this time at time T. You need at least four rooms.  And so you can kind of mathematically go through it, but this is just the the main idea. So we're just going to kind of let me just go back through this stuff. I think we kind of talked about it already, but  What's a BMT is the set of all events that are happening at time T. Right then if R is the number of rooms at an arbitrary valid schedule you need the number of rooms have to be bigger than or equal to be of tea for all tea because you need to be able to to fit all the events in at all times. Okay, and the poop idea is my friendy time to you need at least be of tea rooms. So in total you need at least be of tea rooms for all-time. Therefore we get that L being the maximum over all of these sizes of sex has got to be the lower Bound for all solutions.  Okay. Now let's talk about how the greedy solution actually achieved this bound. So let's say that K is the number of rooms given by the greedy solution. Then I claim at some point K is going to be less than or equal to be of tea. In fact, it's going to be exactly equal to Beauty.  Had some tea.  Okay, so the idea here is  Let's figure out. When did I first need to use that room K. When did I first need to use that last room with the only reason I needed to use it was because it was the minimum number of available room, which means that there were events going on in all the rooms 1 through K - 1 so that means that what they're worth Kay events going on, right? And so the size of be of tea at that moment was equal to K. So you had to have that many rooms.  Get me the time to you. They were K events going on at the same time there for at that point K is greater than is less than or equal to be of tea or actually more specifically K is equal to 50.  so  if it's if it's equal to be a t at some point, then that means it's got to be.  Less than or equal to the max overall the bmt's and therefore it's got to be equal to the bound l.  Okay, so this is sort of  The main strategy is to show that there's a bound and then show that the greedy solution achieves that bound and then you're done.  Because if it's less than 1 is live is less than it at some point. Then then you take the max overall points. It's got to be less than the max.  It's less than or equal to why you actually can't get less than because we prove that that bound was the lowest possible number of rooms.  Okay, so in conclusion  Yeah, this is kind of basically what we just said.  So let's move on to the implementation. Okay event scheduling with multiple rooms. What is the instance while we have an event?  He won through en write each with a start time less AEI is equal to a start. I and a finish I  and the solution format is an assignment.  of each  event to a room  maybe you can think about this as like ordered pairs where like maybe event one goes into room through not event want but maybe event 5 goes into room 3  Okay, the constraints are that no two events in the same.  room overlap  And the objective is to minimize.  I like to call it the maximum.  room number  Nice to kind of figure out what you're trying to do.  Okay, so now I want to give you guys a few minutes.  How would you implement this particular greedy strategy? Okay, ready go.  Do you like maybe if you want to look at this or this one maybe is better.  Maximum FX pose renewed for kids  Is anybody have any?  High-level description of how to implement where I guess it would be like a mid-level implementation level description on how to do this.  wait  But different than what we had.  I'm not sure.  Find a new route with number we find start the first floor on the Avengers by their end.  Karthik you wake up at night and then we bring  whenever we can get an event start time is earlier than our current and time that we know.  otherwise  Okay, but then how do you know which room to assign it to?  I'm not coming up there.  of the room count  and you only when do you increment the number of rooms?  Okay.  Okay, but you're going to kind of start assigning rooms that you might not need to write.  I guess.  So you're going to put the first one into I guess I guess I don't know exactly how you would do it without kind of giving the rooms names, right? Which room are you going to put it in? Because you're going to have to reuse rooms right in order to get the optimal strategy. So how do you know which rooms are which  Okay.  Okay.  But really what according to the latest finish time in that room to the most recent finish time in that room. Okay. So room  has value Frank finished  Of that room, right which is the the finish time of the set of events scheduled for that room up to that point. Okay.  Okay, so then search through.  rooms  for each event  until you find  an available available  Okay, that'll work. How long is that going to take?  I've been searching through those rooms may take up to n time, right? So be like + sqrt, right?  Okay good.  Any other ideas?  Anybody think about using a priority queue for the rooms?  Something like this maybe.  Do you sort it for you sorted the the the start time and the end times we have two sorted lists, so you can kind of go through both of them. Right and then you keep a priority queue of available rooms ordered by or their key would be there room number A Min Heap.  So then you go through the start times when an event starts.  You assign it to the smallest possible room in the priority queue and then delete that room from the from the Q until that event ends and then put it back in and then you just kind of have this sort of priority queue that you keep on popping things and pulling things in and I guess want the priority queue is empty. Then you you put it you put the next number room in there.  any questions  Okay, let's see. Let's kind of  This is going to be the end of greedy strategies and we're going to start talking about divide and conquer. Okay, so let's just give like a  3  the three steps of divide and conquer break the problem up into simpler subproblems.  Saudi subproblem recursively and then combine. Okay. So we're going to start off with multiplication. I know that in 21 we did this also, so those of you taking 21 this might be kind of a review but we're going to we're going to take it a few steps farther. We might not get to it exactly today, but  We can kind of start.  Getting more and more efficient algorithms by taking it step a few steps farther.  Okay, so here's the idea when you multiply binomials.  It requires for multiplications, right?  a x + b x c x + D you need to multiply  a c a d e b c and b d  But what we can do.  Is if we assume that Edition is cheap, which we know is efficient, which it is. It has a short run time. Then we can improve this by only doing three multiplications. So this is the karatsuba.  approach  Okay, so that's what we're going to talk about today for the remainder of the class. Basically. It may not seem like it's very impressive. It's just kind of reducing it by a constant, but because that is your reducing it at every single recursive call, you're going to save a lot of time.  Okay.  So multiplying let's just talk about it as multiplying binary numbers you can do at the grade school way. And if you like you can you can convince yourself that this is going to take Big O of N squared time.  Basically, you're multiplying every single pair of numbers right like this and it's going to get messy. But you have to do every single possible multiplication. Then you have to do a bunch of petitions.  Okay, so what would it look like to do this divide and conquer?  So the idea here is to split up X and Y which would be are binary numbers and split them up until like the left half of digits in the right half of digits.  Okay. Now we have we're basically dividing it into sub problems and we're going to use our algorithm to solve those so problems.  Okay, here's kind of the key Insight is that to do this one of your  One of your sub problems XR is just that binary number but XL is going to be that binary number with a bunch of zeros on it right with an over two zeros added to it. So really mathematically this is  The same thing as putting your number into two halves.  Okay, so let's go back to what it takes to multiply binomials together. But I'm going to instead look at these two binomials. Okay. So let's multiply these two binomials together and you'll see that it's a lot like what we had before we have a two to the end times xly I'll move it to the end over two times the sum and we have an x r y r  I'm so naively if you wanted to do this problem you could recurse.  recurse  on x l y l x l y r  x r y l and X are y are right and do for workers of calls?  And your algorithm might look something like this.  Okay, this is going to be kind of a you know.  the main way that you build a divide-and-conquer algorithm you give it a name so x x y  where X Y X + Y R N B and B are integers and the output is the product XY you have your base case.  And then you split it up.  Split it up.  and then you do your  recursive calls  Anza problems  now, what is the runtime of this? Well, it basically just gives you a  Tea event right gives you a recursion you have for recursive calls, each of size and / 2.  right  And then how long does it take to do the non recursive part?  Well, what is the non recursive part? It's basically doing the base case, which is just a constant time check splitting up these bits of binary strings we can think about that is running in like a linear time thing at worst frames. Just kind of feel in these new strings and then this addition here while we're going to assume that Edition takes linear time on itself. So this will be a linear time addition.  Southern or Crystal part is Big O of n  yes.  Right. So * 2 ^ n r ^ n / 2 that's not an actual multiplication that we need the algorithm for right? Cuz you're just shifting.  Okay good. So we get this recursion.  these guys karatsuba and comedor of they were able to  reduce the number of multiplications needed and they traded it for some additions and subtractions. So, let's see what that looks like. So it's the same type of algorithm. We're going to call X KS.  And instead of those for multiplications they have two of the same ones.  And then they add them together first and then recursively call on their son.  And so we have our one is the same as before. Our two is the same as before and then are 3 - ardoin - R2 that turns out to be that middle term you guys can  See that this is true if you want like as an exercise.  Exercise is to check.  Okay. So let's just go through the correctness of this algorithm really fast these divide and conquer algorithms. The correctness proofs are usually just a very simple induction. You just basically say I have faith the algorithm will work on a certain size show that it works on the next size would divide and conquer usually have to do a strong induction because you're usually dividing it into two or dividing it into for something like that.  Okay, so I just want to go through this because when you guys do your proofs I want them to be this type of induction. So base case is usually just the base case of the algorithm. So when n is equal to 1 then return XY you can make a table of the possibilities. There's only for right when you multiply 0 * 008 * 1 * 2/1 * 1 so then that's all.  Inductive hypothesis. We're going to have to do a strong inductive hypothesis.  because  sub problem  size  is less than  and -1 goes all the way down to end mine then over to.  Okay. So this is the strong induction hypothesis for some and greater than 1  assume that your algorithm works.  Whenever X has K digits and why has K digits for nek in between one enhance the so one of them is one really.  Okay.  So then by the inductive hypothesis those R1 R2 and R3 are they actual correct products of those binary strings?  Picture now. The only thing we have to do is show that combining those things together gives you the product of the original.  input  Okay, so let's just do that. It's just some algebra.  This is what the algorithm returns so start with that what it how does it combine them and show that the combination actually gives you what you want. Right? Well, we get our 1 to the end this whole thing to the end over to and R2. We got XL / x l y l x r y r and then  you guys can  verify this  as an exercise  and then you show that it's equal to that which is equal to XY right? So it's just kind of algebra and that's the end of that proof. So these proofs are usually pretty easy to do.  Yeah, but this one in particular you can just pad the the the bit strings with zeros until you reach a power of two if you like and then it and then I'll always be able to divide.  Okay, so now we got a better.  runtime  Okay, so let's run through a how to solve these using the master theorem.  queso most  divide and conquer algorithms will give you a recursion that looks like this. So we're going to figure out how to solve it for everything. I know that most of you guys have seen this before I wanted to go into it in a little bit more detail so that you have an understanding of why the master theorem is what it is.  let's start off with the  Geometric series does anybody know what the closed form of this thing is?  R to the n + 1 - 1 / r - 1  What do you mean?  Yes any questions about that?  What if I did this?  What happens if R is equal to 1 then? What is the sum equal to?  And plus one. Okay, good. You guys should know this closed form.  Okay good.  So actually thinking about this.  in terms of our this thing behave differently for different values of our we've already seen that it would behave differently if R is equal to one or if R is not equal to 1  but it also as n goes to Infinity this thing behaves differently if R is less than 1 in ours greater than one. Okay. So far is less than 1 then this thing is actually constant right? It's it's it conversions. So it has an upper bound. So it's constant time if you think about an algorithm running in this amount of time.  FRS equal to 1 + 10 + 1 + we get linear time.  And if R is greater than 1 then this is just an exponential function and our this sum is actually big of art to the end.  Okay, so we get this nice.  kind of  three different scenarios based on what the value of R is here.  These are the three scenarios. That's what gives you the three cases in the master theorem.  Okay, so let's kind of break it down into these cases. Okay, so think about a divide-and-conquer problem you split up the original problem and this case I'm splitting it up into four, but you can just think about it as you're splitting it up into a different problems each of size and over be right.  And then you have a square different problem teacher size and over B squared and so on down to the lower case where you have size one. That's when you can put in the base case.  Okay, so  What the original multiplication algorithm that we saw where we divided into four. This would be kind of what it looks like, right?  so you be split up into four problems each of size and over to write and  In order to combine those all back up to the original problem.  You have to do it four times, right? So you basically add to x c x and many operations.  Can't bend as you go down. Now. You have 16 problems all size and over for right? So now you're adding a 4 x c x in  K and as you can see as you go down these levels the number of operations you need increases so we call this a bottom-heavy algorithm because most of the work is done at the at the bottom level and then it kind of goes up.  Okay, when we do it in two three now, you can see instead of 2 and 4. I'm getting 1.5 + 1.5 squared so it's still bottom-heavy, but it's not growing as much and so you're going to get a better run time.  Song I know we just have a few minutes left. So I'm going to kind of go through this kind of quickly since I know you've seen it before but I want you to see it again. We have a good understanding.  Okay, so during the case level of that of that tree. What have you done? What you've done a to the K many subproblems each of size n over B to the k?  And you're going to have to have combined them together in end to the D time but you're only combining little sub problems. So it's only going to take and Overby to the Kate to the Andover be to the K2 the D time.  Okay, so that's why you get this whole thing here.  and  you guys can do this as an exercise to show that these are equivalent.  So basically what we're saying is that this is how long it takes for each level based on K there are and there are log base B of and many levels so you add them all up and you get this summation.  Frank from K down to zero all the way up to log base B event.  So then  what is this summation look like it's basically a geometric Series, right? So it's behavior is dependent on how are relates to be to the D.  Does the same thing like we did before if a is less than b to the D? That means that A over B to the D is less than 1.  So, you know that that sum converges and all you're left with is end-to-end to the D.  If a is equal to B to the D, then you have A over B to the D is equal to 1.  And so that some is linear in in with respect to the upper bound of the summation. Basically, you're just  Adding One log by event many times. So that's why you get this one.  and then finally  He is greater than b to the D. Then you have A over B to the D is greater than 1 and you have that this summation kind of acts like an exponential and that's why you get this and you guys can use a exercise maybe to show that why those people  so that's where all of these things come from. You got the top-heavy the steady-state and the bottom-heavy so you don't have to prove this every time just wanted to give you a sense of why it works. Okay. So now we can just use it without proof in your homework in the quiz, whatever you like.  Okay. Have a nice weekend everyone. "
}